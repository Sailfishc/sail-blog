<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on 橙小张的博客</title>
        <link>https://blog.sailfishc.cn/posts/</link>
        <description>Recent content in Posts on 橙小张的博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Fri, 27 Dec 2019 12:03:29 +0800</lastBuildDate>
        <atom:link href="https://blog.sailfishc.cn/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>J.U.C 同步框架（AQS 框架）</title>
            <link>https://blog.sailfishc.cn/posts/2019/12/j.u.c-%E5%90%8C%E6%AD%A5%E6%A1%86%E6%9E%B6aqs-%E6%A1%86%E6%9E%B6/</link>
            <pubDate>Fri, 27 Dec 2019 12:03:29 +0800</pubDate>
            
            <guid>https://blog.sailfishc.cn/posts/2019/12/j.u.c-%E5%90%8C%E6%AD%A5%E6%A1%86%E6%9E%B6aqs-%E6%A1%86%E6%9E%B6/</guid>
            <description>本文转载自：biezhi.com https://www.cnblogs.com/dennyzhangdd/p/7218510.html
一、论文简介 闲来无事，看看源码，发现了一篇JDK作者的论文《The java.util.concurrent Synchronizer Framework》主要描述了作者对 AbstractQueuedSynchronizer 同步器框架的设计和实现。权威性毋庸置疑！自然需要拜读一下，配上中文翻译，希望大家能有所收获。
二、原文链接 论文英文版原文链接：http://gee.cs.oswego.edu/dl/papers/aqs.pdf
http://gee.cs.oswego.edu/ 这个是老李头的主页，里面有他的部分贡献，感兴趣的可以关注一下，老李头确实比较厉害。
三、中文翻译 摘要 在 J2SE 1.5 的 java.util.concurrent 包（下称 j.u.c 包）中，大部分的同步器（例如锁，屏障等等）都是基于 AbstractQueuedSynchronizer 类（下称 AQS 类），这个简单的框架而构建的。这个框架为同步状态的原子性管理、线程的阻塞和解除阻塞以及排队提供了一种通用的机制。这篇论文主要描述了这个框架基本原理、设计、实现、用法以及性能。
1. 背景介绍 通过 JCP 的 JSR166 规范，Java 的 1.5 版本引入了 j.u.c 包，这个包提供了一系列支持中等程度并发的类。这些组件是一系列的同步器（抽象数据类型(ADT)）。这些同步器主要维护着以下几个功能：内部同步状态的管理(例如：表示一个锁的状态是获取还是释放)，同步状态的更新和检查操作，且至少有一个方法会导致调用线程在同步状态被获取时阻塞，以及在其他线程改变这个同步状态时解除线程的阻塞。上述的这些的实际例子包括：互斥排它锁的不同形式、读写锁、信号量、屏障、Future、事件指示器以及传送队列等。
几乎任一同步器都可以用来实现其他形式的同步器。例如，可以用可重入锁实现信号量或者用信号量实现可重入锁。但是，这样做带来的复杂性，开销，不灵活使其至多只能是个二流工程，且缺乏吸引力。如果任何这样的构造方式不能在本质上比其他形式更简洁，那么开发者就不应该随意地选择其中的某个来构建另一个同步器。取而代之，JSR166 建立了一个小框架，AQS 类。这个框架为构造同步器提供一种通用的机制，并且被 j.u.c 包中大部分类使用，同时很多用户也用它来定义自己的同步器。
在这篇论文的下面部分会讨论这个框架的需求、设计与实现背后的主要思路、示例用法，以及性能指标的一些测量。
2 需求 2.1 功能 同步器一般包含两种方法，一种是 acquire，另一种是 release。acquire 操作阻塞调用的线程，直到或除非同步状态允许其继续执行。而 release 操作则是通过某种方式改变同步状态，使得一或多个被 acquire 阻塞的线程继续执行。
j.u.c 包中并没有对同步器的API做一个统一的定义。因此，有一些类定义了通用的接口（如 Lock），而另外一些则定义了其专有的版本。因此在不同的类中，acquire 和 release 操作的名字和形式会各有不同。例如：Lock.lock，Semaphore.acquire，CountDownLatch.await 和 FutureTask.get，在这个框架里，这些方法都是 acquire 操作。但是，J.U.C 为支持一系列常见的使用选项，在类间都有个一致约定。在有意义的情况下，每一个同步器都支持下面的操作：
 阻塞和非阻塞（例如 tryLock）同步 可选的超时设置，让调用者可以放弃等待 通过中断实现的任务取消，通常是分为两个版本，一个 acquire 可取消，而另一个不可以  同步器的实现根据其状态是否独占而有所不同。独占状态的同步器，在同一时间只有一个线程可以通过阻塞点，而共享状态的同步器可以同时有多个线程在执行。一般锁的实现类往往只维护独占状态，但是，例如计数信号量在数量许可的情况下，允许多个线程同时执行。为了使框架能得到广泛应用，这两种模式都要支持。</description>
            <content type="html"><![CDATA[<p>本文转载自：biezhi.com  <a href="https://www.cnblogs.com/dennyzhangdd/p/7218510.html"><a href="https://www.cnblogs.com/dennyzhangdd/p/7218510.html">https://www.cnblogs.com/dennyzhangdd/p/7218510.html</a></a></p>
<h1 id="heading">一、论文简介</h1>
<p>闲来无事，看看源码，发现了一篇JDK作者的论文《The java.util.concurrent Synchronizer Framework》主要描述了作者对 <code>AbstractQueuedSynchronizer</code> 同步器框架的设计和实现。权威性毋庸置疑！自然需要拜读一下，配上中文翻译，希望大家能有所收获。</p>
<h1 id="heading1">二、原文链接</h1>
<p>论文英文版原文链接：<a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf"><a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf">http://gee.cs.oswego.edu/dl/papers/aqs.pdf</a></a></p>
<p><a href="http://gee.cs.oswego.edu/"><a href="http://gee.cs.oswego.edu/">http://gee.cs.oswego.edu/</a></a> 这个是老李头的主页，里面有他的部分贡献，感兴趣的可以关注一下，老李头确实比较厉害。</p>
<h1 id="heading2">三、中文翻译</h1>
<h2 id="heading3">摘要</h2>
<p>在 J2SE 1.5 的 <code>java.util.concurrent</code> 包（下称 j.u.c 包）中，大部分的同步器（例如锁，屏障等等）都是基于 <code>AbstractQueuedSynchronizer</code> 类（下称 AQS 类），这个简单的框架而构建的。这个框架为同步状态的原子性管理、线程的阻塞和解除阻塞以及排队提供了一种通用的机制。这篇论文主要描述了这个框架基本原理、设计、实现、用法以及性能。</p>
<h2 id="1-">1. 背景介绍</h2>
<p>通过 JCP 的 <code>JSR166</code> 规范，Java 的 1.5 版本引入了 j.u.c 包，这个包提供了一系列支持中等程度并发的类。这些组件是一系列的同步器（抽象数据类型(ADT)）。这些同步器主要维护着以下几个功能：内部同步状态的管理(例如：表示一个锁的状态是获取还是释放)，同步状态的更新和检查操作，且至少有一个方法会导致调用线程在同步状态被获取时阻塞，以及在其他线程改变这个同步状态时解除线程的阻塞。上述的这些的实际例子包括：<strong>互斥排它锁的不同形式、读写锁、信号量、屏障、Future、事件指示器以及传送队列等</strong>。</p>
<p>几乎任一同步器都可以用来实现其他形式的同步器。例如，可以用可重入锁实现信号量或者用信号量实现可重入锁。但是，这样做带来的复杂性，开销，不灵活使其至多只能是个二流工程，且缺乏吸引力。如果任何这样的构造方式不能在本质上比其他形式更简洁，那么开发者就不应该随意地选择其中的某个来构建另一个同步器。取而代之，JSR166 建立了一个小框架，AQS 类。这个框架为构造同步器提供一种通用的机制，并且被 <code>j.u.c</code> 包中大部分类使用，同时很多用户也用它来定义自己的同步器。</p>
<p>在这篇论文的下面部分会讨论这个框架的需求、设计与实现背后的主要思路、示例用法，以及性能指标的一些测量。</p>
<h2 id="2-">2 需求</h2>
<h3 id="21-">2.1 功能</h3>
<p>同步器一般包含两种方法，一种是 <code>acquire</code>，另一种是 <code>release</code>。<code>acquire</code> 操作阻塞调用的线程，直到或除非同步状态允许其继续执行。而 <code>release</code> 操作则是通过某种方式改变同步状态，使得一或多个被 <code>acquire</code> 阻塞的线程继续执行。</p>
<p>j.u.c 包中并没有对同步器的API做一个统一的定义。因此，有一些类定义了通用的接口（如 Lock），而另外一些则定义了其专有的版本。因此在不同的类中，<code>acquire</code> 和 <code>release</code> 操作的名字和形式会各有不同。例如：<code>Lock.lock</code>，<code>Semaphore.acquire</code>，<code>CountDownLatch.await</code> 和 <code>FutureTask.get</code>，在这个框架里，这些方法都是 <code>acquire</code> 操作。但是，J.U.C 为支持一系列常见的使用选项，在类间都有个一致约定。在有意义的情况下，每一个同步器都支持下面的操作：</p>
<ul>
<li>阻塞和非阻塞（例如 <code>tryLock</code>）同步</li>
<li>可选的超时设置，让调用者可以放弃等待</li>
<li>通过中断实现的任务取消，通常是分为两个版本，一个 <code>acquire</code> 可取消，而另一个不可以</li>
</ul>
<p>同步器的实现根据其状态是否独占而有所不同。独占状态的同步器，在同一时间只有一个线程可以通过阻塞点，而共享状态的同步器可以同时有多个线程在执行。一般锁的实现类往往只维护独占状态，但是，例如计数信号量在数量许可的情况下，允许多个线程同时执行。为了使框架能得到广泛应用，这两种模式都要支持。</p>
<p>j.u.c 包里还定义了 <code>Condition</code> 接口，用于支持监控形式的 <code>await/signal</code> 操作，这些操作与独占模式的 <code>Lock</code> 类有关，且 <code>Condition</code> 的实现天生就和与其关联的 <code>Lock</code> 类紧密相关。</p>
<h3 id="22-">2.2 性能目标</h3>
<p>Java 内置锁（使用 <code>synchronized</code> 的方法或代码块）的性能问题一直以来都在被人们关注，并且已经有一系列的文章描述其构造（例如引文 <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>,<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>）。然而，大部分的研究主要关注的是在单核处理器上大部分时候使用于单线程上下文环境中时，如何尽量降低其空间（因为任何的 Java 对象都可以当成是锁）和时间的开销。对于同步器来说这些都不是特别重要：程序员仅在需要的时候才会使用同步器，因此并不需要压缩空间来避免浪费，并且同步器几乎是专门用在多线程设计中（特别是在多核处理器上），在这种环境下，偶尔的竞争是在意料之中的。因此，常规的 JVM 锁优化策略主要是针对零竞争的场景，而其它场景则使用缺乏可预见性的“慢速路径（slow paths）” ，所以常规的JVM锁优化策略并不适用于严重依赖于 J.U.C 包的典型多线程服务端应用。</p>
<p>这里主要的性能目标是可伸缩性，即在大部分情况下，即使，或特别在同步器有竞争的情况下，稳定地保证其效率。在理想的情况下，不管有多少线程正试图通过同步点，通过同步点的开销都应该是个常量。在某一线程被允许通过同步点但还没有通过的情况下，使其耗费的总时间最少，这是主要目标之一。然而，这也必须考虑平衡各种资源，包括总 CPU 时间的需求，内存负载以及线程调度的开销。例如：获取自旋锁通常比阻塞锁所需的时间更短，但是通常也会浪费 CPU 时钟周期，并且造成内存竞争，所以使用的并不频繁。</p>
<p>实现同步器的这些目标包含了两种不同的使用类型。大部分应用程序是最大化其总的吞吐量，容错性，并且最好保证尽量减少饥饿的情况。然而，对于那些控制资源分配的程序来说，更重要是去维持多线程读取的公平性，可以接受较差的总吞吐量。没有任何框架可以代表用户去决定应该选择哪一个方式，因此，应该提供不同的公平策略。</p>
<p>无论同步器的内部实现是多么的精雕细琢，它还是会在某些应用中产生性能瓶颈。因此，框架必须提供相应的监视工具让用户发现和缓和这些瓶颈。至少需要提供一种方式来确定有多少线程被阻塞了。</p>
<h2 id="3-">3 设计与实现</h2>
<p>同步器背后的基本思想非常简单。<code>acquire</code> 操作如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>synchronization state does not allow acquire<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    enqueue current thread <span style="color:#66d9ef">if</span> not already queued<span style="color:#f92672">;</span>
    possibly block current thread<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
dequeue current thread <span style="color:#66d9ef">if</span> it was queued<span style="color:#f92672">;</span>
</code></pre></div><p><code>release</code> 操作如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">update synchronization state<span style="color:#f92672">;</span>
<span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>state may permit a blocked thread to acquire<span style="color:#f92672">)</span>
    unblock one or more queued threads<span style="color:#f92672">;</span>
</code></pre></div><p>为了实现上述操作，需要下面三个基本组件的相互协作：</p>
<ul>
<li>同步状态的原子性管理</li>
<li>线程的阻塞与解除阻塞</li>
<li>队列的管理</li>
</ul>
<p>创建一个框架分别实现这三个组件是有可能的。但是，这会让整个框架既难用又没效率。例如：存储在队列节点的信息必须与解除阻塞所需要的信息一致，而暴露出的方法的签名必须依赖于同步状态的特性。</p>
<p>同步器框架的核心决策是为这三个组件选择一个具体实现，同时在使用方式上又有大量选项可用。这里有意地限制了其适用范围，但是提供了足够的效率，使得实际上没有理由在合适的情况下不用这个框架而去重新建造一个。</p>
<h3 id="31-">3.1 同步状态</h3>
<p>AQS 类使用单个 int（32位）来保存同步状态，并暴露出 <code>getState</code>、<code>setState</code> 以及 <code>compareAndSet</code> 操作来读取和更新这个状态。这些方法都依赖于 j.u.c atomic 包的支持，这个包提供了兼容 JSR133 中 <code>volatile</code> 在读和写上的语义，并且通过使用本地的 <code>compare-and-swap</code> 或 <code>load-linked/store-conditional</code> 指令来实现 <code>compareAndSetState</code>，使得仅当同步状态拥有一个期望值的时候，才会被原子地设置成新值。</p>
<p>将同步状态限制为一个 32 位的整形是出于实践上的考量。虽然 JSR166 也提供了 64 位 long 字段的原子性操作，但这些操作在很多平台上还是使用内部锁的方式来模拟实现的，这会使同步器的性能可能不会很理想。当然，将来可能会有一个类是专门使用 64 位的状态的。然而现在就引入这么一个类到这个包里并不是一个很好的决定（译者注：JDK1.6 中已经包含 <code>java.util.concurrent.locks.AbstractQueuedLongSynchronizer</code> 类，即使用 long 形式维护同步状态的一个 <code>AbstractQueuedSynchronizer</code> 版本）。目前来说，32 位的状态对大多数应用程序都是足够的。在 j.u.c 包中，只有一个同步器类可能需要多于 32 位来维持状态，那就是 <code>CyclicBarrier</code> 类，所以，它用了锁（该包中大多数更高层次的工具亦是如此）。</p>
<p>基于 AQS 的具体实现类必须根据暴露出的状态相关的方法定义 <code>tryAcquire</code> 和 <code>tryRelease</code> 方法，以控制 <code>acquire</code> 和 <code>release</code> 操作。当同步状态满足时，<code>tryAcquire</code> 方法必须返回 true，而当新的同步状态允许后续 <code>acquire</code> 时，<code>tryRelease</code> 方法也必须返回 true。这些方法都接受一个 int 类型的参数用于传递想要的状态。例如：可重入锁中，当某个线程从条件等待中返回，然后重新获取锁时，为了重新建立循环计数的场景。很多同步器并不需要这样一个参数，因此忽略它即可。</p>
<h3 id="32-">3.2 阻塞</h3>
<p>在 JSR166 之前，阻塞线程和解除线程阻塞都是基于 Java 内置监视器，没有基于 Java API 可以用来创建同步器。唯一可以选择的是 <code>Thread.suspend</code> 和 <code>Thread.resume</code>，但是它们都有无法解决的竞态问题，所以也没法用：当一个非阻塞的线程在一个正准备阻塞的线程调用 <code>suspend</code> 前调用了 <code>resume</code>，这个 <code>resume</code> 操作将不会有什么效果。</p>
<p>j.u.c 包有一个 <code>LockSuport</code> 类，这个类中包含了解决这个问题的方法。方法 <code>LockSupport.park</code> 阻塞当前线程除非/直到有个 <code>LockSupport.unpark</code> 方法被调用（unpark 方法被提前调用也是可以的）。unpark的调用是没有被计数的，因此在一个park调用前多次调用 unpark 方法只会解除一个 park 操作。另外，它们作用于每个线程而不是每个同步器。一个线程在一个新的同步器上调用 park 操作可能会立即返回，因为在此之前可能有 “剩余的” unpark 操作。但是，在缺少一个 unpark 操作时，下一次调用 park 就会阻塞。虽然可以显式地消除这个状态（译者注：就是多余的 unpark 调用），但并不值得这样做。在需要的时候多次调用 park 会更高效。</p>
<p>这个简单的机制与有些用法在某种程度上是相似的，例如 Solaris-9 的线程库，WIN32 中的“可消费事件”，以及 Linux 中的 NPTL 线程库。因此最常见的运行 Java 的平台上都有相对应的有效实现。（但目前 Solaris 和 Linux 上的 Sun Hotspot JVM 参考实现实际上是使用一个 pthread 的 condvar 来适应目前的运行时设计的）。park 方法同样支持可选的相对或绝对的超时设置，以及与 JVM 的 <code>Thread.interrupt</code> 结合 —— 可通过中断来 unpark 一个线程。</p>
<h3 id="33-">3.3 队列</h3>
<p>整个框架的关键就是如何管理被阻塞的线程的队列，该队列是严格的 FIFO 队列，因此，框架不支持基于优先级的同步。</p>
<p>同步队列的最佳选择是自身没有使用底层锁来构造的非阻塞数据结构，目前，业界对此很少有争议。而其中主要有两个选择：一个是 Mellor-Crummey 和 Scott 锁（MCS锁）<sup id="fnref:9"><a href="#fn:9" class="footnote-ref" role="doc-noteref">9</a></sup> 的变体，另一个是 Craig，Landin 和Hagersten 锁（CLH锁）<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup><sup id="fnref:8"><a href="#fn:8" class="footnote-ref" role="doc-noteref">8</a></sup><sup id="fnref:10"><a href="#fn:10" class="footnote-ref" role="doc-noteref">10</a></sup> 的变体。一直以来，<code>CLH</code> 锁仅被用于自旋锁。但是，在这个框架中，<code>CLH</code> 锁显然比 <code>MCS</code> 锁更合适。因为CLH锁可以更容易地去实现 “取消（cancellation）” 和 “超时” 功能，因此我们选择了 <code>CLH</code> 锁作为实现的基础。但是最终的设计已经与原来的 <code>CLH</code> 锁有较大的出入，因此下文将对此做出解释。</p>
<p><code>CLH</code> 队列实际上并不那么像队列，因为它的入队和出队操作都与它的用途（即用作锁）紧密相关。它是一个链表队列，通过两个字段 <code>head</code> 和 <code>tail</code> 来存取，这两个字段是可原子更新的，两者在初始化时都指向了一个空节点。</p>
<p><img src="http://ifeve.com/wp-content/uploads/2013/01/CLHNode.png" alt=""></p>
<p>一个新的节点 <code>node</code> 通过一个原子操作入队：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">do</span> <span style="color:#f92672">{</span>
    pred <span style="color:#f92672">=</span> tail<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span> <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span><span style="color:#f92672">!</span>tail<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSet</span><span style="color:#f92672">(</span>pred<span style="color:#f92672">,</span> node<span style="color:#f92672">)</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
</code></pre></div><p>每一个节点的 “释放” 状态都保存在其前驱节点中。因此，自旋锁的 “自旋” 操作就如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>pred<span style="color:#f92672">.</span><span style="color:#a6e22e">status</span> <span style="color:#f92672">!</span><span style="color:#f92672">=</span> RELEASED<span style="color:#f92672">)</span><span style="color:#f92672">;</span> <span style="color:#75715e">// spin
</span></code></pre></div><p>自旋后的出队操作只需将 <code>head</code> 字段指向刚刚得到锁的节点：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">head <span style="color:#f92672">=</span> node<span style="color:#f92672">;</span>
</code></pre></div><p><code>CLH</code> 锁的优点在于其入队和出队操作是快速、无锁的，以及无障碍的（即使在竞争下，某个线程总会赢得一次插入机会而能继续执行）；且探测是否有线程正在等待也很快（只要测试一下 head 是否与 tail 相等）；同时，“释放” 状态是分散的（译者注：几乎每个节点都保存了这个状态，当前节点保存了其后驱节点的 “释放” 状态，因此它们是分散的，不是集中于一块的。），避免了一些不必要的内存竞争。</p>
<p>在原始版本的 <code>CLH</code> 锁中，节点间甚至都没有互相链接。自旋锁中，<code>pred</code> 变量可以是一个局部变量。然而，<code>Scott</code> 和 <code>Scherer</code> 证明了通过在节点中显式地维护前驱节点，<code>CLH</code> 锁就可以处理 “超时” 和各种形式的 “取消”：如果一个节点的前驱节点取消了，这个节点就可以滑动去使用前面一个节点的状态字段。</p>
<p>为了将 <code>CLH</code> 队列用于阻塞式同步器，需要做些额外的修改以提供一种高效的方式定位某个节点的后继节点。在自旋锁中，一个节点只需要改变其状态，下一次自旋中其后继节点就能注意到这个改变，所以节点间的链接并不是必须的。但在阻塞式同步器中，一个节点需要显式地唤醒（unpark）其后继节点。</p>
<p>AQS 队列的节点包含一个 <code>next</code> 链接到它的后继节点。但是，由于没有针对双向链表节点的类似<code>compareAndSet</code> 的原子性无锁插入指令，因此这个next链接的设置并非作为原子性插入操作的一部分，而仅是在节点被插入后简单地赋值：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">pred<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> node<span style="color:#f92672">;</span>
</code></pre></div><p><code>next</code> 链接仅是一种优化。如果通过某个节点的 <code>next</code> 字段发现其后继结点不存在（或看似被取消了），总是可以使用 <code>pred</code> 字段从尾部开始向前遍历来检查是否真的有后续节点。</p>
<p>第二个对 <code>CLH</code> 队列主要的修改是将每个节点都有的状态字段用于控制阻塞而非自旋。在同步器框架中，仅在线程调用具体子类中的 <code>tryAcquire</code> 方法返回 true 时，队列中的线程才能从 <code>acquire</code> 操作中返回；而单个 “released” 位是不够的。但仍然需要做些控制以确保当一个活动的线程位于队列头部时，仅允许其调用 <code>tryAcquire</code>；这时的 <code>acquire</code> 可能会失败，然后（重新）阻塞。这种情况不需要读取状态标识，因为可以通过检查当前节点的前驱是否为head来确定权限。与自旋锁不同，读取 <code>head</code> 以保证复制时不会有太多的内存竞争（there is not enough memory contention reading head to warrant replication.）。然而，“取消” 状态必须存在于状态字段中。</p>
<p>队列节点的状态字段也用于避免没有必要的 park 和 unpark 调用。虽然这些方法跟阻塞原语一样快，但在跨越 Java 和 JVM runtime 以及操作系统边界时仍有可避免的开销。在调用 park 前，线程设置一个“唤醒（signal me）”位，然后再一次检查同步和节点状态。一个释放的线程会清空其自身状态。这样线程就不必频繁地尝试阻塞，特别是在锁相关的类中，这样会浪费时间等待下一个符合条件的线程去申请锁，从而加剧其它竞争的影响。除非后继节点设置了“唤醒”位（译者注：源码中为-1），否则这也可避免正在release的线程去判断其后继节点。这反过来也消除了这些情形：除非“唤醒”与“取消”同时发生，否则必须遍历多个节点来处理一个似乎为null的next字段。</p>
<p>同步框架中使用的 CLH 锁的变体与其他语言中的相比，主要区别可能是同步框架中使用的 CLH 锁需要依赖垃圾回收管理节点的内存，这就避免了一些复杂性和开销。但是，即使依赖 GC 也仍然需要在确定链接字段不再需要时将其置为 null。这往往可以与出队操作一起完成。否则，无用的节点仍然可触及，它们就没法被回收。</p>
<p>其它一些更深入的微调，包括 CLH 队列首次遇到竞争时才需要的初始空节点的延迟初始化等，都可以在J2SE1.5的版本的源代码文档中找到相应的描述。</p>
<p>抛开这些细节，基本的 <code>acquire</code> 操作的最终实现的一般形式如下（互斥，非中断，无超时）：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">if</span><span style="color:#f92672">(</span><span style="color:#f92672">!</span>tryAcquire<span style="color:#f92672">(</span>arg<span style="color:#f92672">)</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    node <span style="color:#f92672">=</span> create and enqueue <span style="color:#66d9ef">new</span> node<span style="color:#f92672">;</span>
    pred <span style="color:#f92672">=</span> node<span style="color:#960050;background-color:#1e0010">&#39;</span>s effective predecessor<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>pred is not head node <span style="color:#f92672">|</span><span style="color:#f92672">|</span> <span style="color:#f92672">!</span>tryAcquire<span style="color:#f92672">(</span>arg<span style="color:#f92672">)</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>pred<span style="color:#960050;background-color:#1e0010">&#39;</span>s signal bit is set<span style="color:#f92672">)</span>
            pard<span style="color:#f92672">(</span><span style="color:#f92672">)</span>
        <span style="color:#66d9ef">else</span>
            compareAndSet pred<span style="color:#960050;background-color:#1e0010">&#39;</span>s signal bit to <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        pred <span style="color:#f92672">=</span> node<span style="color:#960050;background-color:#1e0010">&#39;</span>s effective predecessor<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    head <span style="color:#f92672">=</span> node<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>release操作：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>tryRelease<span style="color:#f92672">(</span>arg<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> head node<span style="color:#960050;background-color:#1e0010">&#39;</span>s signal bit is set<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    compareAndSet head<span style="color:#960050;background-color:#1e0010">&#39;</span>s bit to <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    unpark head<span style="color:#960050;background-color:#1e0010">&#39;</span>s successor<span style="color:#f92672">,</span> <span style="color:#66d9ef">if</span> one exist
<span style="color:#f92672">}</span>
</code></pre></div><p><code>acquire</code> 操作的主循环次数依赖于具体实现类中 <code>tryAcquire</code> 的实现方式。另一方面，在没有 “取消” 操作的情况下，每一个组件的 <code>acquire</code> 和 <code>release</code> 都是一个 <code>O(1)</code> 的操作，忽略 park 中发生的所有操作系统线程调度。</p>
<p>支持 “取消” 操作主要是要在 <code>acquire</code> 循环里的 park 返回时检查中断或超时。由超时或中断而被取消等待的线程会设置其节点状态，然后unpark其后继节点。在有 “取消” 的情况下，判断其前驱节点和后继节点以及重置状态可能需要 <code>O(n)</code> 的遍历（n 是队列的长度）。由于 “取消” 操作，该线程再也不会被阻塞，节点的链接和状态字段可以被快速重建。</p>
<h3 id="34-">3.4 条件队列</h3>
<p>AQS 框架提供了一个 <code>ConditionObject</code> 类，给维护独占同步的类以及实现 <code>Lock</code> 接口的类使用。一个锁对象可以关联任意数目的条件对象，可以提供典型的管程风格的 <code>await</code>、<code>signal</code> 和 <code>signalAll</code> 操作，包括带有超时的，以及一些检测、监控的方法。</p>
<p>通过修正一些设计决策，<code>ConditionObject</code> 类有效地将条件（conditions）与其它同步操作结合到了一起。该类只支持 Java 风格的管程访问规则，这些规则中，仅当当前线程持有锁且要操作的条件（condition）属于该锁时，条件操作才是合法的（一些替代操作的讨论参考 <sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>）。这样，一个 <code>ConditionObject</code> 关联到一个 <code>ReentrantLock</code> 上就表现的跟内置的管程（通过 <code>Object.wait</code> 等）一样了。两者的不同仅仅在于方法的名称、额外的功能以及用户可以为每个锁声明多个条件。</p>
<p><code>ConditionObject</code> 使用了与同步器一样的内部队列节点。但是，是在一个单独的条件队列中维护这些节点的。<code>signal</code> 操作是通过将节点从条件队列转移到锁队列中来实现的，而没有必要在需要唤醒的线程重新获取到锁之前将其唤醒。</p>
<p>基本的 <code>await</code> 操作如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">create and add <span style="color:#66d9ef">new</span> node to conditon queue<span style="color:#f92672">;</span>
release lock<span style="color:#f92672">;</span>
block until node is on lock queue<span style="color:#f92672">;</span>
re<span style="color:#f92672">-</span>acquire lock<span style="color:#f92672">;</span>
</code></pre></div><p>signal操作如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">transfer the first node from condition queue to lock queue<span style="color:#f92672">;</span>
</code></pre></div><p>因为只有在持有锁的时候才能执行这些操作，因此他们可以使用顺序链表队列操作来维护条件队列（在节点中用一个 <code>nextWaiter</code> 字段）。转移操作仅仅把第一个节点从条件队列中的链接解除，然后通过 CLH 插入操作将其插入到锁队列上。</p>
<p>实现这些操作主要复杂在，因超时或 <code>Thread.interrupt</code> 导致取消了条件等待时，该如何处理。“取消” 和 “唤醒” 几乎同时发生就会有竞态问题，最终的结果遵照内置管程相关的规范。JSR133 修订以后，就要求如果中断发生在 <code>signal</code> 操作之前，<code>await</code> 方法必须在重新获取到锁后，抛出 <code>InterruptedException</code>。但是，如果中断发生在 <code>signal</code> 后，<code>await</code> 必须返回且不抛异常，同时设置线程的中断状态。</p>
<p>为了维护适当的顺序，队列节点状态变量中的一个位记录了该节点是否已经（或正在）被转移。“唤醒” 和 “取消” 相关的代码都会尝试用 <code>compareAndSet</code> 修改这个状态。如果某次 <code>signal</code> 操作修改失败，就会转移队列中的下一个节点（如果存在的话）。如果某次 “取消” 操作修改失败，就必须中止此次转移，然后等待重新获得锁。后面的情况采用了一个潜在的无限的自旋等待。在节点成功的被插到锁队列之前，被 “取消” 的等待不能重新获得锁，所以必须自旋等待 CLH 队列插入（即 <code>compareAndSet</code> 操作）被 “唤醒” 线程成功执行。这里极少需要自旋，且自旋里使用 <code>Thread.yield</code> 来提示应该调度某一其它线程，理想情况下就是执行 signal 的那个线程。虽然有可能在这里为 “取消” 实现一个帮助策略以帮助插入节点，但这种情况实在太少，找不到合适的理由来增加这些开销。在其它所有的情况下，这个基本的机制都不需要自旋或 <code>yield</code>，因此在单处理器上保持着合理的性能。</p>
<h2 id="4-">4 用法</h2>
<p>AQS 类将上述的功能结合到一起，并且作为一种基于 “模版方法模式” <sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup> 的基类提供给同步器。子类只需定义状态的检查与更新相关的方法，这些方法控制着 <code>acquire</code> 和 <code>release</code> 操作。然而，将 AQS 的子类作为同步器 ADT 并不适合，因为这个类必须提供方法在内部控制 <code>acquire</code> 和 <code>release</code> 的规则，这些都不应该被用户所看到。所有 <code>java.util.concurrent</code> 包中的同步器类都声明了一个私有的继承了 <code>AbstractQueuedSynchronizer</code> 的内部类，并且把所有同步方法都委托给这个内部类。这样各个同步器类的公开方法就可以使用适合自己的名称。</p>
<p>下面是一个最简单的 <code>Mutex</code> 类的实现，它使用同步状态 0 表示解锁，1 表示锁定。这个类并不需要同步方法中的参数，因此这里在调用的时候使用 0 作为实参，方法实现里将其忽略。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Mutex</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Sync</span> <span style="color:#66d9ef">extends</span> AbstractQueuedSynchronizer <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryAcquire</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> ignore<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">return</span> compareAndSetState<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> 1<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryRelease</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> ignore<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            setState<span style="color:#f92672">(</span>0<span style="color:#f92672">)</span><span style="color:#f92672">;</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
 
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Sync sync <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Sync<span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span> sync<span style="color:#f92672">.</span><span style="color:#a6e22e">acquire</span><span style="color:#f92672">(</span>0<span style="color:#f92672">)</span><span style="color:#f92672">;</span> <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unlock</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span> sync<span style="color:#f92672">.</span><span style="color:#a6e22e">release</span><span style="color:#f92672">(</span>0<span style="color:#f92672">)</span><span style="color:#f92672">;</span> <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这个例子的一个更完整的版本，以及其它用法指南，可以在J2SE的文档中找到。还可以有一些变体。如，<code>tryAcquire</code> 可以使用一种 “test-and-test-and-set” 策略，即在改变状态值前先对状态进行校验。</p>
<p>令人诧异的是，像互斥锁这样性能敏感的东西也打算通过委托和虚方法结合的方式来定义。然而，这正是现代动态编译器一直在重点研究的面向对象设计结构。编译器擅长将这方面的开销优化掉，起码会优化频繁调用同步器的那些代码。</p>
<p><code>AbstractQueuedSynchronizer</code> 类也提供了一些方法用来协助策略控制。例如，基础的 <code>acquire</code> 方法有可超时和可中断的版本。虽然到目前为止，我们的讨论都集中在像锁这样的独占模式的同步器上，但<code>AbstractQueuedSynchronizer</code> 类也包含另一组方法（如 acquireShared），它们的不同点在于 <code>tryAcquireShared</code> 和 <code>tryReleaseShared</code> 方法能够告知框架（通过它们的返回值）尚能接受更多的请求，最终框架会通过级联的 signal(cascading signals) 唤醒多个线程。</p>
<p>虽然将同步器序列化（持久化存储或传输）一般来说没有太大意义，但这些类经常会被用于构造其它类，例如线程安全的集合，而这些集合通常是可序列化的。<code>AbstractQueuedSynchronizer</code> 和 <code>ConditionObject</code> 类都提供了方法用于序列化同步状态，但不会序列化潜在的被阻塞的线程，也不会序列化其它内部暂时性的簿记（bookkeeping）变量。即使如此，在反序列化时，大部分同步器类也只仅将同步状态重置为初始值，这与内置锁的隐式策略一致 —— 总是反序列化到一个解锁状态。这相当于一个空操作，但仍必须显式地支持以便final字段能够反序列化。</p>
<h3 id="41-">4.1 公平调度的控制</h3>
<p>尽管同步器是基于 FIFO 队列的，但它们并不一定就得是公平的。可以注意到，在基础的 acquire 算法（3.3节）中，<code>tryAcquire</code> 是在入队前被执行的。因此一个新的 <code>acquire</code> 线程能够“窃取”本该属于队列头部第一个线程通过同步器的机会。</p>
<p>可闯入的 FIFO 策略通常会提供比其它技术更高的总吞吐率。当一个有竞争的锁已经空闲，而下一个准备获取锁的线程又正在解除阻塞的过程中，这时就没有线程可以获取到这个锁，如果使用闯入策略，则可减少这之间的时间间隔。与此同时，这种策略还可避免过分的，无效率的竞争，这种竞争是由于只允许一个（第一个）排队的线程被唤醒然后尝试 <code>acquire</code> 操作导致的。在只要求短时间持有同步器的场景中，创建同步器的开发者可以通过定义 <code>tryAcquire</code> 在控制权返回之前重复调用自己若干次，来进一步凸显闯入的效果。</p>
<p><img src="http://ifeve.com/wp-content/uploads/2013/01/fifo-300x90.png" alt=""></p>
<p>可闯入的 FIFO 同步器只有概率性的公平属性。锁队列头部一个解除了阻塞的线程拥有一次无偏向的机会（译者注：即不会偏向队头的线程也不会偏向闯入的线程）来赢得与闯入的线程之间的竞争，如果竞争失败，要么重新阻塞要么进行重试。然而，如果闯入的线程到达的速度比队头的线程解除阻塞快，那么在队列中的第一个线程将很难赢得竞争，以至于几乎总要重新阻塞，并且它的后继节点也会一直保持阻塞。对于短暂持有的同步器来说，在队列中第一个线程被解除阻塞期间，多处理器上很可能发生过多次闯入（译者注：即闯入的线程的 acquire 操作）和 <code>release</code> 了。正如下文所提到的，最终结果就是保持一或多个线程的高进展速度的同时，仍至少在一定概率上避免了饥饿的发生。</p>
<p>当有更高的公平性需求时，实现起来也很简单。如果需要严格的公平性，程序员可以把 <code>tryAcquire</code> 方法定义为，若当前线程不是队列的头节点（可通过 <code>getFirstQueuedThread</code> 方法检查，这是框架提供的为数不多的几个检测方法之一），则立即失败（返回false）。</p>
<p>一个更快，但非严格公平的变体可以这样做，若队列为空（判断的瞬间），仍然允许 <code>tryAcquire</code> 执行成功。在这种情况下，多个线程同时遇到一个空队列时可能会去竞争以使自己第一个获得锁，这样，通常至少有一个线程是无需入队列的。<code>java.util.concurrent</code> 包中所有支持公平模式的同步器都采用了这种策略。</p>
<p>尽管公平性设置在实践中很有用，但是它们并没有保障，因为 Java Language Specification 没有提供这样的调度保证。例如：即使是严格公平的同步器，如果一组线程永远不需要阻塞来达到互相等待，那么 JVM 可能会决定纯粹以顺序方式运行它们。在实际中，单处理器上，在抢占式上下文切换之前，这样的线程有可能是各自运行了一段时间。如果这样一个线程正持有某个互斥锁，它将很快会被切换回来，仅是为了释放其持有的锁，然后会继续阻塞，因为它知道有另外一个线程需要这把锁，这更增加了同步器可用但没有线程能来获取之间的间隔。同步器公平性设置在多处理器上的影响可能会更大，因为在这种环境下会产生更多的交错，因此一个线程就会有更多的机会发现锁被另一个线程请求。</p>
<p>在高竞争下，当保护的是短暂持有锁的代码体时，尽管性能可能会较差，但公平锁仍然能有效地工作。例如，当公平性锁保护的是相对长的代码体和/或有着相对长的锁间(inter-lock)间隔，在这种情况下，闯入只能带来很小的性能优势，但却可能会大大增加无限等待的风险。同步器框架将这些工程决策留给用户来确定。</p>
<h3 id="42-">4.2 同步器</h3>
<p>下面是 <code>java.util.concurrent</code> 包中同步器定义方式的概述：</p>
<p><code>ReentrantLock</code> 类使用 AQS 同步状态来保存锁（重复）持有的次数。当锁被一个线程获取时，<code>ReentrantLock</code> 也会记录下当前获得锁的线程标识，以便检查是否是重复获取，以及当错误的线程（译者注：如果线程不是锁的持有者，在此线程中执行该锁的 unlock 操作就是非法的）试图进行解锁操作时检测是否存在非法状态异常。<code>ReentrantLock</code> 也使用了 AQS 提供的 <code>ConditionObject</code>，还向外暴露了其它监控和监测相关的方法。<code>ReentrantLock</code> 通过在内部声明两个不同的 <code>AbstractQueuedSynchronizer</code> 实现类（提供公平模式的那个禁用了闯入策略）来实现可选的公平模式，在创建 <code>ReentrantLock</code> 实例的时候根据设置（译者注：即 ReentrantLock 构造方法中的 fair 参数）使用相应的 <code>AbstractQueuedSynchronizer</code> 实现类。</p>
<p><code>ReentrantReadWriteLock</code> 类使用 AQS 同步状态中的 16 位来保存写锁持有的次数，剩下的 16 位用来保存读锁的持有次数。<code>WriteLock</code> 的构建方式同 <code>ReentrantLock</code>。<code>ReadLock</code> 则通过使用 <code>acquireShared</code> 方法来支持同时允许多个读线程。</p>
<p><code>Semaphore</code> 类（计数信号量）使用 AQS 同步状态来保存信号量的当前计数。它里面定义的 <code>acquireShared</code> 方法会减少计数，或当计数为非正值时阻塞线程；<code>tryRelease</code> 方法会增加计数，可能在计数为正值时还要解除线程的阻塞。</p>
<p><code>CountDownLatch</code> 类使用 AQS 同步状态来表示计数。当该计数为 0 时，所有的 acquire 操作（译者注：acquire 操作是从 aqs 的角度说的，对应到 <code>CountDownLatch</code> 中就是 await 方法）才能通过。</p>
<p><code>FutureTask</code> 类使用 AQS 同步状态来表示某个异步计算任务的运行状态（初始化、运行中、被取消和完成）。设置（译者注：FutureTask 的 set 方法）或取消（译者注：FutureTask 的 cancel 方法）一个 <code>FutureTask</code> 时会调用 AQS 的 release 操作，等待计算结果的线程的阻塞解除是通过 AQS 的 <code>acquire</code> 操作实现的。</p>
<p><code>SynchronousQueues</code> 类（一种 CSP（Communicating Sequential Processes）形式的传递）使用了内部的等待节点，这些节点可以用于协调生产者和消费者。同时，它使用 AQS 同步状态来控制当某个消费者消费当前一项时，允许一个生产者继续生产，反之亦然。</p>
<p><code>java.util.concurrent</code> 包的使用者当然也可以为自定义的应用定义自己的同步器。例如，那些曾考虑到过的，但没有采纳进这个包的同步器包括提供WIN32事件各种风格的语义类，二元信号量，集中管理的锁以及基于树的屏障。</p>
<h2 id="5-">5 性能</h2>
<p>虽然 AQS 框架除了支持互斥锁外，还支持其它形式的同步方式，但锁的性能是最容易测量和比较的。即使如此，也还存在许多不同的测量方式。这里的实验主要是设计来展示锁的开销和吞吐量。</p>
<p>在每个测试中，所有线程都重复的更新一个伪随机数，该随机数由 <code>nextRandom(int seed)</code> 方法计算：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>seed <span style="color:#f92672">%</span> 127773<span style="color:#f92672">)</span> <span style="color:#f92672">*</span> 16807 <span style="color:#f92672">-</span> <span style="color:#f92672">(</span>seed <span style="color:#f92672">/</span> 127773<span style="color:#f92672">)</span> <span style="color:#f92672">*</span> 2836<span style="color:#f92672">;</span>
<span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>t <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> t <span style="color:#f92672">:</span> t <span style="color:#f92672">+</span> 0x7fffffff<span style="color:#f92672">;</span>
</code></pre></div><p>在每次迭代中，线程以概率S在一个互斥锁下更新共享的生成器，否则（译者注：概率为 1-S）更新其自己局部的生成器，此时是不需要锁的。如此，锁占用区域的耗时是短暂的，这就使线程持有锁期间被抢占时的外界干扰降到了最小。这个函数的随机性主要是为了两个目的：确定是否需要使用锁（这个生成器足以应付这里的需求），以及使循环中的代码不可能被轻易地优化掉。</p>
<p>这里比较了四种锁：内置锁，用的是 <code>synchronized</code> 块；互斥锁，用的是像第四节例子中的那样简单的 <code>Mutex</code> 类；可重入锁，用的是 <code>ReentrantLock</code>；以及公平锁，用的是 <code>ReentrantLock</code> 的公平模式。所有测试都运行在 J2SE1.5 JDK build46（大致与 beta2 相同）的 server 模式下。在收集测试数据前，测试程序先运行 20 次非竞争的测试，以排除 JVM “预热”（译者注：更多关于 “预热” 的内容，参见：Java 理论与实践: 动态编译与性能测量）过程的影响。除了公平模式下的测试只跑了一百万次迭代，其它每个线程中的测试都运行了一千万次迭代。</p>
<p>该测试运行在四个 <code>x86</code> 机器和四个 <code>UltraSparc</code> 机器上。所有 <code>x86</code> 机器都运行的是 RedHat 基于 NPTL 2.4 内核和库的 Linux 系统。所有的 <code>UltraSparc</code> 机器都运行的是 <code>Solaris-9</code>。测试时所有系统的负载都很轻。根据该测试的特征，并不要求系统完全空闲（译者注：即测试时操作系统上有其它较轻的负载也不会影响本次测试的结果。）。“4P” 这个名字反映出双核超线程的Xeon更像是4路机器，而不是2路机器。这里没有将测试数据规范化。如下所示，同步的相对开销与处理器的数量、类型、速度之间不具备简单的关系。</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>处理器数量</th>
<th>类型</th>
<th>速度(Mhz)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1P</td>
<td>1</td>
<td>Pentium3</td>
<td>900</td>
</tr>
<tr>
<td>2P</td>
<td>2</td>
<td>Pentium3</td>
<td>1400</td>
</tr>
<tr>
<td>2A</td>
<td>2</td>
<td>Athlon</td>
<td>2000</td>
</tr>
<tr>
<td>4P</td>
<td>2HT</td>
<td>Pentium4/Xeon</td>
<td>2400</td>
</tr>
<tr>
<td>1U</td>
<td>1</td>
<td>UltraSparc2</td>
<td>650</td>
</tr>
<tr>
<td>4U</td>
<td>4</td>
<td>UltraSparc2</td>
<td>450</td>
</tr>
<tr>
<td>8U</td>
<td>8</td>
<td>UltraSparc3</td>
<td>750</td>
</tr>
<tr>
<td>24U</td>
<td>24</td>
<td>UltraSparc3</td>
<td>750</td>
</tr>
</tbody>
</table>
<p><strong>表1 测试的平台</strong></p>
<h3 id="51-">5.1 开销</h3>
<p>无竞争情况下的开销是通过仅运行一个线程，将概率 <code>S</code> 为 1 时的每次迭代时间减去概率 <code>S</code> 为 0（访问共享内存的概率为 0）时的每次迭代时间得到的（译者注：这里的“概率S”即前文提到的 “概率 S”，概率为 0 时是没有锁操作的，概率为 1 时是每次都有锁操作，因此将概率为1时的耗时减去概率为 0 时的耗时就是整个锁操作的开销。）。表 2 以纳秒为单位显示了非竞争场景下每次锁操作的开销。<code>Mutex</code> 类最接近于框架的基本耗时，可重入锁的额外开销是记录当前所有者线程和错误检查的耗时，对于公平锁来说还包含开始时检查队列是否为空的耗时。</p>
<p>表格 2 也展示与内置锁的 “快速路径（fast path）” 对比，<code>tryAcquire</code> 的耗时。这里的差异主要反映出了各锁和机器中使用的不同的原子指令以及内存屏障的耗时。在多处理器上，这些指令常常是完全优于所有其它指令的。内置锁和同步器类之间的主要差别，显然是由于 Hotspot 锁在锁定和解锁时都使用了一次<code>compareAndSet</code>，而同步器的 acquire 操作使用了一次 <code>compareAndSet</code> ，但 release 操作用的是一次volatile写（即，多处理器上的一次内存屏障以及所有处理器上的重排序限制）。每个锁的绝对的和相对耗时因机器的不同而不同。</p>
<table>
<thead>
<tr>
<th>机器</th>
<th>内置</th>
<th>互斥</th>
<th>可重入</th>
<th>公平可重入</th>
</tr>
</thead>
<tbody>
<tr>
<td>1P</td>
<td>18</td>
<td>9</td>
<td>31</td>
<td>37</td>
</tr>
<tr>
<td>2P</td>
<td>58</td>
<td>71</td>
<td>77</td>
<td>81</td>
</tr>
<tr>
<td>2A</td>
<td>13</td>
<td>21</td>
<td>31</td>
<td>30</td>
</tr>
<tr>
<td>4P</td>
<td>116</td>
<td>95</td>
<td>109</td>
<td>117</td>
</tr>
<tr>
<td>1U</td>
<td>90</td>
<td>40</td>
<td>58</td>
<td>67</td>
</tr>
<tr>
<td>4U</td>
<td>122</td>
<td>82</td>
<td>100</td>
<td>115</td>
</tr>
<tr>
<td>8U</td>
<td>160</td>
<td>83</td>
<td>103</td>
<td>123</td>
</tr>
<tr>
<td>24U</td>
<td>161</td>
<td>84</td>
<td>108</td>
<td>119</td>
</tr>
</tbody>
</table>
<p><strong>表2 无竞争时的单锁开销（单位：纳秒）</strong></p>
<p>从另一个极端看，表 3 展示了概率 <code>S</code> 为 1，运行 256 个并发线程时产生了大规模的锁竞争下每个锁的开销。在完全饱和的情况下，可闯入的FIFO锁比内置锁的开销少了一个数量级（也就是更大的吞吐量），比公平锁更是少了两个数量级。这表现出即使有着极大的竞争，在维持线程进展方面可闯入FIFO策略的效率。</p>
<p>表3也说明了即使在内部开销比较低的情况下，公平锁的性能也完全是由上下文切换的时间所决定的。列出的时间大致上都与各平台上线程阻塞和解除线程阻塞的时间相称。</p>
<p>此外，后面增加的一个实验（仅使用机器 4P）表明，对于这里用到的短暂持有的锁，公平参数的设置在总差异中的影响很小。这里将线程终止时间间的差异记录成一个粗粒度的离散量数。在 4P 的机器上，公平锁的时间度量的标准差平均为 <code>0.7%</code>，可重入锁平均为 <code>6.0%</code>。作为对比，为模拟一个长时间持有锁的场景，测试中使每个线程在持有锁的情况下计算了16K次随机数。这时，总运行时间几乎是相同的（公平锁：9.79s，可重入锁：9.72s）。公平模式下的差异依然很小，标准差平均为 <code>0.1%</code>，而可重入锁上升到了平均 <code>29.5%</code>。</p>
<p>| 机器 | 内置 | 互斥 | 可重入 | 公平可重入 |
| 1P | 521 | 46 | 67 | 8327 |
| 2P | 930 | 108 | 132 | 14967 |
| 2A | 748 | 79 | 84 | 33910 |
| 4P | 1146 | 188 | 247 | 15328 |
| 1U | 879 | 153 | 177 | 41394 |
| 4U | 2590 | 347 | 368 | 30004 |
| 8U | 1274 | 157 | 174 | 31084 |
| 24U | 1983 | 160 | 182 | 32291 |</p>
<p><strong>表格3 饱和时的单锁开销（单位：纳秒）</strong></p>
<h3 id="52-">5.2 吞吐量</h3>
<p>大部分同步器都是用于无竞争和极大竞争之间的。这可以用实验在两个方面进行检查，通过修改固定个线程的竞争概率，和/或通过往拥有固定竞争概率的线程集合里增加更多的线程。为了说明这些影响，测试运行在不同的竞争概率和不同的线程数目下，都用的是可重入锁。附图使用了一个 slowdown 度量标准。</p>
<p><img src="http://ifeve.com/wp-content/uploads/2013/02/formula-300x66.jpg" alt=""></p>
<p>这里，t是总运行时间，b是一个线程在没有竞争或同步下的基线时间，n 是线程数，p 是处理器数，<code>S</code> 是共享访问的比例（译者注：即前面的竞争概率 S）。计算结果是实际执行时间与理想执行时间（通常是无法得到的）的比率，理想执行时间是通过使用 Amdahl’s 法则计算出来的。理想时间模拟了一次没有同步开销，没有因锁争用而导致线程阻塞的执行过程。即使这样，在很低的竞争下，相比理想时间，有一些测试结果却表现出了很小的速度增长，大概是由于基线和测试之间的优化、流水线等方面有着轻微的差别。</p>
<p>图中用以 2 为底的对数为比例进行了缩放。例如，值为 1 表示实际时间是理想时间的两倍，4 表示慢 16 倍。使用对数就不需要依赖一个随意的基线时间（这里指的是计算随机数的时间），因此，基于不同底数计算的结果表现出的趋势应该是类似的。这些测试使用的竞争概率从 <code>1/128</code>（标识为 “0.008”）到 1，以 2 的幂为步长，线程的数量从 1 到 1024，以 2 的幂的一半为步长。</p>
<p>在单处理器（1P 和 1U）上，性能随着竞争的上升而下降，但不会随着线程数的增加而下降。多处理器在遭遇竞争时，性能下降的更快。根据多处理器相关的图表显示，开始出现的峰值处虽然只有几个线程的竞争，但相对性能通常却最差。这反映出了一个性能的过渡区域，在这里闯入的线程和被唤醒的线程都准备获取锁，这会让它们频繁的迫使对方阻塞。在大部分时候，过渡区域后面会紧接着一个平滑区域，因为此时几乎没有空闲的锁，所以会与单处理器上顺序执行的模式差不多；在多处理器机器上会较早进入平滑区域。例如，请注意，在满竞争（标识为“1.000”）下这些值表示，在处理器越少的机器上，会有更糟糕的相对速度下降。</p>
<p>根据这些结果，可以针对阻塞（park/unpark）做进一步调优以减少上下文切换和相关的开销，这会给本框架带来小但显著的提升。此外，在多处理器上为短时间持有的但高竞争的锁采用某种形式的适应性自旋，可以避免这里看到的一些波动，这对同步器类大有裨益。虽然在跨不同上下文时适应性自旋很难很好的工作，但可以使用本框架为遇到这类使用配置的特定应用构建一个自定义形式的锁。</p>
<p><img src="https://images2015.cnblogs.com/blog/584866/201707/584866-20170721153333433-1036091107.jpg" alt=""></p>
<p><img src="https://images2015.cnblogs.com/blog/584866/201707/584866-20170721153344933-80322669.jpg" alt=""></p>
<p><img src="https://images2015.cnblogs.com/blog/584866/201707/584866-20170721153353714-548675583.jpg" alt=""></p>
<p><img src="https://images2015.cnblogs.com/blog/584866/201707/584866-20170721153402620-2093158242.jpg" alt=""></p>
<h2 id="6-">6 总结</h2>
<p>本文撰写之时，<code>java.util.concurrent</code> 包中的同步器框架还太新所以还不能在实践中使用。因此在 J2SE 1.5 最终版本发布之前都很难看到其大范围的使用，并且，它的设计，API 实现以及性能肯定还有无法预料的后果。但是，此时，这个框架明显能胜任其基本的目标，即为创建新的同步器提供一个高效的基础。</p>
<h2 id="7-">7 致谢</h2>
<p>Thanks to Dave Dice for countless ideas and advice during the development of this framework, to Mark Moir and Michael Scott for urging consideration of CLH queues, to David Holmes for critiquing early versions of the code and API, to Victor Luchangco and Bill Scherer for reviewing previous incarnations of the source code, and to the other members of the JSR166 Expert Group (Joe Bowbeer, Josh Bloch, Brian Goetz, David Holmes, and Tim Peierls) as well as Bill Pugh, for helping with design and specifications and commenting on drafts of this paper. Portions of this work were made possible by a DARPA PCES grant, NSF grant EIA-0080206 (for access to the 24way Sparc) and a Sun Collaborative Research Grant.</p>
<h1 id="heading4">参考文献</h1>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Agesen, O., D. Detlefs, A. Garthwaite, R. Knippel, Y. S.Ramakrishna, and D. White. An Efficient Meta-lock for Implementing Ubiquitous Synchronization. ACM OOPSLA Proceedings, 1999.<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#8617;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>Andrews, G. Concurrent Programming. Wiley, 1991.<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#8617;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>Bacon, D. Thin Locks: Featherweight Synchronization for Java. ACM PLDI Proceedings, 1998.<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#8617;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>Buhr, P. M. Fortier, and M. Coffin. Monitor Classification,ACM Computing Surveys, March 1995.<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#8617;</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p>Craig, T. S. Building FIFO and priority-queueing spin locks from atomic swap. Technical Report TR 93-02-02,Department of Computer Science, University of Washington, Feb. 1993.<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#8617;</a></p>
</li>
<li id="fn:6" role="doc-endnote">
<p>Gamma, E., R. Helm, R. Johnson, and J. Vlissides. Design Patterns, Addison Wesley, 1996.<a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#8617;</a></p>
</li>
<li id="fn:7" role="doc-endnote">
<p>Holmes, D. Synchronisation Rings, PhD Thesis, Macquarie University, 1999.<a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#8617;</a></p>
</li>
<li id="fn:8" role="doc-endnote">
<p>Magnussen, P., A. Landin, and E. Hagersten. Queue locks on cache coherent multiprocessors. 8th Intl. Parallel Processing Symposium, Cancun, Mexico, Apr. 1994.<a href="#fnref:8" class="footnote-backref" role="doc-backlink">&#8617;</a></p>
</li>
<li id="fn:9" role="doc-endnote">
<p>Mellor-Crummey, J.M., and M. L. Scott. Algorithms for Scalable Synchronization on Shared-Memory Multiprocessors. ACM Trans. on Computer Systems,February 1991<a href="#fnref:9" class="footnote-backref" role="doc-backlink">&#8617;</a></p>
</li>
<li id="fn:10" role="doc-endnote">
<p>M. L. Scott and W N. Scherer III. Scalable Queue-Based Spin Locks with Timeout. 8th ACM Symp. on Principles and Practice of Parallel Programming, Snowbird, UT, June 2001.<a href="#fnref:10" class="footnote-backref" role="doc-backlink">&#8617;</a></p>
</li>
<li id="fn:11" role="doc-endnote">
<p>Sun Microsystems. Multithreading in the Solaris Operating Environment. White paper available at <a href="http://wwws.sun.com/software/solaris/whitepapers.html">http://wwws.sun.com/software/solaris/whitepapers.html</a> 2002.<a href="#fnref:11" class="footnote-backref" role="doc-backlink">&#8617;</a></p>
</li>
<li id="fn:12" role="doc-endnote">
<p>Zhang, H., S. Liang, and L. Bak. Monitor Conversion in a Multithreaded Computer System. United States Patent 6,691,304. 2004.<a href="#fnref:12" class="footnote-backref" role="doc-backlink">&#8617;</a></p>
</li>
</ol>
</section>
]]></content>
        </item>
        
        <item>
            <title>如何使用Unit testing健壮Java代码</title>
            <link>https://blog.sailfishc.cn/posts/2019/12/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8unit-testing%E5%81%A5%E5%A3%AEjava%E4%BB%A3%E7%A0%81/</link>
            <pubDate>Tue, 03 Dec 2019 23:57:32 +0800</pubDate>
            
            <guid>https://blog.sailfishc.cn/posts/2019/12/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8unit-testing%E5%81%A5%E5%A3%AEjava%E4%BB%A3%E7%A0%81/</guid>
            <description>前言：测试的道理，推荐下王垠的博客，这篇博客不会提高你的测试水平，但是有一些理论和方法上的指导。
 在之前对于测试一直处于写Test Case的状态，使用JUnit结合Spring Test跑下接口，使用断言或者格式化的JSON结果比对下结果，这样也平安无事的写了一段时间的代码，随着对代码的一些要求，去学习了一些书籍和资料，有了一些总结，开始使用Unit testing来健壮我们的Java代码吧。
目录  聊聊我为什么要写这篇Unit Test的文章 Unit testing的目的和要解决的问题 Unit testing的基础 Unit testing的设计原则 Unit testing实践中的问题 使用Groovy来编写测试  我为什么要写这篇Unit testing的文章  写好代码应该是一个有追求的程序员对自己的基本要求
 在初入Java时沉浸在学习各种框架的谜团里，在工作中开始关注自己的代码质量，期间看了《重构》、《重构与模式》，之后接触到了敏捷开发，去了解TDD，就开始实践TDD了，当然，这篇文章不是写TDD（Test Driven Development）的。我也一直在找一本适合我的Test书籍，一直没合适的，期间找到了几本：
 《程序开发人员测试指南》 《Junit实战》  之后白衣推荐了《有效的单元测试》，立即入了这本书，发现这本书很符合我现在的情况，目前书还没看完，先大致的浏览了一遍，想结合耗哥（左耳朵耗子）在专栏中关于高效学习的模板写这篇文章，这也是写本文的初衷。
Unit testing的目的和要解决的问题 维基百科定义：Unit testing - Wikipedia
 In computer programming, unit testing is a software testing method by which individual units of source code, sets of one or more computer program modules together with associated control data, usage procedures, and operating procedures, are tested to determine whether they are fit for use.</description>
            <content type="html"><![CDATA[<blockquote>
<p>前言：<a href="http://www.yinwang.org/blog-cn/2016/09/14/tests">测试的道理</a>，推荐下王垠的博客，这篇博客不会提高你的测试水平，但是有一些理论和方法上的指导。</p>
</blockquote>
<p>在之前对于测试一直处于写Test Case的状态，使用JUnit结合Spring Test跑下接口，使用断言或者格式化的JSON结果比对下结果，这样也平安无事的写了一段时间的代码，随着对代码的一些要求，去学习了一些书籍和资料，有了一些总结，开始使用Unit testing来健壮我们的Java代码吧。</p>
<h2 id="heading">目录</h2>
<ul>
<li>聊聊我为什么要写这篇Unit Test的文章</li>
<li>Unit testing的目的和要解决的问题</li>
<li>Unit testing的基础</li>
<li>Unit testing的设计原则</li>
<li>Unit testing实践中的问题</li>
<li>使用Groovy来编写测试</li>
</ul>
<h2 id="unit-testing">我为什么要写这篇Unit testing的文章</h2>
<blockquote>
<p>写好代码应该是一个有追求的程序员对自己的基本要求</p>
</blockquote>
<p>在初入Java时沉浸在学习各种框架的谜团里，在工作中开始关注自己的代码质量，期间看了《重构》、《重构与模式》，之后接触到了敏捷开发，去了解TDD，就开始实践TDD了，当然，这篇文章不是写TDD（Test Driven Development）的。我也一直在找一本适合我的Test书籍，一直没合适的，期间找到了几本：</p>
<ul>
<li>《程序开发人员测试指南》</li>
<li>《Junit实战》</li>
</ul>
<p>之后白衣推荐了《有效的单元测试》，立即入了这本书，发现这本书很符合我现在的情况，目前书还没看完，先大致的浏览了一遍，想结合耗哥（左耳朵耗子）在专栏中关于高效学习的模板写这篇文章，这也是写本文的初衷。</p>
<h2 id="unit-testing1">Unit testing的目的和要解决的问题</h2>
<p>维基百科定义：<a href="https://en.wikipedia.org/wiki/Unit_testing">Unit testing - Wikipedia</a></p>
<blockquote>
<p>In computer programming, unit testing is a software testing method by which individual units of source code, sets of one or more computer program modules together with associated control data, usage procedures, and operating procedures, are tested to determine whether they are fit for use.[1]</p>
</blockquote>
<p>我自己的看法是：</p>
<ul>
<li>验证Source Code的正确性及可用性</li>
<li>提高开发效率</li>
<li>写出更好的代码</li>
</ul>
<h2 id="unit-testing2">Unit testing的基础</h2>
<p>为了更好地描述出一些概念，我使用Junit作为Unit testing的工具结合一些案例来说明。</p>
<h3 id="assert">断言（assert）</h3>
<blockquote>
<p>有一个函数<code>add</code>,实现一个两个数相加</p>
</blockquote>
<pre><code>public int add(int a, int b) {
    return a + b;
}
</code></pre><blockquote>
<p>使用Junit进行测试</p>
</blockquote>
<pre><code>@Test
public void add() {
    int sum = service.add(1, 2);
    assertEquals(3, sum);
}
</code></pre><p>这里的assertEquals就是断言，断定<code>add</code>方法的输出结果是我们期望(expect)的3.</p>
<blockquote>
<p>断言的好处：</p>
</blockquote>
<p>咱们先说下如果没有断言，那么我们会将sum的结果打印到控制台，然后看下是不是3，如果是3那说明是符合我们的要求的，如果不是，那么不符合要求，这里涉及到了人手工的去比对结果，这里的结果只有一个，还好比对，如果有很多，那么大大的增加了比对中出现的问题。
断言的好处：减少人工处理，使用计算机帮我们验证结果</p>
<blockquote>
<p>断言类型：</p>
</blockquote>
<ul>
<li>assertEquals：断言两个对象（或基本对象）是否相等</li>
<li>assertArrayEquals：断言两个数组包含相同的元素</li>
<li>assertTrue：断言语句为真</li>
<li>assertFalse：断言语句为假</li>
<li>assertNull：断言对象引用为空</li>
<li>assertNotNull：断言对象引用不为空</li>
<li>assertSame：断言两个对象引用相同的实例</li>
<li>assertNotSame：断言两个对象引用不同的实例</li>
<li>assertThat：断言对象满足条件</li>
</ul>
<h3 id="mock">Mock</h3>
<h2 id="heading1">参考资源</h2>
<ul>
<li><a href="http://zhangyi.xyz/handout-tdd-code-kata/">TDD编码实战讲义 | 斑斓</a></li>
<li><a href="https://gitbook.cn/books/58c2ac77306e988f12697f16/index.html">深度解读测试驱动开发（TDD）</a></li>
<li><a href="https://insights.thoughtworks.cn/talk-about-tdd-again/">让我们再聊聊TDD – ThoughtWorks洞见</a></li>
<li>TDD并不是看上去的那么美：https://coolshell.cn/articles/3649.html</li>
<li><a href="https://junit.org/junit4/">JUnit -     About</a></li>
<li><a href="https://martinfowler.com/articles/mocksArentStubs.html">Mocks Aren’t Stubs</a></li>
<li><a href="https://github.com/mockito/mockito/wiki/How-to-write-good-tests">How to write good tests · mockito/mockito Wiki · GitHub</a></li>
<li><a href="https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html">Mockito - mockito-core 3.1.0 javadoc</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>这可能是最全的Redis分布式锁介绍</title>
            <link>https://blog.sailfishc.cn/posts/2019/11/%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BB%8B%E7%BB%8D/</link>
            <pubDate>Thu, 21 Nov 2019 07:01:41 +0800</pubDate>
            
            <guid>https://blog.sailfishc.cn/posts/2019/11/%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BB%8B%E7%BB%8D/</guid>
            <description>目录  分布式锁介绍 分布式锁的应用场景 分布式锁几种实现方式介绍  Redis ZK 数据库   Redis实现分布式锁的实现原理 易宝分布式锁分析 *实现Redis分布式锁的正确操作 实现Redis分布式锁的错误案例 Redis分布式锁的问题 Redisson的原理及Redission的一些讨论 基于Redisson的分布式锁的使用  分布式锁介绍 定义  A distributed lock manager (DLM) runs in every machine in a cluster, with an identical copy of a cluster-wide lock database. In this way a DLM provides software applications which are distributed across a cluster on multiple machines with a means to synchronize their accesses to shared resources .</description>
            <content type="html"><![CDATA[<h2 id="heading">目录</h2>
<ul>
<li>分布式锁介绍</li>
<li>分布式锁的应用场景</li>
<li>分布式锁几种实现方式介绍
<ul>
<li>Redis</li>
<li>ZK</li>
<li>数据库</li>
</ul>
</li>
<li>Redis实现分布式锁的实现原理</li>
<li>易宝分布式锁分析</li>
<li>*实现Redis分布式锁的正确操作</li>
<li>实现Redis分布式锁的错误案例</li>
<li>Redis分布式锁的问题</li>
<li>Redisson的原理及Redission的一些讨论</li>
<li>基于Redisson的分布式锁的使用</li>
</ul>
<h2 id="heading1">分布式锁介绍</h2>
<h3 id="heading2">定义</h3>
<blockquote>
<p>A <strong>distributed lock manager</strong> (DLM) runs in every machine in a cluster, with an identical copy of a cluster-wide lock database. In this way a DLM provides  <a href="https://en.wikipedia.org/wiki/Software_application">software applications</a>  which are  <a href="https://en.wikipedia.org/wiki/Distributed_programming">distributed</a>  across a cluster on multiple machines with a means to synchronize their accesses to  <a href="https://en.wikipedia.org/wiki/Shared_resource">shared resources</a> .</p>
</blockquote>
<p>维基百科上的定义是：在多台机器上同步对共享资源访问的方式。</p>
<p>共享资源包含：</p>
<ul>
<li>数据库</li>
<li>Table</li>
<li>文件</li>
<li>共享内存</li>
</ul>
<h3 id="heading3">特性</h3>
<ul>
<li>互斥性。在任意时刻，只有一个客户端能持有锁。</li>
<li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li>
<li>具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。</li>
<li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li>
</ul>
<h2 id="heading4">分布式锁的应用场景</h2>
<p>Redis在现在的项目中使用的很多，英国剑桥大学的分布式系统的研究员Martin Kleppmann总结了分布式锁的两个场景：</p>
<blockquote>
<ul>
<li><strong>Efficiency:</strong> Taking a lock saves you from unnecessarily doing the same work twice (e.g. some expensive computation). If the lock fails and two nodes end up doing the same piece of work, the result is a minor increase in cost (you end up paying 5 cents more to AWS than you otherwise would have) or a minor inconvenience (e.g. a user ends up getting the same email notification twice).</li>
<li><strong>Correctness:</strong> Taking a lock prevents concurrent processes from stepping on each others’ toes and messing up the state of your system. If the lock fails and two nodes concurrently work on the same piece of data, the result is a corrupted file, data loss, permanent inconsistency, the wrong dose of a drug administered to a patient, or some other serious problem.</li>
</ul>
</blockquote>
<p><a href="http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">How to do distributed locking — Martin Kleppmann’s blog</a> 这篇文章中比较清楚的描述了分布式锁的两个场景：</p>
<ul>
<li>效率：使用锁节省去做不必要的相同的事情，例如发送了相同的两封用户邮件，两台机器做相同事的事情。</li>
<li>正确性：使用分布式锁防止并发进程弄乱系统的状态，如果分布式锁失效，两个并发的节点操作了相同的数据，导致文件损坏，数据永久丢失，会造成严重的问题。</li>
</ul>
<h3 id="heading5">实际应用场景</h3>
<blockquote>
<p>场景一</p>
</blockquote>
<p>商户入网接口，一个身份证号只允许注册一个商户，为了避免多个相同的身份证号同时请求，需要使用分布式锁来保证同一时间只能有一个请求。</p>
<blockquote>
<p>场景二</p>
</blockquote>
<p>一笔订单APP端用户在修改收货地址，管理后台端商家同时在修改订单备注，这二个请求同时到达的话，如果不借助db的事务，很容易造成行锁竞争，但用事务的话，db的性能显然比不上redis轻量</p>
<blockquote>
<p>场景三：交易支付回调</p>
</blockquote>
<p>支付成功后支付公司回调消息A，交易系统接收到消息状态为A，进行处理，在处理过程中，支付公司由于系统1问题又发送了一条消息状态为B（相同订单号），B状态消息可能导致订单数据错误</p>
<blockquote>
<p>场景四</p>
</blockquote>
<p>手机三要素验证的列子：(A渠道系统，业务B系统，外部厂商C系统)
(1)B业务系统调用A渠道系统，验证传入的手机、身份证、号码三要素是否一一致。
(2)A渠道系统再调用外部厂商C系统。
(3)A渠道系统将结果返回给B业务系统。
这3个过程中，(2)过程，外部厂商的调用时是需要计费的。当B业务系统并发量很高时，有100笔相同的三要素校验，由于是相同的三要素，A渠道只要调用一次厂商即可知道结果。那么A渠道系统如何控制不让100笔请求全部去访问外部厂商C系统呢？可以使用分布式锁</p>
<h2 id="heading6">分布式锁几种实现方式介绍</h2>
<blockquote>
<p>分布式锁的操作</p>
</blockquote>
<ul>
<li>boolean lock()</li>
<li>boolean tryLock()</li>
<li>boolean tryLock(int timeout)</li>
<li>void unlock</li>
</ul>
<blockquote>
<p>为了减少篇幅，下面几种实现方式只考虑lock和unlock的思路。</p>
</blockquote>
<h3 id="mysql">MySQL实现分布式锁</h3>
<blockquote>
<p>表结构设计</p>
</blockquote>
<ul>
<li>id</li>
<li>key</li>
<li>value</li>
<li>retryNum</li>
<li>createTime</li>
<li>updateTime</li>
</ul>
<blockquote>
<p>加锁操作</p>
</blockquote>
<pre><code>	// 使用排它锁
	Lock  = select * from tbl_lock where key = ‘’ for update;
	if ( Lock != null ){
		if ( value == Lock.value) { 
			// 相同的client
			retryNum++
		}else {
			return false;
		}
	}else {
		// 拿到锁
		insert lock..
		return true;
	}
	
	……

	lock.unlock()
</code></pre><blockquote>
<p>分析</p>
</blockquote>
<ul>
<li>实现分析
<ul>
<li>在Innodb下使用<code>for update</code>加行锁（排它锁），其他client（事务）不能对其进行操作</li>
</ul>
</li>
<li>优点
<ul>
<li>理解简单，无需额外中间件</li>
</ul>
</li>
<li>缺点
<ul>
<li>性能比较低</li>
<li>实现方式较为麻烦（不是复杂）</li>
</ul>
</li>
</ul>
<h3 id="zk">ZK实现分布式锁</h3>
<p>Zookeeper不太熟悉，但是从Zookeeper的客户端<strong>Curator</strong>官网中查看到实现分布锁的一段代码：</p>
<pre><code>InterProcessMutex lock = new InterProcessMutex(client, lockPath);
if ( lock.acquire(maxWait, waitUnit) ) 
{
    try 
    {
        // do some work inside of the critical section here
    }
    finally
    {
        lock.release();
    }
}
</code></pre><p>ZK主要利用得失自己的临时有序节点+watch机制：</p>
<ul>
<li>ClientA和ClientB同时获取同一个锁</li>
<li>会生成两个有序节点
<ul>
<li>/00001</li>
<li>/00002</li>
</ul>
</li>
<li>但是这时候只有clientA获取到锁（第一个节点）</li>
<li>等ClientA处理完成后进行release后唤醒clientB</li>
<li>client获取到锁</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Sailfishc/picRepo/master/iTz1U2.jpg" alt="Zk获取分布式锁"></p>
<blockquote>
<p>分析</p>
</blockquote>
<ul>
<li>优点
<ul>
<li>Zookeeper不需要配置锁超时，由于我们设置节点是临时节点，我们的每个机器维护着一个ZK的session，通过这个session，ZK可以判断机器是否宕机。如果我们的机器挂掉的话，那么这个临时节点对应的就会被删除，所以我们不需要关心锁超时。</li>
<li>ZK高可用程度比较高</li>
</ul>
</li>
<li>缺点
<ul>
<li>ZK需要额外维护，增加维护成本，性能和Mysql相差不大，依然比较差。并且需要开发人员了解ZK是什么。</li>
</ul>
</li>
</ul>
<h3 id="redis">Redis实现分布式锁</h3>
<blockquote>
<p>实现</p>
</blockquote>
<p>Redis官网是这么描述单机分布式的实现的：</p>
<blockquote>
<p>To acquire the lock, the way to go is the following: <code>    SET resource_name my_random_value NX PX 30000</code>The command will set the key only if it does not already exist (NX option), with an expire of 30000 milliseconds (PX option). The key is set to a value “my<em>random</em>value”. This value must be unique across all clients and all lock requests.</p>
</blockquote>
<p>获取锁的方式是：set 资源名称，随机值 NX PX 30000，这条命令只有在key不存在时才会设置，有效期是30000毫秒，这个key设置的value是一个随机值，这个值必须唯一贯穿在客户端加锁的请求中。</p>
<blockquote>
<p>释放锁</p>
</blockquote>
<p>remove the key only if it exists and the value stored at the key is exactly the one I expect to be. This is accomplished by the following Lua script:</p>
<pre><code>if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then
    return redis.call(“del”,KEYS[1])
else
    return 0
end
</code></pre><p>释放锁的条件是这个key存在并且value是我期望的，这是通过以下Lua脚本完成的。</p>
<p>Redis分布式锁使我们要重点分析的，这里先分简要分析下优缺点：</p>
<ul>
<li>优点
<ul>
<li>实现简单，性能高</li>
</ul>
</li>
<li>缺点
<ul>
<li>要配置超时时间</li>
<li>单机问题，不能做到高可用</li>
</ul>
</li>
</ul>
<h2 id="heading7">易宝分布式锁分析</h2>
<h3 id="heading8">源码分析</h3>
<ul>
<li>地址：com.yeepay.utils.lock.impl.RedisLock</li>
</ul>
<blockquote>
<p>简要分析Redis分布式锁步骤</p>
</blockquote>
<p>回头来分析下Redis官网给出的案例，加锁是的几个必要条件：</p>
<ul>
<li>value要唯一</li>
<li>需要在一个指令中使用setNX PX指令</li>
</ul>
<p>Value唯一是要解决如果安全性，例如clientA删除了clientB的锁的这种情况，setNX PX要放在一条原子指令中是因为如果先设置了NX，在设置PX指令的时候客户端宕机，会发生死锁（锁释放不了的情况）</p>
<p>释放锁使用了Lua脚本，原因也是Redis目前不支持比对value的值，然后去删除锁的操作，所以使用了Lua脚本来达到一致性的效果，这类似MySQL中使用存储过程一样。</p>
<h3 id="heading9">易宝分布式锁的一些问题</h3>
<blockquote>
<p>expire seconds 单位不正确，不是second，而是millis</p>
</blockquote>
<pre><code>09:45:53.985 [main] DEBUG com.yeepay.utils.lock.utils.RedisClientUtils - get lock success ,key=key, expire seconds=10000
</code></pre><blockquote>
<p>lock方法不太全，将lock方法实现为了tryLock的功能</p>
</blockquote>
<h3 id="heading10">错误案例</h3>
<blockquote>
<p>错误案例一</p>
</blockquote>
<pre><code>public static void wrongGetLock1(Jedis jedis, String lockKey, String requestId, int expireTime) {

    Long result = jedis.setnx(lockKey, requestId);
    if (result == 1) {
        // 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁
        jedis.expire(lockKey, expireTime);
    }

}
</code></pre><blockquote>
<p>错误案例二</p>
</blockquote>
<pre><code>public static boolean wrongGetLock2(Jedis jedis, String lockKey, int expireTime) {

    long expires = System.currentTimeMillis() + expireTime;
    String expiresStr = String.valueOf(expires);

    // 如果当前锁不存在，返回加锁成功
    if (jedis.setnx(lockKey, expiresStr) == 1) {
        return true;
    }

    // 如果锁存在，获取锁的过期时间
    String currentValueStr = jedis.get(lockKey);
    if (currentValueStr != null &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) {
        // 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间
        String oldValueStr = jedis.getSet(lockKey, expiresStr);
        if (oldValueStr != null &amp;&amp; oldValueStr.equals(currentValueStr)) {
            // 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才有权利加锁
            return true;
        }
    }
        
    // 其他情况，一律返回加锁失败
    return false;

}
</code></pre><h3 id="redis1">Redis分布式锁的问题分析</h3>
<p>既然是分布式系统，那么有几个边界是需要考虑的：</p>
<ul>
<li>网络是不可靠的，是有延迟的或者中断的</li>
<li>多台机器的时钟是有可能不一致的（向前或向后偏移）</li>
<li>系统会宕机</li>
</ul>
<p>基于这些条件我们再分析下单节点Redis或者主从节点Redis实现分布式锁的一些问题：</p>
<blockquote>
<p>场景一</p>
</blockquote>
<ul>
<li>clientA获取到锁，过期时间设置为3s</li>
<li>clientA业务处理时间过长（或者GC以及其他网络问题），处理时间超过3s，Redis由于key过期释放了key</li>
<li>clientB拿到了锁，clientA和clientB在同一时间访问了共享资源</li>
</ul>
<blockquote>
<p>场景二</p>
</blockquote>
<ul>
<li>clientA获取到锁</li>
<li>Redis主节点挂了，从节点升级为Master，但是由于Redis主从同步是异步的，有可能Master没有将数据同步到Slave</li>
<li>clientB获取到了锁，clientA和clientB在同一时间访问了共享资源</li>
</ul>
<h3 id="redisson">Redisson的原理及如何实现分布式锁</h3>
<p>Redis作者对于分布式锁从三个方面来描述如何有效使用分布式锁所需要的三个最低保证：</p>
<blockquote>
<ol>
<li>Safety property: Mutual exclusion. At any given moment, only one client can hold a lock.</li>
<li>Liveness property A: Deadlock free. Eventually it is always possible to acquire a lock, even if the client that locked a resource crashes or gets partitioned.</li>
<li>Liveness property B: Fault tolerance. As long as the majority of Redis nodes are up, clients are able to acquire and release locks.</li>
</ol>
</blockquote>
<ol>
<li>安全属性：互斥，在任何给定的时间，有且仅有一个客户端持有锁</li>
<li>存活属性：无死锁</li>
<li>存活属性：只要大多数节点运行，客户端就可以获取和释放锁</li>
</ol>
<blockquote>
<p>Redission的算法描述，RedLock的算法稍微有点复杂：</p>
</blockquote>
<ul>
<li>获取当前Unix时间，以毫秒为单位。</li>
<li>依次尝试从5个实例，使用相同的key和<strong>具有唯一性的value</strong>（例如UUID）获取锁。当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试去另外一个Redis实例请求获取锁。</li>
<li>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。<strong>当且仅当从大多数</strong>（N/2+1，这里是3个节点）<strong>的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功</strong>。</li>
<li>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。</li>
<li>如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在<strong>所有的Redis实例上进行解锁</strong>（即便某些Redis实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。</li>
</ul>
<blockquote>
<p>Redisson的使用：</p>
</blockquote>
<pre><code>RLock lock1 = redissonInstance1.getLock(&quot;lock1&quot;);
RLock lock2 = redissonInstance2.getLock(&quot;lock2&quot;);
RLock lock3 = redissonInstance3.getLock(&quot;lock3&quot;);

RedissonRedLock lock = anyRedissonInstance.getRedLock(lock1, lock2, lock3);
// locks: lock1 lock2 lock3
lock.lock();
...
lock.unlock();
</code></pre><ul>
<li>构造至少5个不同的RLock</li>
<li>对多个RLock对象进行分组并将它们作为一个锁处理</li>
</ul>
<h3 id="heading11">一些后续的话</h3>
<p>即便是RedLock这么牛逼算法，还是不完善的，使用DDIA作者提出的问题分析下：</p>
<p><img src="https://raw.githubusercontent.com/Sailfishc/picRepo/master/XhLmcL.png" alt="Redis分布式锁的问题"></p>
<p>还是之前的一个例子：</p>
<ul>
<li>ClientA获取锁，发生了GC，超过超时时间，Redis释放锁</li>
<li>ClientB获取到锁，此时ClientA唤醒，两个客户端都获取到锁</li>
<li>ClientB执行了Read-Write-Update模型之后ClientA再次覆盖了ClientB的数据，造成了数据错误</li>
</ul>
<p>也有几个实例：</p>
<blockquote>
<p>案例一</p>
</blockquote>
<ul>
<li>clientA获取到A，B，C三个节点，由于网络故障，无法访问D，E节点</li>
<li>由于C节点时钟向前偏移，导致锁过期</li>
<li>clientB获取到C，D，E，由于网络故障，无法访问A，B节点</li>
<li>在此时，clientA和clientB都获取到了锁</li>
</ul>
<p>并且他提出了几个观点，他认为RedLock是建立在这几个假设上的：</p>
<blockquote>
<ul>
<li>bounded network delay (you can guarantee that packets always arrive within some guaranteed maximum delay),</li>
<li>bounded process pauses (in other words, hard real-time constraints, which you typically only find in car airbag systems and suchlike), and</li>
<li>bounded clock error (cross your fingers that you don’t get your time from a  <a href="http://xenia.media.mit.edu/~nelson/research/ntp-survey99/">bad NTP server</a> ).</li>
</ul>
</blockquote>
<ol>
<li>有界的网络延迟</li>
<li>有界的程序停顿</li>
<li>有界的时钟异常</li>
</ol>
<blockquote>
<p>针对GC导致锁失效的问题</p>
</blockquote>
<p>Martin给出了一个解法，对于ZK这种他会生成一个自增的序列，那么我们真正进行对资源操作的时候，需要判断当前序列是否是最新，有点类似于我们乐观锁。当然这个解法Redis作者进行了反驳，你既然都能生成一个自增的序列了那么你完全不需要加锁了，也就是可以按照类似于Mysql乐观锁的解法去做。</p>
<blockquote>
<p>针对时钟跳跃的问题</p>
</blockquote>
<p>Martin觉得RedLock不安全很大的原因也是因为时钟的跳跃，因为锁过期强依赖于时间，但是ZK不需要依赖时间，依赖每个节点的Session。Redis作者也给出了解答:对于时间跳跃分为人为调整和NTP自动调整。</p>
<ul>
<li>人为调整:人为调整影响的那么完全可以人为不调整，这个是处于可控的。</li>
<li>NTP自动调整:这个可以通过一定的优化，把跳跃时间控制的可控范围内，虽然会跳跃，但是是完全可以接受的。</li>
</ul>
<p>最后Martin认为Redis说的也有道理，但是Redis的分布式锁实现方式还是有问题的，这可能也是TradeOff的魅力吧，Martin是学术流派，从他的书和博客中也可以看出他的参考资料偏Paper，Redis作者是实战派，虽然Redis理论上还是有些问题，但是在目前还是使用比较广泛，这可能就是虽然不完美，但是还是要接受她吧。</p>
<h2 id="heading12">参考资料</h2>
<ul>
<li><a href="https://redis.io/topics/distlock">Distributed locks with Redis – Redis</a></li>
<li><a href="https://github.com/TaXueWWL/redis-distributed-lock">GitHub - TaXueWWL/redis-distributed-lock: redis分布式锁工具包，提供纯Java方式调用，支持传统Spring工程，  为spring boot应用提供了starter，更方便快捷的调用。</a></li>
<li><a href="https://github.com/AnthonyZero/distributed-lock-redis">GitHub - AnthonyZero/distributed-lock-redis: Distributed lock based on redis</a></li>
<li><a href="http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">How to do distributed locking — Martin Kleppmann’s blog</a></li>
<li><a href="http://antirez.com/news/101">Is Redlock safe? - <!-- raw HTML omitted --></a></li>
<li><a href="https://www.oschina.net/translate/redis-distlock?print">使用 Redis 实现分布式锁 - 技术翻译 - OSCHINA 社区</a></li>
<li><a href="https://juejin.im/post/5d9699ace51d45781d5e4baa">死磕 java同步系列之redis分布式锁进化史 - 掘金</a></li>
<li><a href="https://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/">Redis分布式锁的正确实现方式（Java版） - 吴大山的博客 | Wudashan Blog</a></li>
<li><a href="https://redis.io/topics/cluster-tutorial#redis-cluster-consistency-guarantees">Redis cluster tutorial – Redis</a></li>
<li>分布式锁使用场景：https://blog.csdn.net/lemon89/article/details/52796775</li>
<li><a href="https://www.cnblogs.com/yjmyzz/p/distributed-lock-using-zookeeper.html">ZooKeeper 笔记(6) 分布式锁 - 菩提树下的杨过 - 博客园</a></li>
<li><a href="https://www.cnblogs.com/yjmyzz/p/distribution-lock-using-redis.html">基于redis的分布式锁二种应用场景 - 菩提树下的杨过 - 博客园</a></li>
<li><a href="https://draveness.me/zookeeper-chubby">详解分布式协调服务 ZooKeeper</a></li>
<li><a href="https://juejin.im/post/5bbb0d8df265da0abd3533a5">再有人问你分布式锁，这篇文章扔给他 - 掘金</a></li>
<li><a href="https://www.cnblogs.com/yzf666/p/10117890.html">redis 不可重入分布式锁(setNx()和getset()方法实现) - 断剑重铸之时 - 博客园</a></li>
<li><a href="https://github.com/redisson/redisson/wiki/8.-distributed-locks-and-synchronizers">8. Distributed locks and synchronizers · redisson/redisson Wiki · GitHub</a></li>
<li><a href="http://curator.apache.org/getting-started.html">Apache Curator – Distributed Lock</a></li>
<li><a href="https://blog.csdn.net/xuefeng0707/article/details/80588855">curator分布式锁</a></li>
<li><a href="https://www.jianshu.com/p/7e47a4503b87">Redlock：Redis分布式锁最牛逼的实现 - 简书</a></li>
<li><a href="https://www.jianshu.com/p/fba7dd6dcef5">RedLock算法-使用redis实现分布式锁服务 - 简书</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>开发人员必备的Docker基础</title>
            <link>https://blog.sailfishc.cn/posts/2019/11/%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BF%85%E5%A4%87%E7%9A%84docker%E5%9F%BA%E7%A1%80/</link>
            <pubDate>Sun, 10 Nov 2019 16:01:41 +0800</pubDate>
            
            <guid>https://blog.sailfishc.cn/posts/2019/11/%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BF%85%E5%A4%87%E7%9A%84docker%E5%9F%BA%E7%A1%80/</guid>
            <description>Docker简介 说到Docker，我们就来谈谈业务应用从旧时代到Docker的发展历程。
旧时代 旧时代是基于Application运转的，一台服务器（无虚拟机时代）部署多个Application，不管是Windows还是Linux其实是无法保证在一台服务器上稳定安全的运行多个应用的，CPU，内存等公共资源的竞争导致应用极为不稳定。
VM阶段 VM让世界变得美好了，VM算是划时代意义的技术，但是VM不是完美的，VM会占用宿主机额外的CPU,RAM和存储（VM不够轻量级），启动慢。
Linux容器 容器技术出现的比较早，只是Docker将Linux容器技术广泛应用了，Docker解决了VM的问题以外，还有如下优点：
 容易上手 解决了运维中的环境问题及服务调度的痛点  Docker安装 Docker提供了桌面安装和服务器安装，对于开发来说，我们可以归类为：
 Windows平台 Mac平台 Linux平台：Ubuntu/CentOS  Windows平台 硬件要求：
 win10 64位 启用Hyper-V和容器特性  安装步骤：Install Docker Desktop on Windows | Docker Documentation
 下载Docker for windows安装包： https://www.docker.com/products/docker-desktop 根据安装向导安装 成功后再CMD中输入docker version查看版本，如果有版本信息表示安装成功  Mac平台 Mac版本和Windows桌面版安装类似，找到下载包，静默安装即可：
 下载地址：下载Docker for windows安装包： https://www.docker.com/products/docker-desktop  Ubuntu安装  Ubuntu安装：Get Docker Engine - Community for Ubuntu | Docker Documentation  Ubuntu有几种方式安装Docker，我们使用便捷脚本来安装Docker
 在Linux打开Shell 执行：curl -fsSL https://get.docker.com -o get-docker.</description>
            <content type="html"><![CDATA[<h2 id="docker">Docker简介</h2>
<p>说到Docker，我们就来谈谈业务应用从旧时代到Docker的发展历程。</p>
<h3 id="heading">旧时代</h3>
<p>旧时代是基于Application运转的，一台服务器（无虚拟机时代）部署多个Application，不管是Windows还是Linux其实是无法保证在一台服务器上稳定安全的运行多个应用的，CPU，内存等公共资源的竞争导致应用极为不稳定。</p>
<h3 id="vm">VM阶段</h3>
<p>VM让世界变得美好了，VM算是划时代意义的技术，但是VM不是完美的，VM会占用宿主机额外的CPU,RAM和存储（VM不够轻量级），启动慢。</p>
<h3 id="linux">Linux容器</h3>
<p>容器技术出现的比较早，只是Docker将Linux容器技术广泛应用了，Docker解决了VM的问题以外，还有如下优点：</p>
<ul>
<li>容易上手</li>
<li>解决了运维中的环境问题及服务调度的痛点</li>
</ul>
<h2 id="docker1">Docker安装</h2>
<p>Docker提供了桌面安装和服务器安装，对于开发来说，我们可以归类为：</p>
<ul>
<li>Windows平台</li>
<li>Mac平台</li>
<li>Linux平台：Ubuntu/CentOS</li>
</ul>
<h3 id="windows">Windows平台</h3>
<p>硬件要求：</p>
<ul>
<li>win10 64位</li>
<li>启用Hyper-V和容器特性</li>
</ul>
<p>安装步骤：<a href="https://docs.docker.com/docker-for-windows/install/">Install Docker Desktop on Windows | Docker Documentation</a></p>
<ul>
<li>下载Docker for windows安装包： <a href="https://www.docker.com/products/docker-desktop"><a href="https://www.docker.com/products/docker-desktop">https://www.docker.com/products/docker-desktop</a></a></li>
<li>根据安装向导安装</li>
<li>成功后再CMD中输入<code>docker version</code>查看版本，如果有版本信息表示安装成功</li>
</ul>
<h3 id="mac">Mac平台</h3>
<p>Mac版本和Windows桌面版安装类似，找到下载包，静默安装即可：</p>
<ul>
<li>下载地址：下载Docker for windows安装包： <a href="https://www.docker.com/products/docker-desktop"><a href="https://www.docker.com/products/docker-desktop">https://www.docker.com/products/docker-desktop</a></a></li>
</ul>
<h3 id="ubuntu">Ubuntu安装</h3>
<ul>
<li>Ubuntu安装：<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Get Docker Engine - Community for Ubuntu | Docker Documentation</a></li>
</ul>
<p>Ubuntu有几种方式安装Docker，我们使用便捷脚本来安装Docker</p>
<ul>
<li>在Linux打开Shell</li>
<li>执行：<code>curl -fsSL https://get.docker.com -o get-docker.sh</code></li>
<li>执行：<code>sudo sh get-docker.sh</code></li>
<li>执行：<code>sudo usermod -aG docker your-user</code></li>
<li>使用docker —version查看docker版本</li>
</ul>
<blockquote>
<p>备注：</p>
<ol>
<li>不要使用root用户使用Docker</li>
<li>需要将非root用户到本地Docker Unix组当中：<code>sudo usermod -aG docker your-user</code> , your-user为执行Docker的用户名</li>
</ol>
</blockquote>
<p>卸载Docker-CE：</p>
<ul>
<li><code>sudo apt-get purge docker-ce</code></li>
<li><code>sudo rm -rf /var/lib/docker</code></li>
</ul>
<h3 id="centos">CentOS安装</h3>
<ul>
<li>CentOS安装： <a href="https://docs.docker.com/install/linux/docker-ce/centos/"><a href="https://docs.docker.com/install/linux/docker-ce/centos/">https://docs.docker.com/install/linux/docker-ce/centos/</a></a></li>
<li>安装方式同Ubuntu</li>
</ul>
<p>卸载Docker-ce</p>
<ul>
<li><code>sudo yum remove docker-ce</code></li>
<li><code>sudo rm -rf /var/lib/docker</code></li>
</ul>
<h2 id="docker2">Docker镜像与容器</h2>
<p>镜像和容器是Docker的重要概念，在本小节主要会有一下内容：</p>
<ul>
<li>镜像和容器简介</li>
<li>搜索镜像</li>
<li>下载镜像</li>
<li>删除镜像</li>
<li>运行容器</li>
<li>停止容器</li>
<li>删除容器</li>
<li>命令合集</li>
</ul>
<h3 id="heading1">镜像和容器简介</h3>
<p>对于开发来说，简单理解一下镜像：镜像就是Class，容器就是实例对象，一个Class可以有多个实例，每个实例即使内容一致，但是也不是相等的（不同的容器ID和名称）</p>
<h3 id="heading2">搜索镜像</h3>
<p>Docker安装后并没有镜像，需要从仓库中拉取（仓库可以类比Maven仓库，分为本地仓库，私有仓库和中央仓库），使用命令docker  search [image-name]，就可以看到一个redis仓库列表，列表中包含了以下元数据：</p>
<ul>
<li>名称</li>
<li>描述</li>
<li>star数</li>
<li>是否是官方</li>
<li>是否自动化</li>
</ul>
<p><img src="http://img.sailfishc.cn/20190825204152.png?imageslim" alt="搜索镜像"></p>
<h3 id="heading3">下载镜像</h3>
<p>在找到需要的镜像后，可以使用<code>docker pull [image-name]</code>来下载镜像</p>
<h3 id="heading4">运行容器</h3>
<p>基础运行容器： <code>docker run -it ubuntu:latest /bin/bash</code></p>
<p>上面的命令是以交互形式运行了一个最后版本的ubuntu系统，默认进入的目录是/bin/bash，其中的一些参数介绍：</p>
<ul>
<li>run：运行容器的命令</li>
<li>-i -t（可以合并为-it）：交互形式，还有如-d,&amp;等形式</li>
<li>ubuntu:latest：镜像名称（版本）</li>
<li>/bin/bash：交互形式进入后的目录</li>
</ul>
<blockquote>
<p>如果当前没有该镜像，那么在运行容器时会先执行pull命令下载，然后再执行run命令，如果以-it参数启动容器后再bash中执行<code>ctrl-c</code>或者是执行exit命令会终止容器，原因是容器不存在任何进程则无法存在，可以使用<code>ctrl-pq</code>断开shell与容器终端的链接（容器不会终止）</p>
</blockquote>
<p><img src="http://img.sailfishc.cn/20190825205542.png?imageslim" alt="运行容器"></p>
<p>完整的一个docker run命令示例：<code>docker run -d --name my-redis --restart always redis</code></p>
<p>解释如下：</p>
<ul>
<li>-d：后台运行模式</li>
<li>—name：命名一个容器名称为my-redis</li>
<li>—restart：always是一种简单的自我修复策略，表明除非明确停止（例如执行了stop命令），否则会一直尝试重启</li>
</ul>
<h3 id="heading5">镜像和容器命令合集</h3>
<ul>
<li>搜索镜像：docker search [image-name]</li>
<li>下载镜像：docker pull [image-name]</li>
<li>查看本地镜像列表：docker images</li>
<li>删除镜像：docker rm [docker-name]:[tag]</li>
<li>运行容器: docker run [image-name]</li>
<li>重新进入容器：docker exec -it container-id /bin/bash</li>
<li>查看容器列表:docker ps</li>
<li>停止容器：docker stop container-id</li>
<li>删除容器：docker rm container-id</li>
<li>启动容器: docker start container-id</li>
</ul>
<blockquote>
<p>备注：</p>
<ol>
<li>image-name也可以使用image-id（唯一）</li>
<li>删除镜像时如果镜像存在关联的容器，并且容器处于运行或者是停止状态，不允许删除镜像</li>
</ol>
</blockquote>
<h3 id="web">实例：运行一个Web服务器</h3>
<p>启动Nginx容器：<code>docker run --name some-nginx -d -p 8080:80 nginx</code></p>
<blockquote>
<p>以后台模式运行了nginx，名字为some-nginx，-p参数留到下一小节讲解，下图是启动后在本机（localhost）访问nginx容器，可以看到已经可以正常访问到nginx服务了。</p>
</blockquote>
<p><img src="http://img.sailfishc.cn/20190825211847.png?imageslim" alt="Nginx容器"></p>
<h2 id="heading6">参考资料</h2>
<ul>
<li>深入浅出Docker</li>
<li>Docker官网</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>学习观</title>
            <link>https://blog.sailfishc.cn/posts/2019/11/%E5%AD%A6%E4%B9%A0%E8%A7%82/</link>
            <pubDate>Sun, 03 Nov 2019 21:01:53 +0800</pubDate>
            
            <guid>https://blog.sailfishc.cn/posts/2019/11/%E5%AD%A6%E4%B9%A0%E8%A7%82/</guid>
            <description>为学习付费，还是为知识付费，亦或者是为信息付费，在高中时看到一个资料，是一套数学的学习模型，当时心情非常激动，被资料宣传的效果倾倒，觉得有一套这样的学习资料，一定会学有所成，但是最终效果一般，也没考上一个好学校，毕业后坚信Just do IT，选择了IT道路，在IT路上，如何学习也是很重要的一门手艺。
介绍 本篇文章主要是从网络资源《学习观》中做的一些总结，主要包含两部分内容：
 学习理论  学习和记忆 信息和知识 知识的分类   学习工具  思维导图 费曼技巧   学习实战  正确的学习方法 如何学习英文    学习 理论知识 学习和记忆 从上学到工作，一直在学习，也有一些号称终生学习的人，但是好像没人告诉我们什么是学习，或者很少人去思考学习是什么？在上学的时候，听课是学习，做题是学习，考试也是学习，但是这个过程中到底哪些步骤才算是学习呢？学习的结果是学会，那怎么才算是学会呢？抽象的思考下，老师在课堂讲解了A，B，C三个知识点，对应给出了A，B，C三个知识点的题目，你将A，B，C三道题的题目解出来了，说明你学会了A，B，C这三个知识点，但是在考试中出现了你没见过的题目，类似AB，AC，BC，甚至是ABC这种组合的题目，你根据学习的A，B，C的基础知识点没有将题目解出来，这说明你没有学会，那学习究竟是什么呢？
我们将这个过程简化去分析下，有3个数：1，2，3，只有一种规则：乘，那么所有的可能性是：
1 * 1 = 1 1 * 2 = 2 1 * 3 = 3 2 * 1 = 2 2 * 2 = 4 2 * 3 = 6 3 * 1 = 3 3 * 2 = 6 3 * 3 = 9 这个数字是规则是有限的（这也是我们小学数学有可能满分，高中大学很难满分的原因），我们可以使用大脑记忆，出现类似题目可以很快的反馈出结果，但是我们真的学会了吗？没有，因为出现2 * 4的时候就不知道结果了，但是我们通过上面的例子去学习，总结出规律，即使出现其他题目也能解出来的过程就是学习。</description>
            <content type="html"><![CDATA[<p>为学习付费，还是为知识付费，亦或者是为信息付费，在高中时看到一个资料，是一套数学的学习模型，当时心情非常激动，被资料宣传的效果倾倒，觉得有一套这样的学习资料，一定会学有所成，但是最终效果一般，也没考上一个好学校，毕业后坚信<code>Just do IT</code>，选择了IT道路，在IT路上，如何学习也是很重要的一门手艺。</p>
<h2 id="heading">介绍</h2>
<p>本篇文章主要是从网络资源《学习观》中做的一些总结，主要包含两部分内容：</p>
<ul>
<li>学习理论
<ul>
<li>学习和记忆</li>
<li>信息和知识</li>
<li>知识的分类</li>
</ul>
</li>
<li>学习工具
<ul>
<li>思维导图</li>
<li>费曼技巧</li>
</ul>
</li>
<li>学习实战
<ul>
<li>正确的学习方法</li>
<li>如何学习英文</li>
</ul>
</li>
</ul>
<h2 id="heading1">学习</h2>
<h3 id="heading2">理论知识</h3>
<h4 id="heading3">学习和记忆</h4>
<p>从上学到工作，一直在学习，也有一些号称终生学习的人，但是好像没人告诉我们什么是学习，或者很少人去思考学习是什么？在上学的时候，听课是学习，做题是学习，考试也是学习，但是这个过程中到底哪些步骤才算是学习呢？学习的结果是学会，那怎么才算是学会呢？抽象的思考下，老师在课堂讲解了A，B，C三个知识点，对应给出了A，B，C三个知识点的题目，你将A，B，C三道题的题目解出来了，说明你学会了A，B，C这三个知识点，但是在考试中出现了你没见过的题目，类似AB，AC，BC，甚至是ABC这种组合的题目，你根据学习的A，B，C的基础知识点没有将题目解出来，这说明你没有学会，那学习究竟是什么呢？</p>
<p>我们将这个过程简化去分析下，有3个数：1，2，3，只有一种规则：乘，那么所有的可能性是：</p>
<pre><code>1 * 1 = 1
1 * 2 = 2
1 * 3 = 3
2 * 1 = 2
2 * 2 = 4
2 * 3 = 6
3 * 1 = 3
3 * 2 = 6
3 * 3 = 9
</code></pre><p>这个数字是规则是有限的（这也是我们小学数学有可能满分，高中大学很难满分的原因），我们可以使用大脑记忆，出现类似题目可以很快的反馈出结果，但是我们真的学会了吗？没有，因为出现<code>2 * 4</code>的时候就不知道结果了，但是我们通过<code>上面的例子</code>去学习，总结出规律，即使出现其他题目也能解出来的过程就是<code>学习</code>。</p>
<h4 id="heading4">信息和知识</h4>
<p>我们无时无刻不在接受信息，微信消息，别人说的话，那个付费APP推出的专栏课程，这些对于我们来说都是信息，但是并不是知识，那什么是知识呢？回答这个问题，我们先来看什么不是知识：</p>
<ul>
<li><del>买了没看的课程</del></li>
<li><del>匆匆看了一遍的课程</del></li>
<li><del>课堂上没注意听讲的话</del></li>
</ul>
<p>看了这几个例子可以有一点体会，就是某个东西他是不是信息不是绝对的，而在于对你来说他当时的某个状态，我对知识的一个定义是：<code>经过了学习之后将信息压缩，提炼出的内容</code>，这里有一些误区，就是比如老师将他的学习经验分享给了你，这个经验传递的是信息，而不是知识，但是这部分信息已经被压缩了，所以也可以叫做知识的描述，只有等你真正学会，对于你来说，才能叫做知识。</p>
<h4 id="heading5">知识的分类</h4>
<p>知识可以分为思考类和运动类，如何区分思考类和运动类知识呢？一个衡量标准就是是否使用了意识，意识是后天进化的，解决的是推断问题，只能同时运用一个，比如数学，逻辑等，对于语言类（学习英语）和运动类都属于运动类知识，他不靠意识（不然太慢）。</p>
<h3 id="heading6">学习工具</h3>
<h4 id="heading7">思维导图</h4>
<p>思维导图的作用是可以通过一些关键词将思维连接，但是包括我在内很多人都用错了思维导图，常见的学习方法是：</p>
<ul>
<li>阅读知识描述</li>
<li>理解文字意思</li>
<li>不断重复描述</li>
</ul>
<p>在这个过程中将思维导图当成了笔记或者是大纲，试图去记住内容而不是去理解内容，这样导致的就是学会了的错觉。</p>
<blockquote>
<p>思维导图的灵魂：思考</p>
</blockquote>
<p>思维导图通过一个关键词去思考，他是什么？通过一个关键词去联想更多例子，试图用一个关键词去描述这些例子，进而去分析这些例子的输入和输出，找出内部规律，这个规律是不变的，例子中的输入和输出是可变的，通过这些少量的例子找出不变的规律去解决以后更多的问题，这个过程其实是在压缩信息，思维导图不是为了记住知识描述，导图的作用是为了重塑在这个过程中的大脑连接，最终的导图是为了以后复习，在不知道背景的情况下我的导图对你来说应该是没有用的。</p>
<h4 id="heading8">费曼学习</h4>
<p>费曼技巧成为终极学习法，费曼技巧包含了学习和解释，学习在之前已经说了，为什么加了一个解释就显得威力巨大，原因是因为在解释的过程中不能将学习过程中的例子完整的叙述出来，要用自己的话将知识再进行浓缩，并且面临新的问题去阐述。</p>
<h3 id="heading9">学习实战</h3>
<h4 id="heading10">正确的学习方法</h4>
<p>在之前明确了什么是学习，可以将学习的过程抽象为编程语言：</p>
<ul>
<li>已知的信息：输入</li>
<li>经过大脑处理：函数</li>
<li>得出的结论：输出</li>
</ul>
<p>学习的正确流程：</p>
<ul>
<li>明确问题和答案</li>
<li>用例子构建知识</li>
<li>验证知识的有效性</li>
</ul>
<p>这样说其实还是有点抽象，这里先明确几点：</p>
<ul>
<li>例子是为了连接问题和答案，更多的例子可以让你在学习的过程中体会答案是解决了什么样的问题，是如何解决的，从例子中寻找规律，其实例子就是故事，人还是喜欢听故事的，这也是为什么很多演讲都喜欢讲故事了，因为故事（例子）更容易让人理解</li>
<li>通过例子自己总结出的规律要去验证</li>
</ul>
<p>先举几个简单的案例来体会：</p>
<ul>
<li>开源项目学习：
<ul>
<li>首先是需要一定的基础知识（自己大脑中已知的知识）</li>
<li>了解开源库解决了什么问题（例如Dubbo解决的是服务治理问题）</li>
<li>寻找例子：
<ul>
<li>如何使用Dubbo服务（Quick Start）</li>
<li>Dubbo的SPI配置</li>
<li>Dubbo环境（ZK）的搭建</li>
</ul>
</li>
<li>通过例子去熟悉Dubbo是什么，解决了什么问题，怎么用的</li>
<li>寻找新问题：Dubbo使用Hessian序列化的过程中子类和父类属性名一致获取不到值是什么原因？
<ul>
<li>不知道：写一个Demo（例子）去本地验证，Debug查看</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="heading11">如何学习英语</h4>
<blockquote>
<p>运动类知识不能使用意识，也就是不能有中间转义的操作，现在学习的过程都是英文转中文，这种是错误和低效的，运动类知识不能使用思维类的知识，比如不能书中学游泳。<br>
学英文也要以具体为单位，不要只学习单词，从句子学习<br>
参考打游戏时的操作</p>
</blockquote>
<p><strong>学习原则：</strong></p>
<ul>
<li>明确任务的输入和输出</li>
<li>用例子重塑大脑链接</li>
</ul>
<ol>
<li>看单词的英文解释：看完基本还是不理解</li>
<li>看多个例句去体会意思：选择一些简单句去理解</li>
<li>看句子不思考中文的情况下去想想场景（多尝试几次）</li>
<li>可以尝试打出句子</li>
<li>将例子放到翻译网站，播放例句去思考场景</li>
<li>读几遍例句，并思考场景</li>
<li>改几个单词，造一个简单的句子</li>
</ol>
<h2 id="heading12">参考文档</h2>
<ul>
<li><a href="https://www.youtube.com/channel/UCUrJvRXzVBOYtHBs9fDnJEw">Jango Y - YouTube</a></li>
<li><a href="https://www.youtube.com/watch?v=Q2oYGjR1_KE">如何才能正确使用思维导图 - YouTube</a></li>
<li><a href="https://www.youtube.com/watch?v=E3Q5nlr078Q">如何正确使用人脑来在几个月内学会英语 - YouTube</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>科学上网</title>
            <link>https://blog.sailfishc.cn/posts/2019/11/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</link>
            <pubDate>Fri, 01 Nov 2019 09:56:18 +0800</pubDate>
            
            <guid>https://blog.sailfishc.cn/posts/2019/11/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</guid>
            <description>本文转自左耳朵耗子
 作者：左耳朵 http://coolshell.cn 更新时间：2019-11-01
这篇文章可以写的更好，欢迎到 https://github.com/haoel/haoel.github.io 更新
 科学上网  0. 序 1. 英文能力 2. 购买VPS  2.1 常规VPS 2.2 CN2 线路 2.3 NCP 线路   3. 搭建 Shadowsocks 和 VPN 服务  3.1 设置Docker服务 3.2 开启 TCP BBR 拥塞控制算法 3.3 设置Shadowsocks服务 3.4 设置L2TP/IPSec服务 3.5 设置PPTP服务   4. 客户端设置  4.1 Shadowsocks 客户端 4.2 VPN 客户端   5. 流量伪装和其它方式  5.1 V2Ray 5.2 Brook   6.</description>
            <content type="html"><![CDATA[<blockquote>
<p>本文转自左耳朵耗子</p>
</blockquote>
<p>作者：左耳朵 <a href="http://coolshell.cn"><a href="http://coolshell.cn">http://coolshell.cn</a></a>
更新时间：2019-11-01</p>
<p>这篇文章可以写的更好，欢迎到 <a href="https://github.com/haoel/haoel.github.io"><a href="https://github.com/haoel/haoel.github.io">https://github.com/haoel/haoel.github.io</a></a> 更新</p>
<ul>
<li><a href="#%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91">科学上网</a>
<ul>
<li><a href="#0-%E5%BA%8F">0. 序</a></li>
<li><a href="#1-%E8%8B%B1%E6%96%87%E8%83%BD%E5%8A%9B">1. 英文能力</a></li>
<li><a href="#2-%E8%B4%AD%E4%B9%B0vps">2. 购买VPS</a>
<ul>
<li><a href="#21-%E5%B8%B8%E8%A7%84vps">2.1 常规VPS</a></li>
<li><a href="#22-cn2-%E7%BA%BF%E8%B7%AF">2.2 CN2 线路</a></li>
<li><a href="#23-ncp-%E7%BA%BF%E8%B7%AF">2.3 NCP 线路</a></li>
</ul>
</li>
<li><a href="#3-%E6%90%AD%E5%BB%BA-shadowsocks-%E5%92%8C-vpn-%E6%9C%8D%E5%8A%A1">3. 搭建 Shadowsocks 和 VPN 服务</a>
<ul>
<li><a href="#31-%E8%AE%BE%E7%BD%AEdocker%E6%9C%8D%E5%8A%A1">3.1 设置Docker服务</a></li>
<li><a href="#32-%E5%BC%80%E5%90%AF-tcp-bbr-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95">3.2 开启 TCP BBR 拥塞控制算法</a></li>
<li><a href="#33-%E8%AE%BE%E7%BD%AEshadowsocks%E6%9C%8D%E5%8A%A1">3.3 设置Shadowsocks服务</a></li>
<li><a href="#34-%E8%AE%BE%E7%BD%AEl2tpipsec%E6%9C%8D%E5%8A%A1">3.4 设置L2TP/IPSec服务</a></li>
<li><a href="#35-%E8%AE%BE%E7%BD%AEpptp%E6%9C%8D%E5%8A%A1">3.5 设置PPTP服务</a></li>
</ul>
</li>
<li><a href="#4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BE%E7%BD%AE">4. 客户端设置</a>
<ul>
<li><a href="#41-shadowsocks-%E5%AE%A2%E6%88%B7%E7%AB%AF">4.1 Shadowsocks 客户端</a></li>
<li><a href="#42-vpn-%E5%AE%A2%E6%88%B7%E7%AB%AF">4.2 VPN 客户端</a></li>
</ul>
</li>
<li><a href="#5-%E6%B5%81%E9%87%8F%E4%BC%AA%E8%A3%85%E5%92%8C%E5%85%B6%E5%AE%83%E6%96%B9%E5%BC%8F">5. 流量伪装和其它方式</a>
<ul>
<li><a href="#51-v2ray">5.1 V2Ray</a></li>
<li><a href="#52-brook">5.2 Brook</a></li>
</ul>
</li>
<li><a href="#6-%E9%92%88%E5%AF%B9-ip-%E8%A2%AB%E5%B0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">6. 针对 IP 被封的解决方案</a>
<ul>
<li><a href="#61-cloudflare">6.1 Cloudflare</a></li>
<li><a href="#62-v2ray">6.2 V2Ray</a></li>
<li><a href="#63-%E8%A1%A5%E5%85%85">6.3 补充</a></li>
</ul>
</li>
<li><a href="#7-%E5%85%B6%E5%AE%83">7. 其它</a></li>
</ul>
</li>
</ul>
<h2 id="0-">0. 序</h2>
<p>首先，我们先明确一下，我科学上网的目的主要是为了学习、工作、交友、查资料、和丰富自己的眼界，不是为了看黄片，或是干一些非法、政治或是见不得人的事。</p>
<p>对我来说，科学上网很重要，下面罗列一下需要科学上网，我才能真正学习工作和生活的网站：</p>
<ul>
<li>Youtube 和 Vimeo 上的各种大会和教学视频，除了我自己要学，我的孩子也要学。</li>
<li>Wikipedia 维基百科是我目前唯一信得过的百科全书，我在上面可以比较系统地翻阅各种词条。</li>
<li>Slideshare 上有很多的技术文档和资料的PPT，是我的知识学习的地方。</li>
<li>Quora 问答网站，在上面有很多有趣的问答。</li>
<li>博客和论文，很多博客和论文站点都被墙了，比如：Blogspot 和 Medium。</li>
<li>Google 的各种服务，比如：Gmail, Map, Docs，Driver，照片，图片搜索，Voices，论文搜索……包括Google官方的各种技术文档……</li>
<li>一些云服务，比如：Dropbox，IFTTT，Imgur，archive.org……</li>
<li>Twitter 上 Follow 一些牛人和一些官方账号，比如：AWS、Docker……</li>
<li>社交 Facebook, Telegram, Whatsapp，Slack…… 有一些我在国外的亲戚和朋友……</li>
<li>Reddit 是一个聚合网站，一个新闻和文章的集散地，你可以认为是各种频道的今日头条……</li>
<li>Pinterest 和 Instagram  上面有很多不错的图片和视频新闻，是我减压力的地方……</li>
<li>新闻，如BBC。 BBC是全球比较出众的媒体，有太多的有价值资源和内容了，比如纪录片、学英文……</li>
<li>编程，有很多编程的场景需要翻墙，比如，Go语言编程时的 go get 中的很多库是放在 Google的服务器上， 然而Google是全部被墙，包括 Android 和其它一些文档和资源也是一样。包括 SourceForge 的某些项目也需要科学上网，Docker Registry也有部分被墙，还有偶尔抽疯的Github，以及不能访问的gist……</li>
<li>……等等</li>
</ul>
<p>是的，我的互联网不是——全是骗子的百度、充满广告的微信朋友圈、质量低下的公众号、娱乐至死的新浪微博、只有抖机灵和“怎么看XX”的知乎、毫无营养的今日头条…… 在这样的网络空间里，我真的无法生存…… 这根本不是互联网，不是为我服务的互联网，而是在消费我的互联网，是让我变傻变笨的互联网…… 我不能忍，因为它影响到了我的生存……</p>
<h2 id="1-">1. 英文能力</h2>
<p><strong>首先，你应该对英文读写没什么问题!</strong></p>
<p>为什么这么说？<strong>这主要是针对计算机相关的知识，逻辑是这样的，如果你上了Google还是在用中文关键词，那么你好不容易出来了，结果又回去了，所以没什么意义呢？</strong> 换言之，科学上网的目的是为了进入广阔的世界范围与全世界的人交流，所以，英文是必备的，如果你英文有问题，VPN过去的用处也不大。</p>
<p>所以，我把这个前提条件放在第一的位置，就是说—— <strong>真正的墙不是GFW，而是人的大脑！</strong> 意思是，屏蔽你获得信息能力的不是墙，而很大一部分则是我们自己的语言能力！</p>
<h2 id="2-vps">2. 购买VPS</h2>
<p>然后，你需要一个VPS。</p>
<p>（注：<em>当然，你也可以直接购买一些科学上网的服务，但我这里不推荐了，一方面是广告，另一方面通常这样的服务非常的不稳定，而且也容易被代理方做中间件攻击</em>）</p>
<p><strong>现在你买一台VPS也不贵了，也就是一个月10美金左右（70元），我个人觉得一个月花70元钱不算奢侈的事，而且会让你的生活质量得得改善</strong>。</p>
<p>（注：<em>我现在每个投入在科学上网上的成本大概在不到1000元人民币左右，常备3-5个不同国家的VPS，因为国内的网络路由经常性的变化，所以，为了确保总是有一条快的，所以，得多备几个</em>）。</p>
<h3 id="21-vps">2.1 常规VPS</h3>
<p>对于VPS，下面是一些常规选项。</p>
<ul>
<li><a href="https://lightsail.aws.amazon.com/">AWS LightSail</a> 是一个非常便宜好用的服务，最低配置一个月 $3.5 美金，目前的Zone不多，推荐使用日本或新加坡（支持银联卡）</li>
<li><a href="https://aws.amazon.com/cn/">AWS EC2</a>香港、日本或韩国申请个免费试用一年的EC2 VPS （支持银联卡）</li>
<li><a href="https://cloud.google.com/">Google Cloud Platform</a>提供免费试用，赠送300刀赠金（需要国际信用卡）</li>
<li><a href="https://www.linode.com">Linode</a>买个一月USD10刀的VPS</li>
<li><a href="https://www.conoha.jp/zh/">Conoha</a>上买一个日本的VPS，一个月900日元 （可以支付宝）</li>
<li><a href="https://www.vultr.com">Vultr</a>上买一个日本的VPS，一个月5刀 （可以支付宝）</li>
<li><a href="https://www.oracle.com/cloud/free/">Oracle Cloud</a>两台VPS无限期使用，可选美日韩等地（需要国际信用卡）</li>
</ul>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>
<p>在中国，因为有太多的网络提供商，所以，国内的网络也是很奇葩的，可以看到的是，不同的地方，不同的网络，到不同的国家完全不一样，而且还经常性地调整路由，所以，经常性地有时候快有时候慢，简真就是随机的。所以，像我这样要求比较高的人，一般会备3-5个不同国家地区的VPS，以保障上网的速度。</p>
</li>
<li>
<p>香港网速应该是比较好的，但是香港的成本也是比较高的。</p>
</li>
<li>
<p>日本区的网络质量并不一定很好，有时候快的飞快，但有时候会有很大的丢包率（不同的网络不一样），有时候会很慢。上述的这几个VPS服务商中，AWS韩国和日本会好点，然后是Linode，最后是Conoha和Vultr（如果你有更好的，请推荐）</p>
</li>
<li>
<p>Google Cloud Platform - GCP 的香港和台湾结点也是很快的。但是你要能买GCP的主机，你还得先翻墙，所以，感觉有点死锁了。所以，你可能先用Vultr（按时付费）翻墙，然后再到GCP上购买。</p>
</li>
</ul>
</blockquote>
<h3 id="22-cn2-">2.2 CN2 线路</h3>
<p>如果你需要更好更高速的网络服务（比如你要看Youtube的1080P），那么，你需要下面的这些服务器资源了（价格也会高一些）</p>
<p><code>CN2</code> 和 <code>GIA</code> 是两个关键词。<strong>CN2 GIA</strong> 全称 China telecom Next Carrier Network- Global Internet Access 电信国际精品网络，特征是路由线路上骨干节点均为59.43开头的IP。如果想要寻找接入CN2线路的国外VPS提供商，建议使用 <code>Next Carrier Network</code> 或者 <code>CN2</code> 这个关键词搜索即可。</p>
<p>多说一句， CN2本身又分为两种类型：</p>
<ul>
<li>
<p><strong>CN2 GT</strong>: CN2 里属于Global Transit的产品(又名GIS-Global Internet Service)，在CN2里等级低，省级/出国节点为 <code>202.97</code> 开头，国际骨干节点有2～4个 <code>59.43</code> 开头的CN2节点。在出国线路上拥堵程度一般，相对于163骨干网的稍强，相比CN2 GIA，性价比也较高。</p>
</li>
<li>
<p><strong>CN2 GIA</strong>: CN2 里属于Global Internet Access的产品，等级最高，省级/出国/国际骨干节点都以<code>59.43</code>开头，全程没有<code>202.97</code>开头的节点。在出国线路上表现最好，很少拥堵，理论上速度最快最稳定，当然，价格也相对 CN2 GT 偏高。</p>
</li>
</ul>
<p>关于 <code>CN2</code> 线路的主机提供商，下面罗列几个</p>
<ul>
<li><a href="https://bwh8.net/aff.php?aff=39384">搬瓦工</a>  这应该是美区最好的一个用来科学上网的VPS提供商了，实测飞快。购买时你需要注意VPS规格上的 <code>CN2</code> 和 <code>GIA</code> 的描述。（注：点击主页右上角的 <code>regisiter</code> 以后，你可以看到页面上方有两个导航条，在下面的导航条上点 <code>Services</code> -&gt; <code>Order New Services</code> 就可以看到所有的列表了。买完后，你可能需要重装一下操作系统，装成64位带BBR的 ）</li>
<li><a href="https://clientarea.gigsgigscloud.com/index.php?/cart/cloudlet-v-hk/&amp;step=0">Gigsgigscloud</a> CN2 GIA 在香港的结点是很不错的，当然，价格也很不错（建议几个人一起平摊费用）</li>
<li><a href="https://www.kvmla.com/">Kvmla</a> 香港地区的CN2 GIA提供商 每月80元</li>
<li><a href="https://manage.hostdare.com/index.php">Hostdare</a> 的CN2 GIA产品也是三网直连，KVM和OpenVZ两种架构，KVM产品长期缺货</li>
</ul>
<p>更多的可以参考这篇文章《<a href="https://wzfou.com/cn2-gia-vps/">CN2 GIA VPS主机收集整理汇总-电信,联通,移动三网CN2 GIA线路VPS主机</a>》（注：随时间推移，这篇文章的内容可能会失效）</p>
<p>重点说一下，<strong>CN2 GIA + 香港机房</strong>，你会得到巨快无比的上网速度，然而，香港地区的VPS的确是有点贵了。在Youtube.com上看1080p的视频毫无压力。虽然阿里云和腾讯的也有，但是被查到的风险基本上是100%，不建议使用，被抓了别怪我没警告过你。</p>
<h3 id="23-ncp-">2.3 NCP 线路</h3>
<p><strong>NCP</strong> 全称 New Cross Pacific（新跨太平洋海底光缆系统）。
2018年11月底，中国到美国之间的海底光缆新开通了NCP线路，并且容量更大（系统设计容量超过80Tbps），路由更少（中国上海到美国中间路由节点只有11个，ping值110ms）。</p>
<p>NCP线路全长13,000公里，连接美国俄勒冈州希尔斯伯勒，连接崇明（中国大陆），南汇（中国大陆），临港（中国大陆），釜山（韩国），头城（台湾），和丸山（日本）。</p>
<p>相对于第二条中美直达海底光缆系统（跨太平洋快线，TPE），现阶段NCP线路的网络流量更少更稳定。特征是华东/中地区流量会经过NCP直达路由节点，IP地址为202.97.95.201/202。</p>
<p>关于 <code>NCP</code> 线路的主机提供商，下面罗列两个</p>
<ul>
<li><a href="https://www.50kvm.com">50KVM VPS</a> 截止2018年12月2日KVM 产品最低价格￥81.60/月。</li>
<li><a href="https://t667.com/">OLVPS</a> 截止2018年12月2日KVM 产品最低价格¥22/月。</li>
</ul>
<h2 id="3--shadowsocks--vpn-">3. 搭建 Shadowsocks 和 VPN 服务</h2>
<h3 id="31-docker">3.1 设置Docker服务</h3>
<p>首先，你要安装一个Docker CE 服务，这里你要去看一下docker官方的安装文档：</p>
<ul>
<li><a href="https://docs.docker.com/install/linux/docker-ce/centos/">CentOS 上的 Docker CE 安装</a></li>
<li><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Ubuntu 上的 Docker CE 安装</a></li>
</ul>
<p>然后开始设置你的VPN/SS服务</p>
<h3 id="32--tcp-bbr-">3.2 开启 TCP BBR 拥塞控制算法</h3>
<p>TCP BBR（Bottleneck Bandwidth and Round-trip propagation time）是由Google设计，于2016年发布的拥塞算法。以往大部分拥塞算法是基于丢包来作为降低传输速率的信号，而BBR则基于模型主动探测。该算法使用网络最近出站数据分组当时的最大带宽和往返时间来创建网络的显式模型。数据包传输的每个累积或选择性确认用于生成记录在数据包传输过程和确认返回期间的时间内所传送数据量的采样率。该算法认为随着网络接口控制器逐渐进入千兆速度时，分组丢失不应该被认为是识别拥塞的主要决定因素，所以基于模型的拥塞控制算法能有更高的吞吐量和更低的延迟，可以用BBR来替代其他流行的拥塞算法，例如CUBIC。Google在YouTube上应用该算法，将全球平均的YouTube网络吞吐量提高了4%，在一些国家超过了14%。</p>
<p>BBR之后移植入Linux内核4.9版本，并且对于QUIC可用。</p>
<p>如果开启，请参看 《<a href="https://github.com/iMeiji/shadowsocks_install/wiki/%E5%BC%80%E5%90%AFTCP-BBR%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95">开启TCP BBR拥塞控制算法</a> 》</p>
<h3 id="33-shadowsocks">3.3 设置Shadowsocks服务</h3>
<p>Shadowsocks 的 Docker 启动脚本 （其中的 <code>SS_PORT</code> 和 <code>SS_PASSWD</code> 需要重新定义一下）</p>
<pre><code>#!/bin/bash

SS_PORT=1984
SS_PASSWD=MyPasswd

sudo docker run -dt --name ss \
   -p ${SS_PORT}:${SS_PORT} mritd/shadowsocks \
   -s &quot;-s 0.0.0.0 -p ${SS_PORT} -m aes-256-cfb -k ${SS_PASSWD} --fast-open&quot;
</code></pre><h3 id="34-l2tpipsec">3.4 设置L2TP/IPSec服务</h3>
<p>L2TP/IPSec 的启动脚本，其中的三个环境变量 <code>USER</code>， <code>PASS</code> 和 <code>PSK</code> 需要替换一下。</p>
<pre><code>#!/bin/bash

USER=someone
PASS=password
PSK=psk_key

sudo docker run -d  --privileged \
    -e PSK=${PSK} \
    -e USERNAME=${USER} -e PASSWORD=${PASS} \
    -p 500:500/udp \
    -p 4500:4500/udp \
    -p 1701:1701/tcp \
    -p 1194:1194/udp  \
    siomiz/softethervpn
</code></pre><h3 id="35-pptp">3.5 设置PPTP服务</h3>
<p>PPTP不安全，请慎重使用</p>
<pre><code>sudo docker run -d --privileged --net=host 
                -v {/path_to_file/chap-secrets}:/etc/ppp/chap-secrets \
                mobtitude/vpn-pptp
</code></pre><p>PPTP 使用 <code>/etc/ppp/chap-secrets</code> 文件设置用户名和密码，所以你需要给docker容器提供这个文件，下面是这个文件的示例：</p>
<pre><code># Secrets for authentication using PAP
# client    server      secret           acceptable local IP addresses
  fuckgfw   *           whosyourdaddy    *
</code></pre><h2 id="4-">4. 客户端设置</h2>
<h3 id="41-shadowsocks-">4.1 Shadowsocks 客户端</h3>
<p>对于 Shadowsocks 客户端，可以到这里查看 <a href="https://shadowsocks.org/en/download/clients.html">Shadowsocks Clients</a></p>
<ul>
<li>MacOS 上你可以下载 <a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases">ShadowsocksX-NG</a></li>
<li>Windows上你可以下载 <a href="https://github.com/shadowsocks/shadowsocks-windows/releases">Shadowsocks-Windows</a>，需要先安装 <a href="https://dotnet.microsoft.com/download/dotnet-framework-runtime">.NET Framework</a></li>
<li>Android的客户端，你可以用手机访问并下载 <a href="https://github.com/shadowsocks/shadowsocks-android/releases">Shadowsocks-Android</a></li>
<li>iPhone 端就比较麻烦了。因为国内全都被下架了。
<ol>
<li>你需要注册一个美国的苹果ID.</li>
<li>然后 iTunes/App Store 用这个美区的ID登录（不是退出iCloud ，而是退出App Store）</li>
<li>然后搜索 <code>Wingy</code> ，你会搜到 <code>OpenWingy</code>, <code>SuperWingy</code> 等</li>
</ol>
</li>
</ul>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>关于如何注册美区Apple ID账号，你可以参看如下的这几篇文章（我不保证这些文章可不可用，但是你可以自行Google）。
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/36574047">5分钟注册美国区Apple ID（18年亲测有效）</a></li>
<li><a href="https://www.jianshu.com/p/b32da641e849">2018年6月亲测：注册美国地区苹果apple ID帐号终极教程</a></li>
<li><a href="https://blog.csdn.net/ziyuzhiye/article/details/82769129">iOS开发之注册美国Apple Id不需要绑定信用卡，亲测可用</a></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="42-vpn-">4.2 VPN 客户端</h3>
<p>对于L2TP/IPSec，几乎所有的客户端操作系统（无论是Windows/Mac/Linux的电脑，还是iPhone/Android）都支持，你可以自行Google。</p>
<ul>
<li><a href="https://www.jianshu.com/p/24e48cfb574f">Mac OS X PPTP/L2TP设置教程</a></li>
<li><a href="http://nic.upc.edu.cn/2016/0928/c7809a132077/page.htm">Windows 7操作系统配置L2TP VPN方法</a></li>
</ul>
<h2 id="5-">5. 流量伪装和其它方式</h2>
<p>我们知道，你翻墙的行为，其实都是在被探测中的，因为无论你的手机还是宽带都是有需要到运营商那里开通上网账户的，所以，各大电信运营商有你的所有的上网的记录。</p>
<p>在Youtube上有个视频，你可以看一下 《<a href="https://www.youtube.com/watch?v=G-P8eyltc5E&amp;feature=youtu.be">哪种翻墙软件更隐蔽？</a>》，这个播主实测过，SS也好，SSR也好，无论你怎么混淆，都是没用的，都是可以被抓出来的。只有V2Ray 和 Brook 可以伪装得很好。</p>
<blockquote>
<p><strong>注：</strong> 说句老实话，我其时并不想害怕别人知道自己的上什么样的网站，因为我觉得我访问的都是合法的网站，但是就今天这个局势我也没办法——为什么要让像我这样的光明正大的良民搞得跟偷鸡摸狗之徒一样……</p>
</blockquote>
<h3 id="51-v2ray">5.1 V2Ray</h3>
<p>V2Ray 是一个与 Shadowsocks 类似的代理软件。</p>
<ul>
<li>V2Ray 用户手册：<a href="https://www.v2ray.com"><a href="https://www.v2ray.com">https://www.v2ray.com</a></a></li>
<li>V2Ray 项目地址：<a href="https://github.com/v2ray/v2ray-core"><a href="https://github.com/v2ray/v2ray-core">https://github.com/v2ray/v2ray-core</a></a></li>
<li>V2Ray Telegram 使用群链接：<a href="https://t.me/projectv2ray">https://t.me/projectv2ray</a></li>
</ul>
<p>V2Ray 配合一些模块目前来说可以伪装成正常的流量。但是配置相当复杂。大家可以自己Google自己玩吧。</p>
<h3 id="52-brook">5.2 Brook</h3>
<p>Brook是一个由 Go语言编写的跨平台代理软件，支持 Linux/MacOS/Windows/Android/iOS 各个平台。</p>
<ul>
<li>Brook Github项目：<a href="https://github.com/txthinking/brook"><a href="https://github.com/txthinking/brook">https://github.com/txthinking/brook</a></a></li>
<li>Github Wiki教程：<a href="https://github.com/txthinking/brook/wiki/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E(%E4%B8%AD%E6%96%87)"><a href="https://github.com/txthinking/brook/wiki/">https://github.com/txthinking/brook/wiki/</a>使用说明(中文)</a></li>
</ul>
<p>服务器一行命令安装：</p>
<pre><code>wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/brook.sh &amp;&amp; chmod +x brook.sh &amp;&amp; bash brook.sh
</code></pre><p>运行 <code>brook.sh</code> 会出菜单项，你可以按菜单项来，主要就是设置端口号，密码。很简单的，我这里就不截图了，因为这个脚本运行起来中文菜单式的。</p>
<p>然后你可以在 Brook 项目的 Github 首页上下载不同平台的客户端。设置起来也很简单！</p>
<h2 id="6--ip-">6. 针对 IP 被封的解决方案</h2>
<p>花钱购买的 VPS 即便做了流量伪装依然有很大的几率 IP 被封锁，大多 VPS 服务商并不提供更换 IP 的服务，使用 CDN 可以让被封锁的 VPS 继续发挥翻墙功能。</p>
<h3 id="61-cloudflare">6.1 Cloudflare</h3>
<p>Cloudflare 是一个 CDN 服务商，目前国内依然能正常的访问，可以作为跳板来实现翻墙。</p>
<p>注册 Cloudflare 帐号，并有一个空闲域名（三级域名即可），交给 Cloudflare 托管并将域名指向被封的 VPS IP，注意开启 Proxied 并且 SSL-TLS 使用 Flexible 选项。</p>
<p>Cloudflare 只需免费方案足以，不必花钱。</p>
<h3 id="62-v2ray">6.2 V2Ray</h3>
<p>VPS 上正常安装并配置好 V2Ray，注意两点:</p>
<ol>
<li>传输协议必须要使用 ws</li>
<li>要使用 80 或者 8080 端口</li>
</ol>
<p>如果端口有其他用途，那么用 Nginx/Caddy 之类软件，做一个 WebSocket proxy 到 V2Ray 即可。</p>
<h3 id="63-">6.3 补充</h3>
<p>客户端注意使用网址来连接。</p>
<p>目前支持 WebSocket 的免费 CDN 似乎只有 Cloudflare 一家，国内 CDN 服务商既不支持也不安全，不要考虑了。如果有更好的服务商欢迎补充。</p>
<p>网络延迟比直连增加不少，如果是频繁操作会很痛苦。网络带宽如果运气好可能比直连还优化了，用来看 Youtube 搞不好更流畅。</p>
<h2 id="7-">7. 其它</h2>
<p>如下还有一些其它的方式（注：均由网友提供，我没有验证过）</p>
<p><a href="https://getoutline.org/en/home">Outline</a> 是由 Google 旗下 <a href="https://jigsaw.google.com/">Jigsaw</a> 团队开发的整套翻墙解决方案。Server 端使用 Shadowsocks，MacOS, Windows, iOS, Android 均有官方客户端。使用 Outline Manager 可以一键配置 DigitalOcean。其他平台例如 AWS, Google Cloud 也提供相应脚本。主要优点就是使用简单并且整个软件栈全部<a href="https://github.com/Jigsaw-Code/?q=outline">开源</a>，有专业团队长期维护。</p>
<p>（全文完）</p>
]]></content>
        </item>
        
        <item>
            <title>解决添加到GitIgnore的文件没被忽略的问题</title>
            <link>https://blog.sailfishc.cn/posts/2019/10/%E8%A7%A3%E5%86%B3%E6%B7%BB%E5%8A%A0%E5%88%B0gitignore%E7%9A%84%E6%96%87%E4%BB%B6%E6%B2%A1%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84%E9%97%AE%E9%A2%98/</link>
            <pubDate>Wed, 30 Oct 2019 09:56:18 +0800</pubDate>
            
            <guid>https://blog.sailfishc.cn/posts/2019/10/%E8%A7%A3%E5%86%B3%E6%B7%BB%E5%8A%A0%E5%88%B0gitignore%E7%9A%84%E6%96%87%E4%BB%B6%E6%B2%A1%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
            <description> 问题简述
 在开发中有时候会遇到把某文件添加到Git Ignore文件中，但是在Commit的时候发现这个文件还是可以被Commit，并没有被忽略掉，在查看了Git的官方文档，发现官网文档已经做了如下解释：
The purpose of gitignore files is to ensure that certain files not tracked by Git remain untracked. To stop tracking a file that is currently tracked, use：git rm —cached. 意思是：gitignore文件的目的是确保未被Git跟踪的某些文件保持未跟踪状态。要停止跟踪当前跟踪的文件，请使用git rm --cached。
 原因
 一般来说出现这种问题的原因是使用了IDE，在创建文件的时候IDE自动给add进去了，被Git追踪管理了。
 具体执行
  如果是单个文件：git rm —cached path/filename 如果是文件夹：git rm -r —cached path   参考文档
  Git - gitignore Documentation Git - git-rm Documentation  </description>
            <content type="html"><![CDATA[<blockquote>
<p>问题简述</p>
</blockquote>
<p>在开发中有时候会遇到把某文件添加到Git Ignore文件中，但是在Commit的时候发现这个文件还是可以被Commit，并没有被忽略掉，在查看了Git的官方文档，发现官网文档已经做了如下解释：</p>
<pre><code>The purpose of gitignore files is to ensure that certain files not tracked by Git remain untracked.
To stop tracking a file that is currently tracked, use：git rm —cached.
</code></pre><p>意思是：gitignore文件的目的是确保未被Git跟踪的某些文件保持未跟踪状态。要停止跟踪当前跟踪的文件，请使用<code>git rm --cached</code>。</p>
<blockquote>
<p>原因</p>
</blockquote>
<p>一般来说出现这种问题的原因是使用了IDE，在创建文件的时候IDE自动给add进去了，被Git追踪管理了。</p>
<blockquote>
<p>具体执行</p>
</blockquote>
<ul>
<li>如果是单个文件：git rm —cached  path/filename</li>
<li>如果是文件夹：git rm -r —cached path</li>
</ul>
<blockquote>
<p>参考文档</p>
</blockquote>
<ul>
<li><a href="https://git-scm.com/docs/gitignore">Git - gitignore Documentation</a></li>
<li><a href="https://git-scm.com/docs/git-rm">Git - git-rm Documentation</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>通过Hugo&#43;Github快速搭建博客</title>
            <link>https://blog.sailfishc.cn/posts/2019/10/%E9%80%9A%E8%BF%87hugo-github%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</link>
            <pubDate>Thu, 24 Oct 2019 15:05:56 +0800</pubDate>
            
            <guid>https://blog.sailfishc.cn/posts/2019/10/%E9%80%9A%E8%BF%87hugo-github%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</guid>
            <description>写在前面
 程序员总想有自己的一个博客，厌倦了CSDN，简书，掘金这些博客网站，那就自己搭建一个吧，这篇文章包含了从0开始搭建到部署，可以没有自己的域名，自己的服务器，但是面包总会有的。
先罗列下常见的博客网站：
 Hexo WordPress JekyII Ghost Hugo  Hexo是我之前用的博客网站，但是在使用过程中遇到了一些问题：
 node环境问题较多，本身对Node不熟悉，解决成本高 node_modules过大，网络问题下载依赖过慢 编译为html过程越来越慢  后来发现了Hugo，发现Github已经3w多star了，Hugo官网对于Hugo的介绍是：The world’s fastest framework for building websites，总结起来就一句话，那就是快！！！
快速开始  Quick Start | Hugo  Hugo安装很简单，就以Mac为例快速开始：
 安装Hugo：brew install Hugo 查看Hugo版本：Hugo version 新建一个网站，名字为quickstart：Hugo new site quickstart 安装主题  进入目录：cd quickstart 使用Git Init创建Git仓库：git init 下载主题，放入theme目录（名字为ananke）：git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke 使用主题：echo ‘theme = “ananke”’ &amp;gt;&amp;gt; config.toml   新建MarkDown文章（也可以用现有的放入content/posts目录）：Hugo new posts/my-first-post.md 本地预览：Hugo server -D 打开浏览器：http://localhost:1313 搞定🌹  部署 本地搭建好了网站要部署到外部服务上，常见的方式有三种：</description>
            <content type="html"><![CDATA[<blockquote>
<p>写在前面</p>
</blockquote>
<p>程序员总想有自己的一个博客，厌倦了CSDN，简书，掘金这些博客网站，那就自己搭建一个吧，这篇文章包含了从0开始搭建到部署，可以没有自己的域名，自己的服务器，但是面包总会有的。</p>
<p>先罗列下常见的博客网站：</p>
<ul>
<li>Hexo</li>
<li>WordPress</li>
<li>JekyII</li>
<li>Ghost</li>
<li>Hugo</li>
</ul>
<p>Hexo是我之前用的博客网站，但是在使用过程中遇到了一些问题：</p>
<ul>
<li>node环境问题较多，本身对Node不熟悉，解决成本高</li>
<li>node_modules过大，网络问题下载依赖过慢</li>
<li>编译为html过程越来越慢</li>
</ul>
<p>后来发现了Hugo，发现Github已经3w多star了，Hugo官网对于Hugo的介绍是：<code>The world’s fastest framework for building websites</code>，总结起来就一句话，那就是快！！！</p>
<h2 id="heading">快速开始</h2>
<ul>
<li><a href="https://gohugo.io/getting-started/quick-start/">Quick Start | Hugo</a></li>
</ul>
<p>Hugo安装很简单，就以Mac为例快速开始：</p>
<ul>
<li>安装Hugo：<code>brew install Hugo</code></li>
<li>查看Hugo版本：<code>Hugo version</code></li>
<li>新建一个网站，名字为<code>quickstart</code>：<code>Hugo new site quickstart</code></li>
<li>安装主题
<ul>
<li>进入目录：<code>cd quickstart</code></li>
<li>使用Git Init创建Git仓库：<code>git init</code></li>
<li>下载主题，放入theme目录（名字为<code>ananke</code>）：<code>git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke</code></li>
<li>使用主题：<code>echo ‘theme = “ananke”’ &gt;&gt; config.toml</code></li>
</ul>
</li>
<li>新建MarkDown文章（也可以用现有的放入content/posts目录）：<code>Hugo new posts/my-first-post.md</code></li>
<li>本地预览：<code>Hugo server -D</code></li>
<li>打开浏览器：<code>http://localhost:1313</code></li>
<li>搞定🌹</li>
</ul>
<h2 id="heading1">部署</h2>
<p>本地搭建好了网站要部署到外部服务上，常见的方式有三种：</p>
<ul>
<li>部署Github Pages</li>
<li>部署到自己服务器，用静态服务器（例如Nginx）上</li>
<li>使用一些云服务（推荐）</li>
</ul>
<p>先简要介绍下流程，Hugo将Markdown转为静态资源（Html，Css，Js）等资源，放在public目录下，将public发布到静态服务器或者CDN下达到外部可以访问的效果。</p>
<p>对于自己购买服务器部署的方式目前是不推荐的，因为刚开始博客没有自己的品牌，浪费一些资源在服务器上的话是不划算的（也增加维护成本），所以就只考虑基于Github Pages和云服务这两种方式，对于Github Pages，简要说明下，Github Pages提供了3种方式：</p>
<ul>
<li>新建Github用户名（例如<code>sailfishc</code>）的仓库：<code>sailfishc.github.io</code></li>
<li>新建项目，在<code>master</code>分支下新建<code>docs</code>目录</li>
<li>新建项目，添加<code>gh-pages</code>分支</li>
</ul>
<p>最开始本来想尝试第一种，但是还有一个博客已经使用这种模式了，暂时是用不了，因为第二种会将源代码和静态网站在一个分支中，也就不考虑，就采用了第三种，对于第三种方式的部署，最开始采用了Travis部署的方式，但是经过一些尝试，效果并不好（主要是对于Travis的脚本不熟悉，找了一些脚本效果比较差），最后也放弃了，有兴趣的小伙伴们可以看参考文章中对于Travis部署的一些博客，之后一段时间采用了本地执行脚本的方式，等文章写完后，执行脚本<a href="https://gist.github.com/Sailfishc/5c8861ace0469aec69f834d972da64f3">push hugo site to Github gh-pages branch · GitHub</a> ，脚本会自动将生成静态public文件，然后加入<code>gh-pages</code>分支，然后将源代码push到<code>master</code>分支，public下的文件push到<code>gh-pages</code>分支，就可以使用<code>https://sailfishc.github.io/sail-blog</code>访问博客站点了。</p>
<p>大功告成了吗？没有，因为没使用第一种Github pages方案，这个链接包含了<code>项目这名</code>这一级路径，用着很难受，于是就有了之后的改版，也就是<code>Host On Render</code>的方案。</p>
<ul>
<li><a href="https://gohugo.io/hosting-and-deployment/hosting-on-render/">Host on Render | Hugo</a></li>
</ul>
<blockquote>
<p>将网站部署到Render上，享受全球CDN服务，通过<code>Cloudflare</code>自定义域名</p>
</blockquote>
<ul>
<li>打开Render</li>
<li>注册</li>
<li>创建<code>Webservice</code></li>
<li>授予仓库权限</li>
<li>设置参数
<ul>
<li>Environment</li>
<li>Build Command</li>
<li>Publish Directory</li>
</ul>
</li>
<li>将自定义域名加入Render，在Cloudflare配置DNS转发</li>
<li>搞定🌹</li>
</ul>
<h2 id="heading2">一些总结</h2>
<blockquote>
<p>中间走了很多弯路，到最后发现官方文档已经有很多成熟的方案，只是自己没认真看，借<code>左耳朵耗子的话</code>：花时间学习基础知识，花时间度文档，只要把基础打扎实，认真读下文档，就会生出很多时间。</p>
</blockquote>
<blockquote>
<p>参考文章</p>
</blockquote>
<ul>
<li><a href="https://axdlog.com/zh/2018/using-hugo-and-travis-ci-to-deploy-blog-to-github-pages-automatically/">利用Travis CI和Hugo將Blog自動部署到Github Pages - AxdLog</a></li>
<li><a href="https://zyfdegh.github.io/post/201705-how-i-setup-hugo/">我是如何用 Hugo、Travis CI 和 GitHub Pages 搭建博客的? - 独行的蚂蚁 - 博客</a></li>
<li><a href="https://blog.yuantops.com/tech/hugo-travis-ci-auto-deploy-to-gh-pages/">Blog自动部署实践: Hugo + Travis CI -&gt; GitHub Pages // Yuantops’ Blog</a></li>
<li><a href="https://medium.com/swlh/hosting-a-hugo-blog-on-github-pages-with-travis-ci-e74a1d686f10">Hosting a Hugo blog on GitHub Pages with Travis CI - The Startup - Medium</a></li>
<li><a href="https://gohugo.io/hosting-and-deployment/hosting-on-github/">Host on GitHub | Hugo</a></li>
<li><a href="https://www.gohugo.org/doc/tutorials/github-pages-blog/">Hosting on GitHub Pages - Hugo中文文档</a></li>
<li><a href="https://gohugo.io/hosting-and-deployment/hosting-on-render/">Host on Render | Hugo</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>以练代学，学习算法和数据结构</title>
            <link>https://blog.sailfishc.cn/posts/2019/10/%E4%BB%A5%E7%BB%83%E4%BB%A3%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
            <pubDate>Tue, 22 Oct 2019 17:37:00 +0000</pubDate>
            
            <guid>https://blog.sailfishc.cn/posts/2019/10/%E4%BB%A5%E7%BB%83%E4%BB%A3%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
            <description>数据结构和算法的学习总是一条漫长而艰辛的道路，做题是一条学习数据结构和算法的捷径，之前自己零零碎碎的刷了一些LeetCode的题，但是效果并不好，后来吸取了一些刷题人的经验，结合自己对于语言知识和数据结构及算法的掌握程度，总结了自己的一套刷题方式。
首先是对自己的定位，熟悉Java语言，对于常用的数据结构比较熟悉，算法较弱，目标是在较短的时间去熟练掌握数据结构和算法，基于这几点，不能走常规的学习路径（如果在校或者是时间比较充裕可以参考）：
 算法导论 数据结构与算法分析 配合LeetCode或者OJ来练习   我的学习计划是这样的（以练代学）：
  寻找LeetCode的Java版最优解实现（至少400题） 将数据结构和算法进行分类（目录见后文） 寻找可以快速熟悉的视频资源（极客时间的算法面试40讲就挺好） 按分类将LeetCode的题目归类，附上题号，LeetCode题目链接，题目难度分类，最优解地址（Github地址），自己的解法地址   具体是这样做的（第一遍）
  先跟着视频学习（例如数组，链表作为一个阶段，去了解理论基础，及几道经典题型解读） 从分类中找出要练习的LeetCode题目 深度思考10分钟去寻找思路 有思路的话写代码，对比最优解 没有思路直接看答案（最好有视频讲解），理解题目解题思路 自己重新做一遍   第二遍刷题（基本同第一遍步骤）
  数据结构和算法分类
  数据结构  栈 队列 表  数组 单链表 双链表 循环链表 散列表   二叉树  平衡二叉树 红黑树 哈弗曼树 堆   多叉树  B，B+Tree 字典树   图  有向图 无向图 权图     算法  算法思想  分治 动态规划 贪心 回溯 分支界定   复杂度  时间复杂度 空间复杂度   字符串匹配  BF算法 BM算法 Sunday算法 KMP算法 Tire树   排序  插入排序  希尔 直插   交换排序  冒泡 快排（重点）   选择排序  简单排序 堆排序（重点）   归并排序 基数排序   查找  二分查找 二叉排序树 B数 Hash BloomFilter      </description>
            <content type="html"><![CDATA[<p>数据结构和算法的学习总是一条漫长而艰辛的道路，做题是一条学习数据结构和算法的捷径，之前自己零零碎碎的刷了一些LeetCode的题，但是效果并不好，后来吸取了一些刷题人的经验，结合自己对于语言知识和数据结构及算法的掌握程度，总结了自己的一套刷题方式。</p>
<p>首先是对自己的定位，熟悉Java语言，对于常用的数据结构比较熟悉，算法较弱，目标是在较短的时间去熟练掌握数据结构和算法，基于这几点，不能走常规的学习路径（如果在校或者是时间比较充裕可以参考）：</p>
<ul>
<li>算法导论</li>
<li>数据结构与算法分析</li>
<li>配合LeetCode或者OJ来练习</li>
</ul>
<blockquote>
<p>我的学习计划是这样的（以练代学）：</p>
</blockquote>
<ul>
<li>寻找LeetCode的Java版最优解实现（至少400题）</li>
<li>将数据结构和算法进行分类（目录见后文）</li>
<li>寻找可以快速熟悉的视频资源（极客时间的算法面试40讲就挺好）</li>
<li>按分类将LeetCode的题目归类，附上题号，LeetCode题目链接，题目难度分类，最优解地址（Github地址），自己的解法地址</li>
</ul>
<blockquote>
<p>具体是这样做的（第一遍）</p>
</blockquote>
<ul>
<li>先跟着视频学习（例如数组，链表作为一个阶段，去了解理论基础，及几道经典题型解读）</li>
<li>从分类中找出要练习的LeetCode题目</li>
<li>深度思考10分钟去寻找思路</li>
<li>有思路的话写代码，对比最优解</li>
<li>没有思路直接看答案（最好有视频讲解），理解题目解题思路</li>
<li>自己重新做一遍</li>
</ul>
<blockquote>
<p>第二遍刷题（基本同第一遍步骤）</p>
</blockquote>
<blockquote>
<p>数据结构和算法分类</p>
</blockquote>
<ul>
<li>数据结构
<ul>
<li>栈</li>
<li>队列</li>
<li>表
<ul>
<li>数组</li>
<li>单链表</li>
<li>双链表</li>
<li>循环链表</li>
<li>散列表</li>
</ul>
</li>
<li>二叉树
<ul>
<li>平衡二叉树</li>
<li>红黑树</li>
<li>哈弗曼树</li>
<li>堆</li>
</ul>
</li>
<li>多叉树
<ul>
<li>B，B+Tree</li>
<li>字典树</li>
</ul>
</li>
<li>图
<ul>
<li>有向图</li>
<li>无向图</li>
<li>权图</li>
</ul>
</li>
</ul>
</li>
<li>算法
<ul>
<li>算法思想
<ul>
<li>分治</li>
<li>动态规划</li>
<li>贪心</li>
<li>回溯</li>
<li>分支界定</li>
</ul>
</li>
<li>复杂度
<ul>
<li>时间复杂度</li>
<li>空间复杂度</li>
</ul>
</li>
<li>字符串匹配
<ul>
<li>BF算法</li>
<li>BM算法</li>
<li>Sunday算法</li>
<li>KMP算法</li>
<li>Tire树</li>
</ul>
</li>
<li>排序
<ul>
<li>插入排序
<ul>
<li>希尔</li>
<li>直插</li>
</ul>
</li>
<li>交换排序
<ul>
<li>冒泡</li>
<li>快排（重点）</li>
</ul>
</li>
<li>选择排序
<ul>
<li>简单排序</li>
<li>堆排序（重点）</li>
</ul>
</li>
<li>归并排序</li>
<li>基数排序</li>
</ul>
</li>
<li>查找
<ul>
<li>二分查找</li>
<li>二叉排序树</li>
<li>B数</li>
<li>Hash</li>
<li>BloomFilter</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>2018年总结</title>
            <link>https://blog.sailfishc.cn/posts/2019/01/2018%E5%B9%B4%E6%80%BB%E7%BB%93/</link>
            <pubDate>Sun, 13 Jan 2019 17:37:00 +0000</pubDate>
            
            <guid>https://blog.sailfishc.cn/posts/2019/01/2018%E5%B9%B4%E6%80%BB%E7%BB%93/</guid>
            <description>2019年很多人都开始写自己的2018年的总结，虽然已经13号了，但是还是要总结下自己的2018，回头一想，一年过得还真快，2018年加入了创业公司，一年竟也过去了，在这一年里面，也没有做出什么成绩，但是还是有点收获，也总结分享一下。
工作  2018年由于一些特殊原因，部门成立了子公司，从零开始，也算是自己第一次加入创业公司
 虽然是换了一家公司，但是身边的小伙伴还是那些，所以并没感到有多大的变化，前几个月该怎么做就怎么做，之后渐渐感到了业务上的压力，创业维艰，伴随着的就是加班多了，迭代快了，要参与到业务中去思考产品的方向了，对于自己来说，自己的职责变了一点，感觉从大公司的螺丝钉找到了一些归属感。这一年，有的老同事离职了，也有新同事进来，自己也开始带人了，虽然不多，但也是要去改变一些工作方式了。
产品迭代 那些日子，每次上线一个版本之后，大家都去喝酒撸串，尽兴的玩。开发之前骂着产品这么多需求，但是产品上线的时候还是开心的。在公司总结上，我还是觉得团队的战斗力没有比一年前变得更强，只是有部分人的能力变强了，
研发 得益于之前公司的基础建设，还是有一些基础储备，项目在RPC，ZK，Cache，监控，构建部署，MQ，DB维护上还是没怎么费力，大家更多的还是专注于业务，但是前期没有一个好的架构师来规划项目架构，以及开发人员的认知能力和业务迭代的紧迫性，导致项目还是有很多问题：
 技术债：虽然很多代码是新写的，但是业务速度和人员水平，还是存在很多技术债 直接搬用了母公司的技术栈，虽然少了很多维护成本，但是技术选型没有选用最新最成熟的解决方案，生产力还是有点欠缺  企业文化 可能由于之前两家公司的关系，对于企业文化来说没什么感觉，就像大学的校训，只是在某些场合有仪式感的说出来，但是在创业公司，企业文化是对产品是有指导作用的，在某些时候，想不出该做什么，老板就要求从企业文化中去创新，一个公司的一些文化还是深深的影响着一些人，他就像人的价值观和人生观一样，应该是牢牢铭记在心中的，这也就是创业公司的迷人之处吧，因为参与程度高，所以会将自己的价值观注入到公司的文化中。
生活 找到了对的人 啥也不说了，找到了对的人，是今年最大的收获
养了只狗 名字叫格林，一只拆家的柯基
技术成长  更多的去思考如何去学习
 我觉得大部分程序员有三个阶段：
 普通程序员 工程师 架构师  普通程序员 普通程序员是占有了80%的人，只关注于实现功能
工程师 去思考程序的可读性，可维护性和健壮性，思考如何高效
架构师 去挑战不可能的事情，尝试设计更高级的技术，更灵活的系统
2018年的好书  心理学 整洁架构 极客时间的部分专栏 DDIA 函数式编程思维 修改代码的艺术 有效的单元测试 如何阅读一本书  </description>
            <content type="html"><![CDATA[<p><img src="http://image.wufazhuce.com/FkfPZxbajsvcUM7qDmr-sq_yrrH5" alt="2018"></p>
<p>2019年很多人都开始写自己的2018年的总结，虽然已经13号了，但是还是要总结下自己的2018，回头一想，一年过得还真快，2018年加入了创业公司，一年竟也过去了，在这一年里面，也没有做出什么成绩，但是还是有点收获，也总结分享一下。</p>
<h2 id="heading">工作</h2>
<blockquote>
<p>2018年由于一些特殊原因，部门成立了子公司，从零开始，也算是自己第一次加入创业公司</p>
</blockquote>
<p>虽然是换了一家公司，但是身边的小伙伴还是那些，所以并没感到有多大的变化，前几个月该怎么做就怎么做，之后渐渐感到了业务上的压力，创业维艰，伴随着的就是加班多了，迭代快了，要参与到业务中去思考产品的方向了，对于自己来说，自己的职责变了一点，感觉从大公司的螺丝钉找到了一些归属感。这一年，有的老同事离职了，也有新同事进来，自己也开始带人了，虽然不多，但也是要去改变一些工作方式了。</p>
<h3 id="heading1">产品迭代</h3>
<p>那些日子，每次上线一个版本之后，大家都去喝酒撸串，尽兴的玩。开发之前骂着产品这么多需求，但是产品上线的时候还是开心的。在公司总结上，<code>我还是觉得团队的战斗力没有比一年前变得更强，只是有部分人的能力变强了</code>，</p>
<h3 id="heading2">研发</h3>
<p>得益于之前公司的基础建设，还是有一些基础储备，项目在RPC，ZK，Cache，监控，构建部署，MQ，DB维护上还是没怎么费力，大家更多的还是专注于业务，但是前期没有一个好的架构师来规划项目架构，以及开发人员的认知能力和业务迭代的紧迫性，导致项目还是有很多问题：</p>
<ul>
<li>技术债：虽然很多代码是新写的，但是业务速度和人员水平，还是存在很多技术债</li>
<li>直接搬用了母公司的技术栈，虽然少了很多维护成本，但是技术选型没有选用最新最成熟的解决方案，生产力还是有点欠缺</li>
</ul>
<h3 id="heading3">企业文化</h3>
<p>可能由于之前两家公司的关系，对于企业文化来说没什么感觉，就像大学的校训，只是在某些场合有仪式感的说出来，但是在创业公司，<code>企业文化是对产品是有指导作用的</code>，在某些时候，想不出该做什么，老板就要求从企业文化中去创新，一个公司的一些文化还是深深的影响着一些人，他就像人的价值观和人生观一样，应该是牢牢铭记在心中的，这也就是创业公司的迷人之处吧，因为参与程度高，所以会将自己的价值观注入到公司的文化中。</p>
<h2 id="heading4">生活</h2>
<h3 id="heading5">找到了对的人</h3>
<p>啥也不说了，找到了对的人，是今年最大的收获</p>
<h3 id="heading6">养了只狗</h3>
<p>名字叫格林，一只拆家的柯基</p>
<h2 id="heading7">技术成长</h2>
<blockquote>
<p>更多的去思考如何去学习</p>
</blockquote>
<p>我觉得大部分程序员有三个阶段：</p>
<ul>
<li>普通程序员</li>
<li>工程师</li>
<li>架构师</li>
</ul>
<h3 id="heading8">普通程序员</h3>
<p>普通程序员是占有了80%的人，只关注于实现功能</p>
<h3 id="heading9">工程师</h3>
<p>去思考程序的可读性，可维护性和健壮性，思考如何高效</p>
<h3 id="heading10">架构师</h3>
<p>去挑战不可能的事情，尝试设计更高级的技术，更灵活的系统</p>
<h3 id="2018">2018年的好书</h3>
<ul>
<li>心理学</li>
<li>整洁架构</li>
<li>极客时间的部分专栏</li>
<li>DDIA</li>
<li>函数式编程思维</li>
<li>修改代码的艺术</li>
<li>有效的单元测试</li>
<li>如何阅读一本书</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>那些书本中没告诉你的MyBatis</title>
            <link>https://blog.sailfishc.cn/posts/2019/01/%E9%82%A3%E4%BA%9B%E4%B9%A6%E6%9C%AC%E4%B8%AD%E6%B2%A1%E5%91%8A%E8%AF%89%E4%BD%A0%E7%9A%84mybatis/</link>
            <pubDate>Mon, 07 Jan 2019 21:37:00 +0000</pubDate>
            
            <guid>https://blog.sailfishc.cn/posts/2019/01/%E9%82%A3%E4%BA%9B%E4%B9%A6%E6%9C%AC%E4%B8%AD%E6%B2%A1%E5%91%8A%E8%AF%89%E4%BD%A0%E7%9A%84mybatis/</guid>
            <description>不管是《MyBatis从入门到精通》，还是21天精通MyBatis，都告诉了你怎么做？但是没告诉你为什么以及是什么。
 本篇将会讲解MyBatis（Spring-MyBatis）的一些关键类，以及关于DB操作的内容
 关键类  SqlSessionFactory SqlSessionFactoryBean SqlSession MapperFactoryBean SqlSessionDaoSupport SqlSessionTemplate MapperScannerConfigurer  如何访问数据库 mysql -uadmin -pxxx -h58.87.87.129 -P32007
当我们需要连接MySQL时，需要用到几个属性：
 用户名 密码 地址 端口  这在MySQL中叫一次会话（session），在JDBC中JDBC定义了规范，其实现类具体去操作，在MyBatis中，MyBatis的关键类SqlSession定义了如何去操作数据库，例如：
 selectOne selectAll selectList insert …..  具体的实现类有：
 DefaultSqlSession SqlSessionTemplate SqlSessionManager  当然我们都不会直接使用这几个实现类，我们一般是这样的：
public class UserService { @Resource private UserMapper userMapper; } 那这其中究竟是怎么做到这样简化的呢？
实现细节 SqlSessionFactoryBean&amp;amp;SqlSessionFactory 上面介绍了关键类SqlSession, 那如何创建SqlSession呢？MyBatis使用了工厂方法来创建SqlSession，由于工厂和SqlSession是一对多的关系，也就是说一个Factory可以创建多个SqlSession，MyBatis-Spring将SqlSessionFactory放入了容器的生命周期中，也就出现了SqlSessionFactoryBean，我们一般这样配置：
&amp;lt;bean id=&amp;quot;sqlSessionFactory&amp;quot; class=&amp;quot;org.mybatis.spring.SqlSessionFactoryBean&amp;quot;&amp;gt; &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot; /&amp;gt; &amp;lt;/bean&amp;gt;  DataSource（必须配置）： SqlSessionFactory 需要一个（也可以是多个） DataSource  MapperFactoryBean 大家都知道MyBatis是基于Mapper的，一般情况MyBatis的一个Mapper就对应一张DB的Table，就有了</description>
            <content type="html"><![CDATA[<p>不管是《MyBatis从入门到精通》，还是21天精通MyBatis，都告诉了你怎么做？但是没告诉你为什么以及是什么。</p>
<blockquote>
<p>本篇将会讲解MyBatis（Spring-MyBatis）的一些关键类，以及关于DB操作的内容</p>
</blockquote>
<h2 id="heading">关键类</h2>
<ul>
<li>SqlSessionFactory</li>
<li>SqlSessionFactoryBean</li>
<li>SqlSession</li>
<li>MapperFactoryBean</li>
<li>SqlSessionDaoSupport</li>
<li>SqlSessionTemplate</li>
<li>MapperScannerConfigurer</li>
</ul>
<h2 id="heading1">如何访问数据库</h2>
<p><code>mysql -uadmin -pxxx -h58.87.87.129 -P32007</code></p>
<p>当我们需要连接MySQL时，需要用到几个属性：</p>
<ul>
<li>用户名</li>
<li>密码</li>
<li>地址</li>
<li>端口</li>
</ul>
<p>这在MySQL中叫一次会话（session），在JDBC中JDBC定义了规范，其实现类具体去操作，在MyBatis中，MyBatis的关键类<code>SqlSession</code>定义了如何去操作数据库，例如：</p>
<ul>
<li>selectOne</li>
<li>selectAll</li>
<li>selectList</li>
<li>insert</li>
<li>…..</li>
</ul>
<p>具体的实现类有：</p>
<ul>
<li>DefaultSqlSession</li>
<li>SqlSessionTemplate</li>
<li>SqlSessionManager</li>
</ul>
<p>当然我们都不会直接使用这几个实现类，我们一般是这样的：</p>
<pre><code>public class UserService {
	
	@Resource
	private UserMapper userMapper;
}
</code></pre><p>那这其中究竟是怎么做到这样简化的呢？</p>
<h2 id="heading2">实现细节</h2>
<h3 id="sqlsessionfactorybeansqlsessionfactory">SqlSessionFactoryBean&amp;SqlSessionFactory</h3>
<p>上面介绍了关键类<code>SqlSession</code>, 那如何创建<code>SqlSession</code>呢？MyBatis使用了工厂方法来创建<code>SqlSession</code>，由于工厂和SqlSession是一对多的关系，也就是说一个Factory可以创建多个SqlSession，MyBatis-Spring将SqlSessionFactory放入了容器的生命周期中，也就出现了SqlSessionFactoryBean，我们一般这样配置：</p>
<pre><code>&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
</code></pre><ul>
<li>DataSource（必须配置）： SqlSessionFactory 需要一个（也可以是多个） DataSource</li>
</ul>
<h3 id="mapperfactorybean">MapperFactoryBean</h3>
<p>大家都知道MyBatis是基于Mapper的，一般情况MyBatis的一个Mapper就对应一张DB的Table，就有了</p>
<ul>
<li>UserMapper</li>
<li>PersonMapper</li>
<li>AddressMapper</li>
<li>…..</li>
</ul>
<p>那MapperFactoryBean是干什么用的呢？</p>
<ul>
<li>告诉容器（可以是Spring容器）：我的这个Mapper可以访问这个数据，所以MapperFactoryBean需要配置<code>Mapper</code>和<code>SqlSessionFactory</code></li>
</ul>
<pre><code>&lt;bean id=&quot;userMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;
  &lt;property name=&quot;mapperInterface&quot; value=&quot;org.mybatis.spring.sample.mapper.UserMapper&quot; /&gt;
  &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;
&lt;/bean&gt;
</code></pre><blockquote>
<p>到目前为止，我们没有定义mapper.xml文件，但是我们可以这样用了</p>
</blockquote>
<pre><code>public interface UserMapper {
  @Select(&quot;SELECT * FROM users WHERE id = #{userId}&quot;)
  User getUser(@Param(&quot;userId&quot;) String userId);
} 
</code></pre><p>AND</p>
<pre><code>public class FooServiceImpl implements FooService {

private UserMapper userMapper;

public void setUserMapper(UserMapper userMapper) {
  this.userMapper = userMapper;
}

public User doSomeBusinessStuff(String userId) {
  return this.userMapper.getUser(userId);
}
}
</code></pre><p>但是只用注解的话面对繁杂的SQL，会显得代码凌乱，就出现了使用xml来描述SQL（当然其他的ORM甚至可以使Markdown），MyBatis要知道SQL文件在哪里有两种方式：</p>
<ul>
<li>和mapper接口在同一个包路径下</li>
<li>mapperLocations：将目录地址设置到mapperLocations中</li>
</ul>
<pre><code>&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
  &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:sample/config/mappers/**/*.xml&quot; /&gt;
&lt;/bean&gt;
</code></pre><h3 id="mapperscannerconfigurer">MapperScannerConfigurer</h3>
<p>在上面的方法中，我们需要把Mapper当做Service的Bean中的属性设置进去，这样显得太麻烦了，就有了<code>MapperScannerConfigurer</code></p>
<pre><code>&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
  &lt;property name=&quot;basePackage&quot; value=&quot;org.mybatis.spring.sample.mapper&quot; /&gt;
&lt;/bean&gt;
</code></pre><ul>
<li>basePackage 属性是让你为映射器接口文件设置基本的包路径</li>
<li>MapperScannerConfigurer , 它 将 会 查 找 类 路 径 下 的 映 射 器 并 自 动 将 它 们 创 建 成 MapperFactoryBean</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>致生活</title>
            <link>https://blog.sailfishc.cn/posts/2018/09/%E8%87%B4%E7%94%9F%E6%B4%BB/</link>
            <pubDate>Sun, 02 Sep 2018 11:37:00 +0000</pubDate>
            
            <guid>https://blog.sailfishc.cn/posts/2018/09/%E8%87%B4%E7%94%9F%E6%B4%BB/</guid>
            <description> 少年真正成人的那一刻，大概就是，对于你的家人，你会时不时惦记，想念，渴望从他们那里得到抚慰，害怕他们哪天离开人世——他们成为你梦境的常客，内心最柔软的部分；你却无比清楚：纵然爱他们，却再无法同他们心无芥蒂地谈论，或长久地生活在一起。 — 一个
 今天送妈妈去火车站回家了，过来的时间不长不短，来去10天，期间工作比较忙，只有周末有时间出去逛，没去几个地方，只去了故宫、颐和园、森林公园、鸟巢、前门、天安门，这是过年回家之后第一次见我妈，来北京以后基本每年就回一趟家，这次我妈在我的坚持下过来，我就规划着带她吃点好的，买几件衣服，带她逛逛。
去车站接她的时候，她穿着一件橘色的衣服，在人群中显得很突兀，在家的时候还没怎么注意，来北京了，突然发现妈妈已经老了，白头发多了些，她在人群中提着一个箱子，面对人群，有一点慌乱，我想着她做了一天火车了，回来休息一下，第二天再出去，她坚持说自己不累，下午就去周边的森林公园逛了逛，晚上在外面吃了点鱼，吃完就说太贵了。
周六和周天带着她逛，我给她教着怎么会使用地图，怎么使用微信支付，怎么坐地铁，之后我说目的地，妈妈打开地图，给我说路线，我跟着她走，想着上班的时候能自己出去走走，其实她来北京最重要的是陪陪我，不在乎去哪，我上班的那几天，等着我回家，加班很晚，回来已经11点多了，妈妈会倒点牛奶或做点汤给我，其实最温暖的，是回家的时候灯是亮着的，屋里有牵挂着你的人。
昨天我问她感觉北京怎么样，她说就是东西贵，赚得多花的也多，你一个人很孤单。
可能是家庭本身的因素，我妈从小就比较严厉，有些感情也不好表达，现在越大了和爸妈也聊得不多了，每次就是问问身体怎么样啊，家里怎么样啊，家里缺啥吗？这次来给妈妈拍照，妈妈就会看看给她拍的怎么样啊，有时候就说笑起来拍出照片不好看，不笑拍出来也不好看-.-
时间过得很快，今天送她回家了，心情有点低落，觉得有点对不起他们，不在他们身边，现在自己赚钱，但是还是给不了他们好的生活，只希望他们身体健康，争取明年带爸妈出去玩。
 自己好久不写这种非技术文章了，今天特别想写，写的有点乱，每个在外边工作的人，可能心里都有一团火。
 </description>
            <content type="html"><![CDATA[<p><img src="http://p783z0zp1.bkt.clouddn.com/img/20180902122035.png" alt="Mother"></p>
<blockquote>
<p>少年真正成人的那一刻，大概就是，对于你的家人，你会时不时惦记，想念，渴望从他们那里得到抚慰，害怕他们哪天离开人世——他们成为你梦境的常客，内心最柔软的部分；你却无比清楚：纵然爱他们，却再无法同他们心无芥蒂地谈论，或长久地生活在一起。
— 一个</p>
</blockquote>
<p>今天送妈妈去火车站回家了，过来的时间不长不短，来去10天，期间工作比较忙，只有周末有时间出去逛，没去几个地方，只去了故宫、颐和园、森林公园、鸟巢、前门、天安门，这是过年回家之后第一次见我妈，来北京以后基本每年就回一趟家，这次我妈在我的坚持下过来，我就规划着带她吃点好的，买几件衣服，带她逛逛。</p>
<p>去车站接她的时候，她穿着一件橘色的衣服，在人群中显得很突兀，在家的时候还没怎么注意，来北京了，突然发现妈妈已经老了，白头发多了些，她在人群中提着一个箱子，面对人群，有一点慌乱，我想着她做了一天火车了，回来休息一下，第二天再出去，她坚持说自己不累，下午就去周边的森林公园逛了逛，晚上在外面吃了点鱼，吃完就说太贵了。</p>
<p>周六和周天带着她逛，我给她教着怎么会使用地图，怎么使用微信支付，怎么坐地铁，之后我说目的地，妈妈打开地图，给我说路线，我跟着她走，想着上班的时候能自己出去走走，其实她来北京最重要的是陪陪我，不在乎去哪，我上班的那几天，等着我回家，加班很晚，回来已经11点多了，妈妈会倒点牛奶或做点汤给我，其实最温暖的，是回家的时候灯是亮着的，屋里有牵挂着你的人。</p>
<p>昨天我问她感觉北京怎么样，她说就是东西贵，赚得多花的也多，你一个人很孤单。</p>
<p>可能是家庭本身的因素，我妈从小就比较严厉，有些感情也不好表达，现在越大了和爸妈也聊得不多了，每次就是问问身体怎么样啊，家里怎么样啊，家里缺啥吗？这次来给妈妈拍照，妈妈就会看看给她拍的怎么样啊，有时候就说笑起来拍出照片不好看，不笑拍出来也不好看-.-</p>
<p>时间过得很快，今天送她回家了，心情有点低落，觉得有点对不起他们，不在他们身边，现在自己赚钱，但是还是给不了他们好的生活，只希望他们身体健康，争取明年带爸妈出去玩。</p>
<blockquote>
<p>自己好久不写这种非技术文章了，今天特别想写，写的有点乱，每个在外边工作的人，可能心里都有一团火。</p>
</blockquote>
]]></content>
        </item>
        
        <item>
            <title>设计模式总结</title>
            <link>https://blog.sailfishc.cn/posts/2017/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</link>
            <pubDate>Wed, 24 May 2017 11:37:00 +0000</pubDate>
            
            <guid>https://blog.sailfishc.cn/posts/2017/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</guid>
            <description>一、创建型模式(五种)  工厂方法模式(Factory)：工厂创建对象（经典实现：很多框架初始化时都会创建一个工厂对象，用来加载资源） 抽象工厂模式(Abstractfactory)：抽象工厂实例创建对象，工厂可修改，灵活度高（经典实现：Struts2插件机制的核心实现就是BeanFactory这个抽象工厂。Spring IOC加载Bean，AOP创建Proxy） 单例模式(Sington)：适用于只需要一个对象的情况（经典实现：Tomcat中StringManager的错误处理机制） 建造者模式(Builder)：一步一步创建一个复杂的对象（经典实现：MyBatis中的SQLSession就是结合了Configure，executor等对象，以此来实现SQLSession的复杂功能） 原型模式(Prototype)：复制对象，包括深度复制和浅度复制，深度复制重建引用对象，浅度复制不创建（经典实现：java序列化）  二、结构型模式(七种)  适配器模式(Adapter)：通过实现接口，依赖注入，继承等方式为不相关的实体建立关系（经典实现：Tomcat新版本连接器Coyote，就是通过为Connector适配建立了ProtocolHandler与Tomcat组件Connector的关联关系） 装饰器模式(Decorator)：创建包装对象修饰扩展被包装对象的功能（经典实现：IO家族中BufferedXxx） 代理模式(Proxy)：通过添加中间代理的方式限制，过滤，修改被代理类的某些行为（经典实现：Spring AOP核心实现，DataSource中为Connection创建代理对象，改变close方法的行为，使其从开始的关闭连接变成将连接还回连接池） 外观模式(Facade)：通过外观的包装，使应用程序只能看到外观对象，而不会看到具体的细节对象。（经典实现：Tomcat中创建外观类包装StandardContext传给Wrapper，创建外观类包装Wrapper以ServletConfiguration的形式传给Servlet，以此来屏蔽不想让Servlet可见的那些Tomcat容器参数） 桥接模式(Bridge)：将抽象部分与它的实现部分分离，使它们都可以独立地变化（经典实现：JDBC驱动） 组合模式(Composite)：部分与整体，常用于表示树形结构 享元模式(Flyweight)：维护资源集合（经典实现：数据库连接池，避免重新开启数据库链接的开销）  三、行为型模式(十一种)  策略模式(Strategy)：定义多个不同的实现类，这些类实现公共接口，通过调用接口调用不同实例得到不同结果（经典实现：Spring中Bean的定义与注入，Controller，Servcie，repository三层架构中只依赖上一层接口） 模板方法模式(Template)：父类定义公共方法，不同子类重写父类抽象方法，得到不同结果（经典实现：Tomcat生命周期中的init，SpringIOC上层类加载具体子类指定的配置文件） 观察者模式(Observer)：目标方法被调用，通知所有观察者（经典实现：Tomcat生命周期事件监听，Spring BeanPostProcessor实现 ） 迭代子模式(Interator)：提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。（经典实现：集合迭代器） 责任链模式(ChainOfResponsibility)：链式依赖，依次调用（经典实现：Tomcat Valve） 命令模式(Commond)：Action定义具体命令，拦截器Invocation回调执行命令（经典实现：Struts2） 备忘录模式(Memento)：建立原始对象副本，用于存储恢复原始对象数据 状态模式(Stage)：通过改变状态，改变行为（经典实现：切换装载着不同配置信息的配置文件对象） 访问者模式(Visitor)：结构与操作解耦。灵活的操作，放入固定的结构中执行（经典实现：在SpringAOP的实现过程中首先会有一个ProxyCreator去创建切入点，通知之类的，然后创建一个抽象工厂将这些参数对象传递给抽象工厂，抽象工厂调用createAopProxy(this)来创建对象，传入不同的抽象工厂创建出不同的实体对象） 中介者模式(Mediator)：MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者 解释器模式(Iterpreter)：定义分别定义 + - * / 非终结符，组合不同的非终结符定义不同的表达式，维护繁琐  四、学习资源  调停者模式 解释器模式 访问者模式 状态模式 备忘录模式 命令模式 责任链模式 迭代子模式 观察者模式 模板方法模式 策略模式 不变模式 桥梁模式 门面模式 享元模式 代理模式 装饰模式 合成模式 适配器模式 原型模式 建造模式 单例模式 抽象工厂模式 工厂方法模式 简单工厂模式  五、总结   内容部分引用自http://smallbug-vip.</description>
            <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/734456-32b3fb0c1a41aa71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="heading">一、创建型模式(五种)</h2>
<ul>
<li>工厂方法模式(Factory)：工厂创建对象（经典实现：很多框架初始化时都会创建一个工厂对象，用来加载资源）</li>
<li>抽象工厂模式(Abstractfactory)：抽象工厂实例创建对象，工厂可修改，灵活度高（经典实现：Struts2插件机制的核心实现就是BeanFactory这个抽象工厂。Spring IOC加载Bean，AOP创建Proxy）</li>
<li>单例模式(Sington)：适用于只需要一个对象的情况（经典实现：Tomcat中StringManager的错误处理机制）</li>
<li>建造者模式(Builder)：一步一步创建一个复杂的对象（经典实现：MyBatis中的SQLSession就是结合了Configure，executor等对象，以此来实现SQLSession的复杂功能）</li>
<li>原型模式(Prototype)：复制对象，包括深度复制和浅度复制，深度复制重建引用对象，浅度复制不创建（经典实现：java序列化）</li>
</ul>
<h2 id="heading1">二、结构型模式(七种)</h2>
<ul>
<li>适配器模式(Adapter)：通过实现接口，依赖注入，继承等方式为不相关的实体建立关系（经典实现：Tomcat新版本连接器Coyote，就是通过为Connector适配建立了ProtocolHandler与Tomcat组件Connector的关联关系）</li>
<li>装饰器模式(Decorator)：创建包装对象修饰扩展被包装对象的功能（经典实现：IO家族中BufferedXxx）</li>
<li>代理模式(Proxy)：通过添加中间代理的方式限制，过滤，修改被代理类的某些行为（经典实现：Spring AOP核心实现，DataSource中为Connection创建代理对象，改变close方法的行为，使其从开始的关闭连接变成将连接还回连接池）</li>
<li>外观模式(Facade)：通过外观的包装，使应用程序只能看到外观对象，而不会看到具体的细节对象。（经典实现：Tomcat中创建外观类包装StandardContext传给Wrapper，创建外观类包装Wrapper以ServletConfiguration的形式传给Servlet，以此来屏蔽不想让Servlet可见的那些Tomcat容器参数）</li>
<li>桥接模式(Bridge)：将抽象部分与它的实现部分分离，使它们都可以独立地变化（经典实现：JDBC驱动）</li>
<li>组合模式(Composite)：部分与整体，常用于表示树形结构</li>
<li>享元模式(Flyweight)：维护资源集合（经典实现：数据库连接池，避免重新开启数据库链接的开销）</li>
</ul>
<h2 id="heading2">三、行为型模式(十一种)</h2>
<ul>
<li>策略模式(Strategy)：定义多个不同的实现类，这些类实现公共接口，通过调用接口调用不同实例得到不同结果（经典实现：Spring中Bean的定义与注入，Controller，Servcie，repository三层架构中只依赖上一层接口）</li>
<li>模板方法模式(Template)：父类定义公共方法，不同子类重写父类抽象方法，得到不同结果（经典实现：Tomcat生命周期中的init，SpringIOC上层类加载具体子类指定的配置文件）</li>
<li>观察者模式(Observer)：目标方法被调用，通知所有观察者（经典实现：Tomcat生命周期事件监听，Spring BeanPostProcessor实现 ）</li>
<li>迭代子模式(Interator)：提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。（经典实现：集合迭代器）</li>
<li>责任链模式(ChainOfResponsibility)：链式依赖，依次调用（经典实现：Tomcat Valve）</li>
<li>命令模式(Commond)：Action定义具体命令，拦截器Invocation回调执行命令（经典实现：Struts2）</li>
<li>备忘录模式(Memento)：建立原始对象副本，用于存储恢复原始对象数据</li>
<li>状态模式(Stage)：通过改变状态，改变行为（经典实现：切换装载着不同配置信息的配置文件对象）</li>
<li>访问者模式(Visitor)：结构与操作解耦。灵活的操作，放入固定的结构中执行（经典实现：在SpringAOP的实现过程中首先会有一个ProxyCreator去创建切入点，通知之类的，然后创建一个抽象工厂将这些参数对象传递给抽象工厂，抽象工厂调用createAopProxy(this)来创建对象，传入不同的抽象工厂创建出不同的实体对象）</li>
<li>中介者模式(Mediator)：MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者</li>
<li>解释器模式(Iterpreter)：定义分别定义 + - * / 非终结符，组合不同的非终结符定义不同的表达式，维护繁琐</li>
</ul>
<h2 id="heading3">四、学习资源</h2>
<ul>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/06/20/2554024.html">调停者模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/06/19/2552617.html">解释器模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/06/14/2545381.html">访问者模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/06/08/2538146.html">状态模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/06/06/2534942.html">备忘录模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/06/01/2526972.html">命令模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/05/28/2516865.html">责任链模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/05/22/2511506.html">迭代子模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html">观察者模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/05/14/2495235.html">模板方法模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/05/10/2491891.html">策略模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/05/08/2487757.html">不变模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/05/07/2480938.html">桥梁模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/05/02/2478101.html">门面模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/04/26/2468499.html">享元模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/04/23/2466712.html">代理模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html">装饰模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/04/17/2453861.html">合成模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html">适配器模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/04/11/2439387.html">原型模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/04/07/2433939.html">建造模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/03/31/2425631.html">单例模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/03/28/2418836.html">抽象工厂模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/03/25/2416227.html">工厂方法模式</a></li>
<li><a href="http://www.cnblogs.com/java-my-life/archive/2012/03/22/2412308.html">简单工厂模式</a></li>
</ul>
<h2 id="heading4">五、总结</h2>
<blockquote>
<ul>
<li>内容部分引用自http://smallbug-vip.iteye.com/blog/2276470</li>
</ul>
</blockquote>
<ul>
<li>在学习设计模式的过程中最直观的感觉就是小demo感觉看着很爽，自己也能理解，但是在实际开发中想套用哪种设计模式却感觉有点心有余而力不足的意思，这可能就是设计模式太灵活的缘故，设计模式都是在大量的代码中积累的精髓所在，这篇总结也是给自己一个笔记，让自己在之后的开发中可以回过头来看看。</li>
<li>很多人对设计模式有点误解，认为只有GoF的设计模式才是设计模式，这种观点有点不正确，以下是引用一段解释：
<ul>
<li>设计模式的不同侧重
<ul>
<li>1、 侧重总体架构的设计模式，如MVC(Java web开发)，MVVM(WPF)</li>
<li>2、 侧重细节架构的设计模式，如GoF所描述的23种设计模式</li>
<li>3、 侧重实现的模式，如生产消费队列的同步问题等等</li>
</ul>
</li>
</ul>
</li>
<li>设计模式是对oo原则的实现</li>
<li>再引用一段话：
<ul>
<li>简单的功能或演示性的程序不要考虑设计模式</li>
<li>关注问题而非解决方案。也就是说只有遇到问题时才去设计模式里找方法</li>
<li>关注重用而非设计模式。也就是说设计模式是以重用为目的的，只要能做到重用，是否使用了某种设计模式并不重要</li>
<li>在支持函数式编程的语言里避免使用设计模式。如前所述，设计模式是以重用的目的的，而高阶函数很多情况下是比设计模式更好的重用方法，这些语言包括常见的js, ruby, python等
能用简单的模式解决的问题不要引入复杂的模式</li>
<li>已经有解决方案的情况下不要硬套设计模式，设计模式不是一切</li>
<li>正确认识些暂时无法理解的模式，如Memento, Interpreter, Visitor等，这些模式代表着一类问题，很多时候使用第三方库是更好的选择</li>
<li>看轻设计模式，它们只能解决一小部分问题</li>
</ul>
</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>浅析RPC</title>
            <link>https://blog.sailfishc.cn/posts/2017/04/%E6%B5%85%E6%9E%90rpc/</link>
            <pubDate>Sat, 29 Apr 2017 14:37:00 +0000</pubDate>
            
            <guid>https://blog.sailfishc.cn/posts/2017/04/%E6%B5%85%E6%9E%90rpc/</guid>
            <description>目前很多应用应该都不是one in all模式了，避免不了发生远程调用，和同事聊了下RPC之后，发现大家对RPC的概念还是比较模糊的，虽然一直在用，但是不太明白其含义，在知乎上搜了下RPC HTTP这俩个关键词，发现还是有很多误解的。
  问题一：既然有http 请求，为什么还要用rpc调用？ 问题二：请问rpc协议和http协议的关系和区别？   之后就萌生了写一篇关于RPC的文章。
 一、RPC的基本概念 RPC，即 Remote Procedure Call（远程过程调用），说得通俗一点就是：调用远程计算机上的服务，就像调用本地服务一样。 RPC的实现包含了两部分，一部分是客户端，一部分是服务端，服务的调用方发送RPC请求到服务提供方，服务提供方根据参数执行方法，响应客户端，一次RPC请求结束。 这篇文章解释的不错：通俗的语言解释什么是 RPC 框架
RPC 可基于 HTTP 或 TCP 协议，Web Service 就是基于 HTTP 协议的 RPC，它具有良好的跨平台性，但其性能却不如基于 TCP 协议的 RPC。会两方面会直接影响 RPC 的性能，一是传输方式，二是序列化。
众所周知，TCP 是传输层协议，HTTP 是应用层协议，而传输层较应用层更加底层，在数据传输方面，越底层越快，因此，在一般情况下，TCP 一定比 HTTP 快。就序列化而言，Java 提供了默认的序列化方式，但在高并发的情况下，这种方式将会带来一些性能上的瓶颈，于是市面上出现了一系列优秀的序列化框架，比如：Protobuf、Kryo、Hessian、Jackson 等，它们可以取代 Java 默认的序列化，从而提供更高效的性能。
针对对象序列化，有各种方式的性能对比，Github地址:
通过对比可知：
 Google的Protostuff性能最好 JSON/XML性能比较差  但是JSON/XML方式在互联网领域应用比较广泛，第三方的解析包也比较容易使用，所以在效率要求不是很高的情况下是一种不错的选择。
dubbo作为一种服务治理框架，RPC作为其中的内部通信方式，使用也是非常简单：
@Component public class CityDubboConsumerService { @Reference(version = &amp;quot;1.0.0&amp;quot;) CityDubboService cityDubboService; public void printCity() { String cityName=&amp;quot;xx&amp;quot;; City city = cityDubboService.</description>
            <content type="html"><![CDATA[<blockquote>
<p>目前很多应用应该都不是one in all模式了，避免不了发生远程调用，和同事聊了下RPC之后，发现大家对RPC的概念还是比较模糊的，虽然一直在用，但是不太明白其含义，在知乎上搜了下RPC HTTP这俩个关键词，发现还是有很多误解的。</p>
</blockquote>
<ul>
<li>问题一：既然有http 请求，为什么还要用rpc调用？</li>
<li>问题二：请问rpc协议和http协议的关系和区别？</li>
</ul>
<blockquote>
<p>之后就萌生了写一篇关于RPC的文章。</p>
</blockquote>
<h2 id="rpc">一、RPC的基本概念</h2>
<p>RPC，即 Remote Procedure Call（远程过程调用），说得通俗一点就是：调用远程计算机上的服务，就像调用本地服务一样。
RPC的实现包含了两部分，一部分是客户端，一部分是服务端，服务的调用方发送RPC请求到服务提供方，服务提供方根据参数执行方法，响应客户端，一次RPC请求结束。
这篇文章解释的不错：<a href="https://www.zhihu.com/question/25536695">通俗的语言解释什么是 RPC 框架</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-56600e1178de48f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>RPC 可基于 HTTP 或 TCP 协议，Web Service 就是基于 HTTP 协议的 RPC，它具有良好的跨平台性，但其性能却不如基于 TCP 协议的 RPC。会两方面会直接影响 RPC 的性能，一是传输方式，二是序列化。</p>
<p>众所周知，TCP 是传输层协议，HTTP 是应用层协议，而传输层较应用层更加底层，在数据传输方面，越底层越快，因此，在一般情况下，TCP 一定比 HTTP 快。就序列化而言，Java 提供了默认的序列化方式，但在高并发的情况下，这种方式将会带来一些性能上的瓶颈，于是市面上出现了一系列优秀的序列化框架，比如：Protobuf、Kryo、Hessian、Jackson 等，它们可以取代 Java 默认的序列化，从而提供更高效的性能。</p>
<p>针对对象序列化，有各种方式的性能对比，<a href="https://github.com/eishay/jvm-serializers/wiki">Github地址</a>:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-ff9c09c4b7ae2916.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">
通过对比可知：</p>
<ul>
<li>Google的Protostuff性能最好</li>
<li>JSON/XML性能比较差</li>
</ul>
<p>但是JSON/XML方式在互联网领域应用比较广泛，第三方的解析包也比较容易使用，所以在效率要求不是很高的情况下是一种不错的选择。</p>
<p>dubbo作为一种服务治理框架，RPC作为其中的内部通信方式，使用也是非常简单：</p>
<pre><code>@Component
public class CityDubboConsumerService {

    @Reference(version = &quot;1.0.0&quot;)
    CityDubboService cityDubboService;

    public void printCity() {
        String cityName=&quot;xx&quot;;
        City city = cityDubboService.findCityByName(cityName);
        System.out.println(city.toString());
    }
}
</code></pre><ul>
<li>在不理解RPC概念的情况下，会认为RPC就只有这种应用，其实开发中经常使用的HTTPClient调用也是属于RPC的一种方式。</li>
</ul>
<h2 id="rpc1">二、RPC的使用</h2>
<h3 id="1tcp">1、基于TCP的远程调用</h3>
<ul>
<li>服务消费者</li>
</ul>
<pre><code>public class Consumer {


	public static void main(String[] args) throws UnknownHostException, IOException, SecurityException, NoSuchMethodException, ClassNotFoundException{

		//接口名称
		String interfacename= SayHelloService.class.getName();

		//需要远程执行的方法
		Method method = SayHelloService.class.getMethod(&quot;sayHello&quot;, java.lang.String.class);

		//需要传递到远端的参数
		Object[] arguments = {&quot;hello&quot;};

		Socket socket = new Socket(&quot;127.0.0.1&quot;, 1234);

		//将方法名称和参数传递到远端
		ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());
		output.writeUTF(interfacename); //接口名称
		output.writeUTF(method.getName());  //方法名称
		output.writeObject(method.getParameterTypes());
		output.writeObject(arguments);

		//从远端读取方法执行结果
		ObjectInputStream input = new ObjectInputStream(socket.getInputStream());
		Object result = input.readObject();

		//使用代理对象来处理，直接返回string类型

		System.out.println(result);
	}
}
</code></pre><ul>
<li>服务提供者</li>
</ul>
<pre><code>public class Provider {

	//所有的服务
	private static Map&lt;String,Object&gt; services = new HashMap&lt;String,Object&gt;();

	static{
		services.put(SayHelloService.class.getName(), new SayHelloServiceImpl());
	}

	public static void main(String[] args) throws IOException, ClassNotFoundException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException{

		ServerSocket server = new ServerSocket(1234);
		while(true) {
			Socket socket = server.accept();

			//读取服务信息
			ObjectInputStream input = new ObjectInputStream(socket.getInputStream());
			String interfacename = input.readUTF(); //接口名称
			String methodName = input.readUTF();  //方法名称
			Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[])input.readObject();  //参数类型
			Object[] arguments = (Object[])input.readObject();  //参数对象

			//执行调用
			Class serviceinterfaceclass = Class.forName(interfacename);//得到接口的class
			Object service = services.get(interfacename);//取得服务实现的对象
			Method method = serviceinterfaceclass.getMethod(methodName, parameterTypes);//获得要调用的方法
			Object result = method.invoke(service, arguments);

			ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());
			output.writeObject(result);
		}
	}
}
</code></pre><ul>
<li>接口</li>
</ul>
<pre><code>public interface SayHelloService {

	/**
	 * 问好的接口
	 * @param helloArg 参数
	 * @return
	 */
	public String sayHello(String helloArg);
}
</code></pre><ul>
<li>实现类</li>
</ul>
<pre><code>public class SayHelloServiceImpl implements SayHelloService {

	@Override
	public String sayHello(String helloArg) {

		if(helloArg.equals(&quot;hello&quot;)){
			return &quot;hello&quot;;
		}else{
			return &quot;bye bye&quot;;
		}

	}

}
</code></pre><h3 id="2http">2、基于HTTP的远程调用</h3>
<ul>
<li>基础服务接口</li>
</ul>
<pre><code>public interface BaseService {

	public Object execute(Map&lt;String,Object&gt; args);
}
</code></pre><ul>
<li>JSON结果集</li>
</ul>
<pre><code>public class JsonResult {

	//结果状态码
	private int resultCode;
	//状态码解释消息
	private String message;
	//结果
	private Object result;

	public int getResultCode() {
		return resultCode;
	}
	public void setResultCode(int resultCode) {
		this.resultCode = resultCode;
	}
	public String getMessage() {
		return message;
	}
	public void setMessage(String message) {
		this.message = message;
	}
	public Object getResult() {
		return result;
	}
	public void setResult(Object result) {
		this.result = result;
	}
}
</code></pre><ul>
<li>JSON帮助类</li>
</ul>
<pre><code>public class JsonUtil {

	private static final ObjectMapper mapper = new ObjectMapper();

	public static Object jsonToObject(String json, Class cls) {

		try{
			//允许json串里面的key value不带双引号
			mapper.configure(org.codehaus.jackson.JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);

			// 允许制定的object中的属性没有json串中某个key
			mapper.configure(org.codehaus.jackson.map.DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);

			return mapper.readValue(json, cls);

		}catch(Exception e){}

		return null;

	}

	public static String getJson(Object object)  {

		try{
			String json = null;

			StringWriter sw = new StringWriter();
			JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);
			mapper.writeValue(gen, object);
			gen.close();
			json = sw.toString();
			return json;

		}catch(Exception e){}

		return null;
	}
}
</code></pre><pre><code>public class SayHelloService implements BaseService{

	public Object execute(Map&lt;String, Object&gt; args) {
		//request.getParameterMap() 取出来为array,此处需要注意
		String[] helloArg = (String[]) args.get(&quot;arg1&quot;);

		if(&quot;hello&quot;.equals(helloArg[0])){
			return &quot;hello&quot;;
		}else{
			return &quot;bye bye&quot;;
		}
	}

}
</code></pre><ul>
<li>服务消费者</li>
</ul>
<pre><code>public class ServiceConsumer extends HttpServlet{

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp)
			throws ServletException, IOException {

		this.doPost(req, resp);
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp)
			throws ServletException, IOException {

		//参数
		String service = &quot;com.http.sayhello&quot;;
		String format = &quot;json&quot;;
		String arg1 = &quot;hello&quot;;


		String url = &quot;http://localhost:8080//testhttprpc/provider.do?&quot;+&quot;service=&quot; + service + &quot;&amp;format=&quot; + format + &quot;&amp;arg1=&quot; + arg1;

		//组装请求
		HttpClient httpClient = new DefaultHttpClient();
		HttpGet httpGet = new HttpGet(url);

		//接收响应
		HttpResponse response = httpClient.execute(httpGet);

		HttpEntity entity = response.getEntity();
		byte[] bytes = EntityUtils.toByteArray(entity);
		String jsonresult = new String(bytes, &quot;utf8&quot;);

		JsonResult result = (JsonResult)JsonUtil.jsonToObject(jsonresult, JsonResult.class);

		resp.getWriter().write(result.getResult().toString());

	}
}
</code></pre><ul>
<li>服务提供者</li>
</ul>
<pre><code>public class ServiceProvider  extends HttpServlet{

	private Map&lt;String,BaseService&gt; serviceMap ;


	@Override
	public void init() throws ServletException {
		//服务map初始化
		serviceMap = new HashMap&lt;String,BaseService&gt;();
		serviceMap.put(&quot;com.http.sayhello&quot;, new SayHelloService());
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp)
			throws ServletException, IOException {

		this.doPost(req, resp);
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp)
			throws ServletException, IOException {

		//基本参数
		String servicename = req.getParameter(&quot;service&quot;);
		String format = req.getParameter(&quot;format&quot;);

		Map parameters =  req.getParameterMap();

		BaseService service = serviceMap.get(servicename);
		Object result = service.execute(parameters);

		//生成json结果集
		JsonResult jsonResult = new JsonResult();
		jsonResult.setResult(result);
		jsonResult.setMessage(&quot;success&quot;);
		jsonResult.setResultCode(200);

		String json = JsonUtil.getJson(jsonResult);
		resp.getWriter().write(json);
	}
}
</code></pre><h3 id="3url">3、URL风格</h3>
<ul>
<li>RPC风格的URL</li>
<li>RESTFUL风格的URL</li>
</ul>
<p><strong>RPC风格的URL</strong>
<code>http://hostname/provider.do?service=com.http.sayhello&amp;format=json&amp;timest amp=2017-04-07-13-22-09&amp;arg1=arg1&amp;arg2=arg2</code></p>
<ul>
<li>hostname表示服务提供方的主机名</li>
<li>service表示远程调用的服务接口名称</li>
<li>format表示返回参数的格式</li>
<li>timestamp表示客户端请求的时间戳</li>
<li>arg1和 arg2表示服务所需要的参数</li>
<li>备注：淘宝开放平台的API以这种形式的URL提供</li>
</ul>
<p><strong>RESTFUL风格的URL</strong></p>
<pre><code>POST http://hostname/people 创建name为zhangsan的people记录
GET http://hostname/people/zhangsan 返回name为zhangsan的people记录
PUT http://hostname/people/zhangsan 提交name为zhangsan的people记录更新 
DELETE http://hostname/people/zhangsan 删除name为zhangsan的people记录
</code></pre><h2 id="heading">三、总结</h2>
<blockquote>
<ul>
<li>本文内容部分摘自《大型分布式网站架构》</li>
</ul>
</blockquote>
]]></content>
        </item>
        
        <item>
            <title>消息队列之RabbitMQ基础</title>
            <link>https://blog.sailfishc.cn/posts/2017/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8Brabbitmq%E5%9F%BA%E7%A1%80/</link>
            <pubDate>Sun, 23 Apr 2017 14:37:00 +0000</pubDate>
            
            <guid>https://blog.sailfishc.cn/posts/2017/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%8Brabbitmq%E5%9F%BA%E7%A1%80/</guid>
            <description>MQ在工作中用途还是比较多的，RabbitMQ又是比较容易上手并且在企业中用的比较多的一种消息服务，本篇文章借鉴于ginobefun的文章和ConanLi的文章，一方面是加深理解，一方面也是补充自己在MQ的不足。
 一、AMQP基础 二、RabbitMQ 基础概念  生产者、消费者 队列 交换器 绑定  生产者、消费者  生产者（producer）创建消息，然后发送到代理服务器（RabbitMQ） 消费者（consumer）连接到代理服务器上，并订阅到队列（queue）上；当消费者接收到消息时，它只得到消息的一部分：有效载荷（标签并没有随有效载荷一同传递） 信道（channel）建立在”真实的”TCP连接内的虚拟连接；不论是发布信息、订阅队列或是接收消息，都是通过信道完成的；不使用TCP连接主要是因为对于操作系统而言建立和销毁TCP会话非常昂贵的开销；在一条TCP连接上创建多少条信道是没有限制的 消息包含两部分：有效载荷（payload）和标签（label）；有效载荷就是你想要传输的数据（可以是任何格式的任何内容）；标签描述了有效载荷，并且RabbitMQ用它来决定谁将获得消息的拷贝（之后举例说明）  队列(queue)  Queue（队列）是RabbitMQ的内部对象，用于存储消息 主体流程：  队列类似一个broker角色，生产者将内容（消息）发送到队列 队列进行存储，消费者将消息消费 消费者确认消费消息（ack）   生产者和消费者都可以通过来创建队列：  channel.queueDeclare(QUEUE_NAME, durable, exclusive, autoDelete, arguments);  durable：队列名称，不指定则随机生成 exclusive：设置为true则为私有队列，只有当前消费者可以订阅； autoDelete：设置为true时最后一个消费者取消订阅将自动移除队列； arguments：参数  交换器&amp;amp;绑定 RabbitMQ的消息不是直接从生产者发送到队列的，而是要经过交换器然后才可以到达队列：
 生成者把消息发布到交换器上； 消息最终到达队列，并被消费者接收； 绑定决定了消息如何从交换器到特定的队列；  四种交换器类型：
 fanout：把所有发送到该Exchange的消息路由到所有与它绑定的Queue中 direct：把消息路由到bindingKey与routingKey完全匹配的Queue中 topic：把消息路由到bindingKey与routingKey模糊匹配的Queue中 headers：headers类型的Exchange不依赖于routingKey与bindingKey的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配  1、fanout  生产者（P）发送到Exchange（X）的所有消息都会路由到图中的两个Queue，并最终被两个消费者（C1与C2）消费。  2、direct  routingKey=”error”发送消息，则会同时路由到Queue1（amqp.gen-S9b…）和Queue2（amqp.gen-Agl…） routingKey=”info”或routingKey=”warning”发送消息，则只会路由到Queue2 以其他routingKey发送消息，则不会路由到这两个Queue中  3、topic  routingKey=”quick.orange.rabbit”发送信息，则会同时路由到Q1与Q2 routingKey=”lazy.orange.fox”发送信息，则只会路由到Q1 routingKey=”lazy.</description>
            <content type="html"><![CDATA[<blockquote>
<p>MQ在工作中用途还是比较多的，RabbitMQ又是比较容易上手并且在企业中用的比较多的一种消息服务，本篇文章借鉴于ginobefun的文章和ConanLi的文章，一方面是加深理解，一方面也是补充自己在MQ的不足。</p>
</blockquote>
<h2 id="amqp">一、AMQP基础</h2>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-845cc2702f14ced5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h2 id="rabbitmq">二、RabbitMQ</h2>
<h3 id="heading">基础概念</h3>
<ul>
<li>生产者、消费者</li>
<li>队列</li>
<li>交换器</li>
<li>绑定</li>
</ul>
<h3 id="heading1">生产者、消费者</h3>
<ul>
<li>生产者（producer）创建消息，然后发送到代理服务器（RabbitMQ）</li>
<li>消费者（consumer）连接到代理服务器上，并订阅到队列（queue）上；当消费者接收到消息时，它只得到消息的一部分：有效载荷（标签并没有随有效载荷一同传递）</li>
<li>信道（channel）建立在”真实的”TCP连接内的虚拟连接；不论是发布信息、订阅队列或是接收消息，都是通过信道完成的；不使用TCP连接主要是因为对于操作系统而言建立和销毁TCP会话非常昂贵的开销；在一条TCP连接上创建多少条信道是没有限制的</li>
<li>消息包含两部分：有效载荷（payload）和标签（label）；有效载荷就是你想要传输的数据（可以是任何格式的任何内容）；标签描述了有效载荷，并且RabbitMQ用它来决定谁将获得消息的拷贝（之后举例说明）</li>
</ul>
<h3 id="queue">队列(queue)</h3>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-f86bac7c48c13760.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>Queue（队列）是RabbitMQ的内部对象，用于存储消息</li>
<li>主体流程：
<ul>
<li>队列类似一个broker角色，生产者将内容（消息）发送到队列</li>
<li>队列进行存储，消费者将消息消费</li>
<li>消费者确认消费消息（ack）</li>
</ul>
</li>
<li>生产者和消费者都可以通过来创建队列：</li>
</ul>
<pre><code>channel.queueDeclare(QUEUE_NAME, durable, exclusive, autoDelete, arguments);
</code></pre><ul>
<li>durable：队列名称，不指定则随机生成</li>
<li>exclusive：设置为true则为私有队列，只有当前消费者可以订阅；</li>
<li>autoDelete：设置为true时最后一个消费者取消订阅将自动移除队列；</li>
<li>arguments：参数</li>
</ul>
<h3 id="heading2">交换器&amp;绑定</h3>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-21d9bdcc89b8e154.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>RabbitMQ的消息不是直接从生产者发送到队列的，而是要经过交换器然后才可以到达队列：</p>
<ul>
<li>生成者把消息发布到交换器上；</li>
<li>消息最终到达队列，并被消费者接收；</li>
<li>绑定决定了消息如何从交换器到特定的队列；</li>
</ul>
<p>四种交换器类型：</p>
<ul>
<li>fanout：把所有发送到该Exchange的消息路由到所有与它绑定的Queue中</li>
<li>direct：把消息路由到bindingKey与routingKey完全匹配的Queue中</li>
<li>topic：把消息路由到bindingKey与routingKey模糊匹配的Queue中</li>
<li>headers：headers类型的Exchange不依赖于routingKey与bindingKey的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配</li>
</ul>
<h3 id="1fanout">1、fanout</h3>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-258010ad115af8ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>生产者（P）发送到Exchange（X）的所有消息都会路由到图中的两个Queue，并最终被两个消费者（C1与C2）消费。</li>
</ul>
<h3 id="2direct">2、direct</h3>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-9e5a006e5b703846.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>routingKey=”error”发送消息，则会同时路由到Queue1（amqp.gen-S9b…）和Queue2（amqp.gen-Agl…）</li>
<li>routingKey=”info”或routingKey=”warning”发送消息，则只会路由到Queue2</li>
<li>以其他routingKey发送消息，则不会路由到这两个Queue中</li>
</ul>
<h3 id="3topic">3、topic</h3>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-5a35611ee3132828.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>routingKey=”quick.orange.rabbit”发送信息，则会同时路由到Q1与Q2</li>
<li>routingKey=”lazy.orange.fox”发送信息，则只会路由到Q1</li>
<li>routingKey=”lazy.brown.fox”发送消息，则只会路由到Q2</li>
<li>routingKey=”lazy.pink.rabbit”发送消息，则只会路由到Q2（只会投递给Q2一次，虽然这个routingKey与Q2的两个bindingKey都匹配）</li>
<li>routingKey=”quick.brown.fox”、routingKey=”orange”、routingKey=”quick.orange.male.rabbit”发送消息，则会被丢弃，它们并没有匹配任何bindingKey</li>
</ul>
<h3 id="4header">4、header</h3>
<p>headers类型的Exchange不依赖于routingKey与bindingKey的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。</p>
<h2 id="springbootrabbitmq">三、SpringBoot+RabbitMQ实战</h2>
<p>** Docker环境下安装RabbitMQ**</p>
<pre><code># 下载rabbitmq的docker镜像和managerment的镜像
docker pull rabbitmq:management
# 启动rabbitmq镜像
docker run -d --name rabbitmq --publish 5671:5671 \
 --publish 5672:5672 --publish 4369:4369 --publish 25672:25672 --publish 15671:15671 --publish 15672:15672 \
rabbitmq:management
</code></pre><ul>
<li>
<p>端口解释：</p>
<ul>
<li>4369:epmd(Erlang Port Mapper Daemon)</li>
<li>25672:Erlang distribution</li>
<li>5672, 5671:AMQP 0-9-1 without and with TLS</li>
<li>15672:if management plugin is enabled</li>
<li>61613, 61614:if STOMP is enabled</li>
<li>1883, 8883:if MQTT is enabled</li>
</ul>
</li>
<li>
<p>默认访问路径：<code>http://localhost:15672</code></p>
</li>
<li>
<p>默认用户名和密码：<code>guest/guest</code></p>
</li>
</ul>
<blockquote>
<p>介于代码粘贴进来比较多，提供项目<a href="https://github.com/Sailfishc/learn-rabbitmq">GitHub</a>地址，本文提取代码片段进行讲解</p>
</blockquote>
<h3 id="heading3">项目结构</h3>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-8a6f1499f3aa21ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h3 id="heading4">关键参数</h3>
<ul>
<li>@RabbitListener(queues = &ldquo;xxx&rdquo;)</li>
<li>RabbitTemplate</li>
<li>TopicExchange</li>
<li>Binding</li>
<li>Queue</li>
</ul>
<h3 id="heading5">代码段讲解</h3>
<ul>
<li>创建队列</li>
</ul>
<pre><code>  @Bean
    public Queue ssdQueue(){
        return new Queue(&quot;hello&quot;);
    }
</code></pre><ul>
<li>创建topic类型交换器</li>
</ul>
<pre><code>@Bean
    public TopicExchange topicExchange() {
        return new TopicExchange(&quot;topicExchange&quot;);
    }
</code></pre><ul>
<li>创建fanout类型的交换器</li>
</ul>
<pre><code>@Bean
    public FanoutExchange fanoutExchange() {
        return new FanoutExchange(&quot;fanoutExchange&quot;);
    }
</code></pre><ul>
<li>绑定topic类型的交换器</li>
</ul>
<pre><code>@Bean
    public Binding bindingExchangeTopicA(Queue topicAQueue, TopicExchange topicExchange) {
        return BindingBuilder.bind(topicAQueue).to(topicExchange).with(&quot;topic.a&quot;);
    }
</code></pre><ul>
<li>绑定fanout类型的交换器</li>
</ul>
<pre><code>@Bean
    public Binding bindingExchangeFanoutC(Queue fanoutCQueue, FanoutExchange fanoutExchange) {
        return BindingBuilder.bind(fanoutCQueue).to(fanoutExchange);
    }
</code></pre><h2 id="heading6">四、总结</h2>
<p>本片文章主要讲解了以下RabbitMQ的一些基础概念和使用SpringBoot和RabbitMQ整合的几个案例，也是笔者结合博客和官网写的一片总结，总结的也比较基础，没有包括一些高级的内容，例如事务，最终一致性，重复消息和顺序消息的处理等等。</p>
]]></content>
        </item>
        
        <item>
            <title>38年（转载）</title>
            <link>https://blog.sailfishc.cn/posts/2017/04/38%E5%B9%B4%E8%BD%AC%E8%BD%BD/</link>
            <pubDate>Fri, 07 Apr 2017 14:37:00 +0000</pubDate>
            
            <guid>https://blog.sailfishc.cn/posts/2017/04/38%E5%B9%B4%E8%BD%AC%E8%BD%BD/</guid>
            <description>1979年4月7日的夜里3点，一个卑微的生命诞生了，这个小生命就是我。和当时大多数家庭一样，生活一直非常艰苦。从小开始穿哥哥留下的衣服，终于有一天，我希望买一件新羽绒服，父母推辞了很多次，闹了很多次，终于有一次妈妈下班回家，我堵住大门，不买羽绒服不让进门，但这一次终于迎来了一件新羽绒服，然而这一次仿佛是人生重大的洗礼，我一下子就长大了，从此再也没有闹过什么新衣服，默默穿起来哥哥的旧衣服，背起了旧书包，人生迎来了新的境界，一定要靠自己努力，一定一定要靠自己努力。当时我把所有的玩具赠送给了一个好友，他很奇怪，为什么这些之前珍重的宝贝都不要了，我说我想多看点书，多明白一些道理。
当时家里很小很小，哥哥回到家要学英语，需要一个安静的环境，关起了门，我也无处去，就到处玩，很晚才回家。加上天资平庸，学习成绩并不突出，但也不坏。考大学的时候，亲戚都劝我父母，供两个孩子上大学太辛苦了，不如让我当兵算了，能考上专科的话就读个专科，我就是这样一个不被看好的丑小鸭。
那时我也没什么梦想，也做好了当兵的打算，并填补了材料进行了体检。不想分数还够读专科。直到上了大学，我在内心深处还一直瞧不起自己，什么都不如别人，什么都不敢争取，有喜欢的姑娘，连说话的勇气都没有，也没穿过什么漂亮衣服，长相又傻，可以说自己就把自己当烂仔了。
我读的这个学校，淮海工学院，是一个僻静的远在郊区的学校，一个仿佛与世隔绝的地方，除了读书以外，没有什么不花钱的娱乐。那个时候我认识了一个女孩，非常努力的学习，每天晚上无论我多晚下晚自习，总能看到她。有一次我和同学决定守到一次她下晚自习，并且看看她是不是通宵学习的。我们准备了食品和水，终于守到11点半，这个女孩收拾书包走了，宿舍是10点半熄灯，11点锁大门，我们已经回不去了，只好在自习室憋了一夜，后来才知道这个女孩和宿舍管理员疏通了，可以随时回去。。
有一次她离开的时候，我看了她的笔记和做得习题，我简直难以置信这个世界上会有这样一种学习的方法，于是我就开始跟随她的学习脚步，后来大学时光基本都是看着她的背影过来的，有一次她主动向我问好，我们就认识了，但交流也不多，他有个很不错的男友，经常看到他们幸福的样子。
毕业的时候这个女孩毫无悬念地考研上了南京航空航天大学。我准备2年后符合专科考试资格后也考研，然后就是4年，失败了4次后，选择调剂到南京大学软件学院，从97年开始考试大学，准备考研，历经7年不懈努力，日夜奋斗，迎来了人生第一次胜利。
我想经历过考研的人会理解，备考的过程是非常惨烈的，每个知识点的整理，反复练习不亚于高考，而且是在完全无人监督的情况下，靠着内在的巨大动力完成的考试过程，特别是对我这么个天赋很差的人来说，就更加艰难。
研究生毕业那年是2007年，我在硕士这个圈子算大龄了，找工作很困难，加上之前专科背景，非常非常难，当时几个宿舍一起投西门子，所有人都获得笔试机会，唯独我被排除了，无论多么艰难，我都没有隐瞒过简历，宁可被淘汰，后来在南京投遍所有单位，无一录用，经一个北京朋友介绍，来到北京闯世界，在搜狗打工，然后就是3年。搜狗是我职业生涯的高峰，我的很多技能都是在搜狗学会的，这是一个顽强战斗的团队。
2010年，我又开始人生新的征途，进入了清华大学攻读博士学位，在所有脱产博士中，找不到比我年龄再大的了，我甚至比一个老师年龄还大。克服了很多困难，很多人的嘲笑，走到了博士毕业这一天。这些嘲笑包括没有发表重要论文，一清博士等等。在毕业典礼的时候，我对自己说，虽然我这个博士学位没有公开认可的含金量的东西，但是我做了很多非常有价值的东西，只是没有转化成论文，是的，只是没有转化成论文，我对自己的研究工作是满意的。pullword分词，词库，thuirdb至今还在为公司和很多人创造价值，我想这个世界上也只有我自己能认可自己并不是一个很水很水的博士了。
毕业季，找工作又非常难，那时我已经是36岁的老同志了，即便找到工作也没有北京户口，最大的offer只有50万年薪，也没有更好的选择，和一个同年毕业的博士一起创业，然后又是艰苦奋斗2年至今，公司也没倒闭，发展得不快，但也活着，那天合伙人对我说，我现在真的很热爱自己的工作，我听后很想流泪，我说，其实我也很热爱自己的工作，我们有更伟大的梦想，一起努力吧。
97年读了大学好，我就几乎没什么娱乐了，很多同龄人玩的东西，我都没玩过，看过的电影电视我都没看过，从小至今都不被看好，各种嘲笑，蔑视。前不久我看了微博的黑名单很是感慨，我大概几年前就不再拉黑任何人，也不删除任何网友的侮辱和嘲讽的语言了，来到38岁的我少了很多意气，看淡了很多很多，也不争什么名，能把家庭管理好，把公司管理好，照顾好厂里几名职工的生活，把客户服务好，让客户放心，人生就阔以了。
但是有一点我想是非常非常重要，也是我写这篇文章的核心用意，任何时候都要坚持努力，坚持自己，相信自己，不要责备没有好的家庭环境，也不要责备自己天赋很差，就在能力范围内，做好自己，一切美好的事情都将自然到来，人只有一个人生，无论我们如何书写，如何定义，都只有一个人生，所以能努力一点就努力一点，谢谢。</description>
            <content type="html"><![CDATA[<p>1979年4月7日的夜里3点，一个卑微的生命诞生了，这个小生命就是我。和当时大多数家庭一样，生活一直非常艰苦。从小开始穿哥哥留下的衣服，终于有一天，我希望买一件新羽绒服，父母推辞了很多次，闹了很多次，终于有一次妈妈下班回家，我堵住大门，不买羽绒服不让进门，但这一次终于迎来了一件新羽绒服，然而这一次仿佛是人生重大的洗礼，我一下子就长大了，从此再也没有闹过什么新衣服，默默穿起来哥哥的旧衣服，背起了旧书包，人生迎来了新的境界，一定要靠自己努力，一定一定要靠自己努力。当时我把所有的玩具赠送给了一个好友，他很奇怪，为什么这些之前珍重的宝贝都不要了，我说我想多看点书，多明白一些道理。</p>
<p>当时家里很小很小，哥哥回到家要学英语，需要一个安静的环境，关起了门，我也无处去，就到处玩，很晚才回家。加上天资平庸，学习成绩并不突出，但也不坏。考大学的时候，亲戚都劝我父母，供两个孩子上大学太辛苦了，不如让我当兵算了，能考上专科的话就读个专科，我就是这样一个不被看好的丑小鸭。</p>
<p>那时我也没什么梦想，也做好了当兵的打算，并填补了材料进行了体检。不想分数还够读专科。直到上了大学，我在内心深处还一直瞧不起自己，什么都不如别人，什么都不敢争取，有喜欢的姑娘，连说话的勇气都没有，也没穿过什么漂亮衣服，长相又傻，可以说自己就把自己当烂仔了。</p>
<p>我读的这个学校，淮海工学院，是一个僻静的远在郊区的学校，一个仿佛与世隔绝的地方，除了读书以外，没有什么不花钱的娱乐。那个时候我认识了一个女孩，非常努力的学习，每天晚上无论我多晚下晚自习，总能看到她。有一次我和同学决定守到一次她下晚自习，并且看看她是不是通宵学习的。我们准备了食品和水，终于守到11点半，这个女孩收拾书包走了，宿舍是10点半熄灯，11点锁大门，我们已经回不去了，只好在自习室憋了一夜，后来才知道这个女孩和宿舍管理员疏通了，可以随时回去。。</p>
<p>有一次她离开的时候，我看了她的笔记和做得习题，我简直难以置信这个世界上会有这样一种学习的方法，于是我就开始跟随她的学习脚步，后来大学时光基本都是看着她的背影过来的，有一次她主动向我问好，我们就认识了，但交流也不多，他有个很不错的男友，经常看到他们幸福的样子。</p>
<p>毕业的时候这个女孩毫无悬念地考研上了南京航空航天大学。我准备2年后符合专科考试资格后也考研，然后就是4年，失败了4次后，选择调剂到南京大学软件学院，从97年开始考试大学，准备考研，历经7年不懈努力，日夜奋斗，迎来了人生第一次胜利。</p>
<p>我想经历过考研的人会理解，备考的过程是非常惨烈的，每个知识点的整理，反复练习不亚于高考，而且是在完全无人监督的情况下，靠着内在的巨大动力完成的考试过程，特别是对我这么个天赋很差的人来说，就更加艰难。</p>
<p>研究生毕业那年是2007年，我在硕士这个圈子算大龄了，找工作很困难，加上之前专科背景，非常非常难，当时几个宿舍一起投西门子，所有人都获得笔试机会，唯独我被排除了，无论多么艰难，我都没有隐瞒过简历，宁可被淘汰，后来在南京投遍所有单位，无一录用，经一个北京朋友介绍，来到北京闯世界，在搜狗打工，然后就是3年。搜狗是我职业生涯的高峰，我的很多技能都是在搜狗学会的，这是一个顽强战斗的团队。</p>
<p>2010年，我又开始人生新的征途，进入了清华大学攻读博士学位，在所有脱产博士中，找不到比我年龄再大的了，我甚至比一个老师年龄还大。克服了很多困难，很多人的嘲笑，走到了博士毕业这一天。这些嘲笑包括没有发表重要论文，一清博士等等。在毕业典礼的时候，我对自己说，虽然我这个博士学位没有公开认可的含金量的东西，但是我做了很多非常有价值的东西，只是没有转化成论文，是的，只是没有转化成论文，我对自己的研究工作是满意的。pullword分词，词库，thuirdb至今还在为公司和很多人创造价值，我想这个世界上也只有我自己能认可自己并不是一个很水很水的博士了。</p>
<p>毕业季，找工作又非常难，那时我已经是36岁的老同志了，即便找到工作也没有北京户口，最大的offer只有50万年薪，也没有更好的选择，和一个同年毕业的博士一起创业，然后又是艰苦奋斗2年至今，公司也没倒闭，发展得不快，但也活着，那天合伙人对我说，我现在真的很热爱自己的工作，我听后很想流泪，我说，其实我也很热爱自己的工作，我们有更伟大的梦想，一起努力吧。</p>
<p>97年读了大学好，我就几乎没什么娱乐了，很多同龄人玩的东西，我都没玩过，看过的电影电视我都没看过，从小至今都不被看好，各种嘲笑，蔑视。前不久我看了微博的黑名单很是感慨，我大概几年前就不再拉黑任何人，也不删除任何网友的侮辱和嘲讽的语言了，来到38岁的我少了很多意气，看淡了很多很多，也不争什么名，能把家庭管理好，把公司管理好，照顾好厂里几名职工的生活，把客户服务好，让客户放心，人生就阔以了。</p>
<p>但是有一点我想是非常非常重要，也是我写这篇文章的核心用意，任何时候都要坚持努力，坚持自己，相信自己，不要责备没有好的家庭环境，也不要责备自己天赋很差，就在能力范围内，做好自己，一切美好的事情都将自然到来，人只有一个人生，无论我们如何书写，如何定义，都只有一个人生，所以能努力一点就努力一点，谢谢。</p>
]]></content>
        </item>
        
        <item>
            <title>Elasticsearch学习记录</title>
            <link>https://blog.sailfishc.cn/posts/2017/03/elasticsearch%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</link>
            <pubDate>Fri, 31 Mar 2017 17:58:27 +0000</pubDate>
            
            <guid>https://blog.sailfishc.cn/posts/2017/03/elasticsearch%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</guid>
            <description></description>
            <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/734456-8aeb5bbc2b58286a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-e5889b34c4fc6d90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
]]></content>
        </item>
        
        <item>
            <title>解决Mysql存储Emoji乱码问题</title>
            <link>https://blog.sailfishc.cn/posts/2017/03/%E8%A7%A3%E5%86%B3mysql%E5%AD%98%E5%82%A8emoji%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</link>
            <pubDate>Fri, 31 Mar 2017 17:58:27 +0000</pubDate>
            
            <guid>https://blog.sailfishc.cn/posts/2017/03/%E8%A7%A3%E5%86%B3mysql%E5%AD%98%E5%82%A8emoji%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</guid>
            <description>最近开发的小伙伴们在开发一个社区模块的时候发现目前数据库存储Emoji表情有问题，会出现乱码的情况，之后是这么解决的：UTF-8转为utf8mb4，但是这种操作数据库的方式很不好，然后就找到了这种方式解决。
 在解决之前，得先说明一下为什么会出现乱码，Emoji表情占用4个字节，但是MySQL数据库UTF-8编码最多只能存储3个字节，就会导致存储不进去，在读取的时候读取不完整，导致乱码，那Unicode和UTF-8有什么区别呢？
 字符编码笔记  总的就一句话，UTF-8是Unicode的一种实现。
一、如何解决Emoji存储问题  Github地址解决方案  再来摘抄一遍自己的笔记：mysql 的 utf8编码的一个字符最多3个字节，但是一个emoji表情为4个字节，所以utf8不支持存储emoji表情。但是utf8的超集utf8mb4一个字符最多能有4字节，所以能支持emoji表情的存储。但是修改这个配置太繁琐了，容易出错，emoji-java这个库可以在代码段解决这个问题，解决思路：
 页面有一个表情😁，在经过处理之后可以是😄,将这个字符存入数据库 读取的时候可以将😄这个字符转为😁  例如： 😁 我可以存储为😄，😭存储为😢，等等，可以这样映射起来。
1、引入依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.vdurmont&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;emoji-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.2.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 2、常用API  @RequestMapping(&amp;quot;/add/content&amp;quot;) public ResponseEntity insertContent(@RequestBody Content content) { String title = content.getTitle(); String titles = EmojiParser.parseToAliases(title); content.setTitle(titles); Integer integer = emojiMapper.insertContent(content); if (integer == 1) { return ResponseEntity.ok().build(); } return ResponseEntity.badRequest().build(); } @RequestMapping(&amp;quot;/get/{id}&amp;quot;) public Content getById(@PathVariable(&amp;quot;id&amp;quot;) Integer id) { Content content = emojiMapper.</description>
            <content type="html"><![CDATA[<blockquote>
<p>最近开发的小伙伴们在开发一个社区模块的时候发现目前数据库存储Emoji表情有问题，会出现乱码的情况，之后是这么解决的：UTF-8转为utf8mb4，但是这种操作数据库的方式很不好，然后就找到了这种方式解决。</p>
</blockquote>
<p>在解决之前，得先说明一下为什么会出现乱码，Emoji表情占用4个字节，但是MySQL数据库UTF-8编码最多只能存储3个字节，就会导致存储不进去，在读取的时候读取不完整，导致乱码，那Unicode和UTF-8有什么区别呢？</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">字符编码笔记</a></li>
</ul>
<p>总的就一句话，UTF-8是Unicode的一种实现。</p>
<h2 id="emoji">一、如何解决Emoji存储问题</h2>
<ul>
<li><a href="https://github.com/Sailfishc/emoji-demo">Github地址解决方案</a></li>
</ul>
<p>再来摘抄一遍自己的笔记：mysql 的 utf8编码的一个字符最多3个字节，但是一个emoji表情为4个字节，所以utf8不支持存储emoji表情。但是utf8的超集utf8mb4一个字符最多能有4字节，所以能支持emoji表情的存储。但是修改这个配置太繁琐了，容易出错，emoji-java这个库可以在代码段解决这个问题，解决思路：</p>
<ul>
<li>页面有一个表情😁，在经过处理之后可以是😄,将这个字符存入数据库</li>
<li>读取的时候可以将😄这个字符转为😁</li>
</ul>
<p>例如： 😁 我可以存储为😄，😭存储为😢，等等，可以这样映射起来。</p>
<h3 id="1">1、引入依赖</h3>
<pre><code>&lt;dependency&gt;
     &lt;groupId&gt;com.vdurmont&lt;/groupId&gt;
     &lt;artifactId&gt;emoji-java&lt;/artifactId&gt;
    &lt;version&gt;3.2.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h3 id="2api">2、常用API</h3>
<pre><code>    @RequestMapping(&quot;/add/content&quot;)
    public ResponseEntity insertContent(@RequestBody Content content) {
        String title = content.getTitle();

        String titles = EmojiParser.parseToAliases(title);
        content.setTitle(titles);
        Integer integer = emojiMapper.insertContent(content);
        if (integer == 1) {
           return ResponseEntity.ok().build();
        }
        return  ResponseEntity.badRequest().build();

    }

    @RequestMapping(&quot;/get/{id}&quot;)
    public Content getById(@PathVariable(&quot;id&quot;) Integer id) {

        Content content = emojiMapper.selectById(id);
        String title = EmojiParser.parseToUnicode(content.getTitle());
        content.setTitle(title);
        if (content != null) {
            return content;
        }
        return  null;
    }
</code></pre><ul>
<li>EmojiParser.parseToAliases(string); 将表情符号转为字符</li>
<li>EmojiParser.parseToUnicode(string); 将字符转为表情符号</li>
</ul>
<h3 id="3">3、案例</h3>
<ul>
<li>存储图片</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-7ca27396c4a6b58e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>数据库存储记录</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-61a5a894b926af27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>查询记录</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-a97bc9194fbe4ee8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
]]></content>
        </item>
        
        <item>
            <title>Mac下Elasticsearch5.X和Head插件的安装</title>
            <link>https://blog.sailfishc.cn/posts/2017/03/mac%E4%B8%8Belasticsearch5.x%E5%92%8Chead%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85/</link>
            <pubDate>Sat, 25 Mar 2017 14:37:00 +0000</pubDate>
            
            <guid>https://blog.sailfishc.cn/posts/2017/03/mac%E4%B8%8Belasticsearch5.x%E5%92%8Chead%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85/</guid>
            <description>Elasticsearch5.x的安装：在ELK升级到5.0之后，有些特性发生了变化，例如全部使用JDK8，插件变化和环境校验等。
 一、安装Elasticsearch  在官网下载tar包，下载地址 下载之后解压 进入bin目录下启动   备注：如果是root用户启动会出现异常，因为es出去安全性考虑，禁止以root用户启动，解决办法是新建一个用户，详情请看这篇博客：CENTOS安装ElasticSearch。
  进入es的conf目录修改配置文件  cluster.name: es-cluster node.name: node-1 network.host: 0.0.0.0 http.port: 9200   启动ES，命令如下
 ./elasticsearch ./elasticsearch -d (这是后台启动）    看到如下日志信息：
  [2017-03-25T14:30:45,189][INFO ][o.e.n.Node ] [node-1] initializing ... [2017-03-25T14:30:45,272][INFO ][o.e.e.NodeEnvironment ] [node-1] using [1] data paths, mounts [[/ (/dev/disk1)]], net usable_space [278.8gb], net total_space [464.6gb], spins? [unknown], types [hfs] [2017-03-25T14:30:45,272][INFO ][o.e.e.NodeEnvironment ] [node-1] heap size [1.</description>
            <content type="html"><![CDATA[<blockquote>
<p>Elasticsearch5.x的安装：在ELK升级到5.0之后，有些特性发生了变化，例如全部使用JDK8，插件变化和环境校验等。</p>
</blockquote>
<h3 id="elasticsearch">一、安装Elasticsearch</h3>
<ul>
<li>在官网下载tar包，<a href="https://www.elastic.co/downloads/elasticsearch">下载地址</a></li>
<li>下载之后解压</li>
<li>进入bin目录下启动</li>
</ul>
<blockquote>
<p>备注：如果是root用户启动会出现异常，因为es出去安全性考虑，禁止以root用户启动，解决办法是新建一个用户，详情请看这篇博客：<a href="https://my.oschina.net/topeagle/blog/591451?fromerr=mzOr2qzZlogstash">CENTOS安装ElasticSearch</a>。</p>
</blockquote>
<ul>
<li>进入es的conf目录修改配置文件</li>
</ul>
<pre><code>cluster.name: es-cluster
node.name: node-1
network.host: 0.0.0.0
http.port: 9200
</code></pre><ul>
<li>
<p>启动ES，命令如下</p>
<ul>
<li>./elasticsearch</li>
<li>./elasticsearch -d (这是后台启动）</li>
</ul>
</li>
<li>
<p>看到如下日志信息：</p>
</li>
</ul>
<pre><code>[2017-03-25T14:30:45,189][INFO ][o.e.n.Node               ] [node-1] initializing ...
[2017-03-25T14:30:45,272][INFO ][o.e.e.NodeEnvironment    ] [node-1] using [1] data paths, mounts [[/ (/dev/disk1)]], net usable_space [278.8gb], net total_space [464.6gb], spins? [unknown], types [hfs]
[2017-03-25T14:30:45,272][INFO ][o.e.e.NodeEnvironment    ] [node-1] heap size [1.9gb], compressed ordinary object pointers [true]
[2017-03-25T14:30:45,273][INFO ][o.e.n.Node               ] [node-1] node name [node-1], node ID [n1HFjO-TQlSs4Ncw0HD34A]
[2017-03-25T14:30:45,276][INFO ][o.e.n.Node               ] [node-1] version[5.2.2], pid[3763], build[f9d9b74/2017-02-24T17:26:45.835Z], OS[Mac OS X/10.12.3/x86_64], JVM[Oracle Corporation/Java HotSpot(TM) 64-Bit Server VM/1.8.0_111/25.111-b14]
[2017-03-25T14:30:45,971][INFO ][o.e.p.PluginsService     ] [node-1] loaded module [aggs-matrix-stats]
[2017-03-25T14:30:45,971][INFO ][o.e.p.PluginsService     ] [node-1] loaded module [ingest-common]
[2017-03-25T14:30:45,971][INFO ][o.e.p.PluginsService     ] [node-1] loaded module [lang-expression]
[2017-03-25T14:30:45,971][INFO ][o.e.p.PluginsService     ] [node-1] loaded module [lang-groovy]
[2017-03-25T14:30:45,971][INFO ][o.e.p.PluginsService     ] [node-1] loaded module [lang-mustache]
[2017-03-25T14:30:45,971][INFO ][o.e.p.PluginsService     ] [node-1] loaded module [lang-painless]
[2017-03-25T14:30:45,971][INFO ][o.e.p.PluginsService     ] [node-1] loaded module [percolator]
[2017-03-25T14:30:45,971][INFO ][o.e.p.PluginsService     ] [node-1] loaded module [reindex]
[2017-03-25T14:30:45,972][INFO ][o.e.p.PluginsService     ] [node-1] loaded module [transport-netty3]
[2017-03-25T14:30:45,972][INFO ][o.e.p.PluginsService     ] [node-1] loaded module [transport-netty4]
[2017-03-25T14:30:45,972][INFO ][o.e.p.PluginsService     ] [node-1] no plugins loaded
[2017-03-25T14:30:47,936][INFO ][o.e.n.Node               ] [node-1] initialized
[2017-03-25T14:30:47,936][INFO ][o.e.n.Node               ] [node-1] starting ...
[2017-03-25T14:30:48,119][INFO ][o.e.t.TransportService   ] [node-1] publish_address {192.168.31.110:9300}, bound_addresses {[::]:9300}
[2017-03-25T14:30:48,123][INFO ][o.e.b.BootstrapChecks    ] [node-1] bound or publishing to a non-loopback or non-link-local address, enforcing bootstrap checks
[2017-03-25T14:30:51,226][INFO ][o.e.c.s.ClusterService   ] [node-1] new_master {node-1}{n1HFjO-TQlSs4Ncw0HD34A}{gn6UwArmTG-DEwYmzh1U9g}{192.168.31.110}{192.168.31.110:9300}, reason: zen-disco-elected-as-master ([0] nodes joined)
[2017-03-25T14:30:51,240][INFO ][o.e.h.HttpServer         ] [node-1] publish_address {192.168.31.110:9200}, bound_addresses {[::]:9200}
[2017-03-25T14:30:51,240][INFO ][o.e.n.Node               ] [node-1] started
[2017-03-25T14:30:51,246][INFO ][o.e.g.GatewayService     ] [node-1] recovered [0] indices into cluster_state
</code></pre><ul>
<li>通过IP访问，例如我的IP是192.168.31.110，那么访问地址就是192.168.31.110:9200，可以看到如下信息</li>
</ul>
<pre><code>{
name: &quot;n1HFjO-&quot;,
cluster_name: &quot;elasticsearch&quot;,
cluster_uuid: &quot;njH6T6eMS-mDf3tloN5THg&quot;,
version: {
number: &quot;5.2.2&quot;,
build_hash: &quot;f9d9b74&quot;,
build_date: &quot;2017-02-24T17:26:45.835Z&quot;,
build_snapshot: false,
lucene_version: &quot;6.4.1&quot;
},
tagline: &quot;You Know, for Search&quot;
}
</code></pre><h3 id="head">二、安装Head插件</h3>
<blockquote>
<p>Head插件是我们常用的插件，但是在ELK5.0以后按照之前的插件安装方式不能使用了，看了head官网之后，要单独启动一个服务才可以。</p>
</blockquote>
<ul>
<li><a href="https://github.com/mobz/elasticsearch-head">Head-GitHub官网</a></li>
<li>官网简易教程</li>
</ul>
<pre><code>git clone git://github.com/mobz/elasticsearch-head.git
cd elasticsearch-head
npm install
grunt server
</code></pre><p><strong>这里依赖Node环境，我们需要做一下工作：</strong></p>
<ul>
<li>Git</li>
<li><a href="https://nodejs.org/en/download/">Node官网</a></li>
</ul>
<h4 id="1head">1、Head插件安装</h4>
<ul>
<li>下载并安装对应的Node安装包</li>
<li>安装Git环境</li>
<li>下载Head项目</li>
<li>cd elasticsearch-head</li>
<li>修改服务器监听地址，地址目录：head/Gruntfile.js</li>
</ul>
<pre><code>connect: {
    server: {
        options: {
            port: 9100,
            hostname: '*',
            base: '.',
            keepalive: true
        }
    }
}
</code></pre><ul>
<li>修改连接地址，目录：head/_site/app.js</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-38c88f015bd861e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>npm install</li>
</ul>
<blockquote>
<p>备注：如果npm源特别慢的话，可以参考这篇文档：<a href="http://www.uedbox.com/npm-install-slow-solution/">npm install 无响应解决方案
</a></p>
</blockquote>
<ul>
<li>grunt是一个很方便的构建工具，可以进行打包压缩、测试、执行等等的工作，5.0里的head插件就是通过grunt启动的。因此需要安装一下grunt：<code>npm install grunt-cli</code></li>
<li>grunt server：保证es服务已经启动</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-633cc8658676a775.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>打开浏览器输入：IP:9100</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-411df93d94cc0cb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>正常的话可以看到已经连接了ES，但是ES社区中很多人反映都配置好了，但是看不到连接信息，这时候需要在在 es 的 elasticsearch.ym 里添加如下配置：</li>
</ul>
<pre><code>http.cors.enabled: true
http.cors.allow-origin: &quot;*&quot; 
</code></pre><blockquote>
<p>2017-03-26补充：在安装x-pack之后head无法连接es，只能将es的xpack认证给关闭，关闭方式：</p>
</blockquote>
<ul>
<li>在Es的conf文件中配置xpack.security.enabled: false</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Jenkins Maven Git SpringBoot Jar War Linux持续集成</title>
            <link>https://blog.sailfishc.cn/posts/2017/03/jenkins-maven-git-springboot-jar-war-linux%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</link>
            <pubDate>Fri, 24 Mar 2017 15:12:00 +0000</pubDate>
            
            <guid>https://blog.sailfishc.cn/posts/2017/03/jenkins-maven-git-springboot-jar-war-linux%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</guid>
            <description>一、前言 公司一直使用的是Java语言进行开发，自然而然逐渐的使用SpringBoot替代原来的框架，特别是对于现在的spring cloud微服务来说，一个项目由多个小项目组成，每个小项目都独立部署，使用jenkins是最好的部署和管理工具了。
Jenkins大概就这么工作：
 拉取GIT/SVN 等仓库的文件 然后使用Maven/Ant/Gradle等构件工具进行Build 构建成功之后会进行部署（deploy）  二、安装  Jenkins官网 下载War包或者Jar包都可以（推荐war包，适合新手，也比较稳定）   安装（略过） 安装条件  JDK MAVEN   插件安装   必备插件  Git plugin Maven Integration plugin publish over ssh插件（用于上传打包好的项目到远程Linux）   插件列表（太多不一一列出）  三、配置  此处省略jdk(请注意服务器上需要安装jdk，而不是jre)、maven、git的安装
 1、系统配置 在系统管理中找到Global Tool Configurations,其中包含jdk、git、maven等工具的配置
注意： 请勾掉自动安装，自己手动安装以上工具后再进行配置
三、新建项目 这里我们选择创建Maven项目：
如果在源码管理中出现如下红色代码，说明是本机的用户没有配置Git用户授权
这里使用了Git作为源码管理工具，先配置SSH Key，在Jenkins的证书管理中添加SSH。在Jenkins管理页面，选择“Credentials”，然后选择“Global credentials (unrestricted)”，点击“Add Credentials”，如下图所示，我们填写自己的SSH信息，然后点击“Save”，这样就把SSH添加到Jenkins的全局域中去了。
 备注：Passphrase这里不用填值，这是自动生成的。 如何配置Git ssh解决上述ssh key问题，可参考以下教程链接 http://www.linuxidc.com/Linux/2014-10/108080.htm
 配置成功后选择配置的用户，就发现已经没有红色的提示，说明ssh key配置成功了 1、构建  备注：这里的Root Pom指的是根目录下的Pom文件</description>
            <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/734456-9d9aa000a2176fa1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h2 id="heading">一、前言</h2>
<p>公司一直使用的是Java语言进行开发，自然而然逐渐的使用SpringBoot替代原来的框架，特别是对于现在的spring cloud微服务来说，一个项目由多个小项目组成，每个小项目都独立部署，使用jenkins是最好的部署和管理工具了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-727fcd1dd174863b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>Jenkins大概就这么工作：</p>
<ul>
<li>拉取GIT/SVN 等仓库的文件</li>
<li>然后使用Maven/Ant/Gradle等构件工具进行Build</li>
<li>构建成功之后会进行部署（deploy）</li>
</ul>
<h2 id="heading1">二、安装</h2>
<ul>
<li><a href="https://jenkins.io/index.html">Jenkins官网</a></li>
<li>下载War包或者Jar包都可以（推荐war包，适合新手，也比较稳定）</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-6ed5afc220bcf971.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>安装（略过）</li>
<li>安装条件
<ul>
<li>JDK</li>
<li>MAVEN</li>
</ul>
</li>
<li>插件安装</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-31a2db10f939d233.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>必备插件
<ul>
<li>Git plugin</li>
<li><a href="http://wiki.jenkins-ci.org/display/JENKINS/Maven+Project+Plugin">Maven Integration plugin</a></li>
<li>publish over ssh插件（用于上传打包好的项目到远程Linux）</li>
</ul>
</li>
<li>插件列表（太多不一一列出）</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-ba5e79a14fc8f11f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h2 id="heading2">三、配置</h2>
<blockquote>
<p>此处省略jdk(请注意服务器上需要安装jdk，而不是jre)、maven、git的安装</p>
</blockquote>
<h3 id="1">1、系统配置</h3>
<p>在系统管理中找到Global Tool Configurations,其中包含jdk、git、maven等工具的配置</p>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-6b6ad974687749b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-e6630d187141a908.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-c442bc89ef0430d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>注意： 请勾掉自动安装，自己手动安装以上工具后再进行配置</p>
<h2 id="heading3">三、新建项目</h2>
<p>这里我们选择创建Maven项目：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-f1f3c101baba2e12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>如果在源码管理中出现如下红色代码，说明是本机的用户没有配置Git用户授权</p>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-a3ff81beed0bd601.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>这里使用了Git作为源码管理工具，先配置SSH Key，在Jenkins的证书管理中添加SSH。在Jenkins管理页面，选择“Credentials”，然后选择“Global credentials (unrestricted)”，点击“Add Credentials”，如下图所示，我们填写自己的SSH信息，然后点击“Save”，这样就把SSH添加到Jenkins的全局域中去了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-d4812fcccba017d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<blockquote>
<p>备注：Passphrase这里不用填值，这是自动生成的。
如何配置Git ssh解决上述ssh key问题，可参考以下教程链接
<a href="http://www.linuxidc.com/Linux/2014-10/108080.htm"><a href="http://www.linuxidc.com/Linux/2014-10/108080.htm">http://www.linuxidc.com/Linux/2014-10/108080.htm</a></a></p>
</blockquote>
<p>配置成功后选择配置的用户，就发现已经没有红色的提示，说明ssh key配置成功了
<img src="http://upload-images.jianshu.io/upload_images/734456-9aca3e863f2438bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h3 id="11">1、构建</h3>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-f8aad83a9637aca7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<blockquote>
<p>备注：这里的Root Pom指的是根目录下的Pom文件</p>
</blockquote>
<p>如果是图一结构，Root Pom为：pom.xml</p>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-5d60696a8822d328.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>如果为图二结构，Root Pom为：project_A/pom.xml</p>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-1fc8d3ad36650808.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h3 id="2">2、授权服务器</h3>
<p>打开jenkins首页，点击系统管理&ndash;系统设置，下拉找到找到publish over ssh,进行以下设置（请确保前面的步骤中publish over ssh插件已经安装成功，如果没有发现，那就是还没有安装成功，请返回去安装）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-91e845ed76874d9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h3 id="3jar">3、部署Jar包</h3>
<p>进入上面的已经创建好的jenkinsWeb项目，点击配置，下拉找到Post Steps进行配置。</p>
<p>１、点击</p>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-a4f2907d49e74db5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png">
如果没找到这项，证明publish over ssh没有安装成功。</p>
<p>2、接着进行下图配置</p>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-b95732df59e48d68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>参数说明：</p>
<p>Transfer SetSource files：表示要上传的本地的jar包及路径，可到工作空间去看。</p>
<p>Remove prefix:表示要上传时要去除的文件夹，即只上传jar包。</p>
<p>remote driectory:即表示执行时的路径，相当于把jar包上传到这里了。</p>
<p>exec commad:要执行的命令脚本。</p>
<blockquote>
<p>构建脚本</p>
</blockquote>
<pre><code># 将应用停止
#stop.sh
#!/bin/bash
echo &quot;Stopping SpringBoot Application&quot;
pid=`ps -ef | grep search-1.0-SNAPSHOT.jar | grep -v grep | awk '{print $2}'`
if [ -n &quot;$pid&quot; ]
then
   kill -9 $pid
fi
</code></pre><pre><code>#replace.sh 用于将上次构建的结果备份，然后将新的构建结果移动到合适的位置
#!/bin/bash
# 先判断文件是否存在，如果存在，则备份
file=&quot;/home/app/mall-search/search-1.0-SNAPSHOT.jar&quot;
if [ -f &quot;$file&quot; ]
then
   mv /home/app/mall-search/search-1.0-SNAPSHOT.jar /home/app/mall-search/backup/search-1.0-SNAPSHOT.jar.`date +%Y%m%d%H%M%S`
fi
mv /home/app/deploy/search-1.0-SNAPSHOT.jar /home/app/mall-search/search-1.0-SNAPSHOT.jar
</code></pre><pre><code># startup.sh 启动项目
#!/bin/sh
export JAVA_HOME=/home/shopin/jdk1.8.0_121
echo ${JAVA_HOME}
echo &quot;授予当前用户权限&quot;
chmod 777 /home/shopin/mall-search/search-1.0-SNAPSHOT.jar
echo &quot;执行.....&quot;
cd /home/shopin/mall-search/
nohup ${JAVA_HOME}/bin/java -jar search-1.0-SNAPSHOT.jar &gt; /dev/null &amp;
echo &quot;启动成功...&quot;
</code></pre><p>这样就可以将jar包打到远程服务器了</p>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-7bee1d38208a4082.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h3 id="4wartomcat">4、部署War包容器（tomcat）中</h3>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-c0f207c324028f18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>如果容器是tomcat，就需要在tomcat配置相应的用户名和密码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-63057a4157bef0eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<blockquote>
<p>以上就是Jenkins for SpringBoot，同样也可以发布到tomcat</p>
</blockquote>
]]></content>
        </item>
        
        <item>
            <title>如何高效学习，总结自己的学习方法</title>
            <link>https://blog.sailfishc.cn/posts/2017/03/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</link>
            <pubDate>Wed, 22 Mar 2017 22:37:00 +0000</pubDate>
            
            <guid>https://blog.sailfishc.cn/posts/2017/03/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</guid>
            <description>在工作之后一段时间一直会有这么一种感觉：一天浑浑噩噩不知道干了什么，或者整天被他人打断而不能专注，又或者从早到晚的忙导致下班头脑发胀。
 自己也在寻找适合自己的学习方法，可能是学习能力比较差，一直没找到合适的，很多人推荐的番茄工作法自己尝试了几次也放弃了，但是现在工作每天都很忙，但是不知道自己干嘛了，这促使我又开始寻找一个适合自己的工具和学习方法。
这次的主题分两部分：
 工具 学习方法  一、工具 还是从番茄工作法开始了，再看了其他的学习法之后觉得还是回归到番茄工作法，原因就是简单，并且理论上是可行的，我一直坚定的认为只有理论正确，行动才不会走弯路。
 我的番茄工作流程  这里区分两个工具：
 一个任务清单软件，例如滴答清单 一个番茄钟，这里推荐Chrome插件版的番茄钟  1、List清单负责维护近期的活动清单
2、计时插件界面简洁还提供了统计和云同步功能。
3、简单的excel表格用来记录每天的完成情况
 备注：Excel是一个额外的动作，主要是为了知道自己每天做了什么，在番茄钟运行的过程中很可能因为外部原因或者内部原因导致中断，如果中断了就如实的记录下来。
 二、学习方法 这里的学习方法不是指某个具体学科的学习方法，而是对知识的一个统一轮廓，就是一个大的概念，不是那种21天精通Java等等，也就是一个理论加实践的过程，很多时候最基础的就是最好的，学习方法其实在上学的时候老师就会经常说，就是：预习+认真听讲+复习，在1W小时训练的基础上很大一部分就是重复，但是是要有目的的重复。
 我的理论基础  我们获取知识的渠道多种多样，但是最终的目的就是为了在用的时候可以想起来或者可以灵活运用（在大脑中建立起联系），也就像写代码，有输入，有输入，在中间环节进行了转换而已，我大概理了一下，知识的获取有这么一些渠道：
 官网文档 博客 GitHub等 视频资源 书籍 门户网站 各类信息类APP 微信公众账号 &amp;hellip;&amp;hellip;.  总的来说，我已吸收知识的时间段分为：
 即时知识 延时知识  即时知识是在看的过程中就可以消化的了，知识量比较少，常见的是为了解决一个问题去百度或者Google或者查找资料找到了解决办法，或者是一些非专业性知识等，再或者是在大片时间去看书，延时知识是我们经常用到的知识，例如一片专业的博客或者资料没时间看会保存在笔记类软件中或者是类似POCKET这种稍后阅读软件中，然后有时间再看。
  基于此知识体系我理出的流程就是知识输入，中间转化，然后输出，有必要（精华）再分享，在复习即可，关于复习这其实是很重要的一步，这也是重复练习和记录笔记重要的一步，我也一直没做好这步，具体操作有以下几个步骤。
  以周作为一个小单元，月作为一个大单元，每周给自己安排一段时间专门进行知识的复习，清空自己在POCKET中存储的List，将没用的清除掉，有用的整理为笔记存储，然后也从Pocket中清除掉，不要把没经过自己大脑思考的东西记录到笔记中，如果有必要，将自己的笔记整理为博客发表，关于学习，用好工具也是相当必要的，推荐几款上面说到不同阶段的工具。
  输入工具
 pocket 开发者头条 掘金 知乎 简书 各类博客    中间转化
 Xmind（思维导图） processon（画流程图） 纸和笔 你的大脑    输出工具</description>
            <content type="html"><![CDATA[<blockquote>
<p>在工作之后一段时间一直会有这么一种感觉：一天浑浑噩噩不知道干了什么，或者整天被他人打断而不能专注，又或者从早到晚的忙导致下班头脑发胀。</p>
</blockquote>
<p>自己也在寻找适合自己的学习方法，可能是学习能力比较差，一直没找到合适的，很多人推荐的番茄工作法自己尝试了几次也放弃了，但是现在工作每天都很忙，但是不知道自己干嘛了，这促使我又开始寻找一个适合自己的工具和学习方法。</p>
<p>这次的主题分两部分：</p>
<ul>
<li>工具</li>
<li>学习方法</li>
</ul>
<h2 id="heading">一、工具</h2>
<p>还是从番茄工作法开始了，再看了其他的学习法之后觉得还是回归到番茄工作法，原因就是简单，并且理论上是可行的，我一直坚定的认为只有理论正确，行动才不会走弯路。</p>
<ul>
<li>我的番茄工作流程</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-8f085c7444438995.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>这里区分两个工具：</p>
<ul>
<li>一个任务清单软件，例如滴答清单</li>
<li>一个番茄钟，这里推荐Chrome插件版的番茄钟</li>
</ul>
<p>1、List清单负责维护近期的活动清单</p>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-00ad77333d792c68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>2、计时插件界面简洁还提供了统计和云同步功能。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-5d991fe0ae6a94d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>3、简单的excel表格用来记录每天的完成情况</p>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-11651b402cafdf8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<blockquote>
<p>备注：Excel是一个额外的动作，主要是为了知道自己每天做了什么，在番茄钟运行的过程中很可能因为外部原因或者内部原因导致中断，如果中断了就如实的记录下来。</p>
</blockquote>
<h2 id="heading1">二、学习方法</h2>
<p>这里的学习方法不是指某个具体学科的学习方法，而是对知识的一个统一轮廓，就是一个大的概念，不是那种21天精通Java等等，也就是一个理论加实践的过程，很多时候最基础的就是最好的，学习方法其实在上学的时候老师就会经常说，就是：预习+认真听讲+复习，在1W小时训练的基础上很大一部分就是重复，但是是要有目的的重复。</p>
<ul>
<li>我的理论基础</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/734456-b542f58c7685aff3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>我们获取知识的渠道多种多样，但是最终的目的就是为了在用的时候可以想起来或者可以灵活运用（在大脑中建立起联系），也就像写代码，有输入，有输入，在中间环节进行了转换而已，我大概理了一下，知识的获取有这么一些渠道：</p>
<ul>
<li>官网文档</li>
<li>博客</li>
<li>GitHub等</li>
<li>视频资源</li>
<li>书籍</li>
<li>门户网站</li>
<li>各类信息类APP</li>
<li>微信公众账号</li>
<li>&hellip;&hellip;.</li>
</ul>
<p>总的来说，我已吸收知识的时间段分为：</p>
<ul>
<li>即时知识</li>
<li>延时知识</li>
</ul>
<p>即时知识是在看的过程中就可以消化的了，知识量比较少，常见的是为了解决一个问题去百度或者Google或者查找资料找到了解决办法，或者是一些非专业性知识等，再或者是在大片时间去看书，延时知识是我们经常用到的知识，例如一片专业的博客或者资料没时间看会保存在笔记类软件中或者是类似POCKET这种稍后阅读软件中，然后有时间再看。</p>
<ul>
<li>
<p>基于此知识体系我理出的流程就是知识输入，中间转化，然后输出，有必要（精华）再分享，在复习即可，关于复习这其实是很重要的一步，这也是重复练习和记录笔记重要的一步，我也一直没做好这步，具体操作有以下几个步骤。</p>
</li>
<li>
<p>以周作为一个小单元，月作为一个大单元，每周给自己安排一段时间专门进行知识的复习，清空自己在POCKET中存储的List，将没用的清除掉，有用的整理为笔记存储，然后也从Pocket中清除掉，<strong>不要把没经过自己大脑思考的东西记录到笔记中</strong>，如果有必要，将自己的笔记整理为博客发表，关于学习，用好工具也是相当必要的，推荐几款上面说到不同阶段的工具。</p>
</li>
<li>
<p>输入工具</p>
<ul>
<li>pocket</li>
<li>开发者头条</li>
<li>掘金</li>
<li>知乎</li>
<li>简书</li>
<li>各类博客</li>
</ul>
</li>
<li>
<p>中间转化</p>
<ul>
<li>Xmind（思维导图）</li>
<li>processon（画流程图）</li>
<li>纸和笔</li>
<li>你的大脑</li>
</ul>
</li>
<li>
<p>输出工具</p>
<ul>
<li>为知笔记</li>
<li>有道云笔记</li>
<li>印象笔记</li>
<li>OneNote</li>
</ul>
</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Java程序员学习路线</title>
            <link>https://blog.sailfishc.cn/posts/2017/03/java%E7%A8%8B%E5%BA%8F%E5%91%98%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</link>
            <pubDate>Wed, 01 Mar 2017 17:58:27 +0000</pubDate>
            
            <guid>https://blog.sailfishc.cn/posts/2017/03/java%E7%A8%8B%E5%BA%8F%E5%91%98%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</guid>
            <description>从认真开始学习Java到从事Java工作到现在，已经有一年时间了，在之前的学习过程中大多是通过视频进行学习的，没有工作上的经验，也就没有深入思考，刚开始想的就是会用就好，但是在工作之后发现，除了会用，还得要去思考，当然，在工作中需要学习的东西太多太多了，目前的关键就是找到适合自己的学习方法，培养起来快速学习的能力，在此之前，就是一段迷茫期，也算是在迷茫中进行探索，也走了很多弯路，得出一句话，经典的未必适合自己，别人的成功经验也不是自己的。 在JavaEE这条路上，之前我是这么认识的，首先应该学习Java基础，然后开始学习JavaWeb，在JavaWeb学习中避免不了要学习三大框架，当然，数据库知识也是要有的，以及一定的前端知识，这样就可以做出一个网站了。但是随着工作经验的增加，对于做产品这件事情也有了和之前不一样的理解，首先是对这种大而全的概念已经没有了，认识到了一个更加广阔的世界之后，就会发现自己能力的渺小，你就更加的认识了自己，会衡量自己能不能做，这算是一个优点，但也会是自己能力的瓶颈，具体我就不举例子，Java可以做很多事情，从片面的B/S结构到目前理解的B/S结构，一年的时间真的可以改变一个人很多。 感觉有点跑题了，说回来，还是怎么学习：
1、你得对你所在行业的知识框架要有一个基本的了解  比如我所在的JavaEE的学习路线：
 Java基础
 基础语法 逻辑控制流 面向对象的知识 常用的类，如String IO 集合 多线程 异常 网络编程  JavaWeb
 html/css/js相关基础知识 xml相关配置 Tomcat服务器 Servlet/JSP 数据库相关知识 过滤器，监听器 ajax session/cookie jdbc  框架相关(会用即可)
 spring springmvc myBatis  这是最基础的知识，这个层面就是先会用，可以在网上找一个网上商城的例子用来练习，把整体的代码思路看看，就算是OK了。 在实习工作期间，主要是适应公司的代码环境，这时候要会用一定的工具，类似版本控制，项目管理工具等：
 GIT SVN Maven  这些工具的基本操作学习用不了多久，但是会给你带动很高的效率，在这之后，就是真正开始自己学习的过程，这才是提高的过程，你得根据自己的实际情况开始自己学习，不再依赖于视频教程，更多的是来源于书籍和自己实际项目的思考，首先要将业务需求转化为自己的代码实现，这是最关键的，其次是思考，怎么写更好，这是一个模仿+思考的过程，你要了解系统的整体结构是什么，用到了哪些技术，日志是怎么处理的，异常是怎么处理的，最关键的是要有自己的代码风格。
2、一次项目交接的思考 前几天有个同事要离职了，他的项目需要进行交接，我最近工作量比较少，就由我进行交接，这几天我觉得是我好几个月来成长最快的几天，我和他单独交流，因为项目是新建的一个项目，项目中业务信息不多，所以好理解，两天时间，基本上就可以上手了，之后的一天里我就一直和他在聊系统的设计思路和编码风格以及如何提高自己的编码水平。 很多人在做项目的时候思考的是如何做出来，也包括我，但是没有思考怎么做更好，他说他在做这个项目中删除了很多代码，想了好几套方法去解决，最终是保留了一套觉得自己好的，在这里，它借鉴了两个框架的设计思路，他没有深入了解过一个框架，但是大体了解一些，通过在写项目的过程中它看了些框架的源码，借鉴了一些它的思路，慢慢的也就有了一个从需求很不明确，没有的项目到现在也算是一个产品的项目，这其中花费了自己很大的心思。 我一直觉得自己的代码写的很烂，也一直想提高，但是苦于不知道如何提高，听了他的这些话，我就在想，目前我有基本的编码基础，我应该怎样提高，做项目？目前没有太多的时间去完整的做一个项目，最好的开端就是借鉴，从一个开源框架中借鉴它的思路，学习它的设计模式，编码风格，对工具类的封装，对功能的实现，这就像是你刚来公司的时候，要学习公司项目一样，但是这种开源框架会比较大，也比较难，不会像公司项目那样相对容易的让你去学习，但是坚持下去，总会有改变。</description>
            <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/734456-bd44329a91cb8500.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>从认真开始学习Java到从事Java工作到现在，已经有一年时间了，在之前的学习过程中大多是通过视频进行学习的，没有工作上的经验，也就没有深入思考，刚开始想的就是会用就好，但是在工作之后发现，除了会用，还得要去思考，当然，在工作中需要学习的东西太多太多了，目前的关键就是找到适合自己的学习方法，培养起来快速学习的能力，在此之前，就是一段迷茫期，也算是在迷茫中进行探索，也走了很多弯路，得出一句话，经典的未必适合自己，别人的成功经验也不是自己的。
在JavaEE这条路上，之前我是这么认识的，首先应该学习Java基础，然后开始学习JavaWeb，在JavaWeb学习中避免不了要学习三大框架，当然，数据库知识也是要有的，以及一定的前端知识，这样就可以做出一个网站了。但是随着工作经验的增加，对于做产品这件事情也有了和之前不一样的理解，首先是对这种大而全的概念已经没有了，认识到了一个更加广阔的世界之后，就会发现自己能力的渺小，你就更加的认识了自己，会衡量自己能不能做，这算是一个优点，但也会是自己能力的瓶颈，具体我就不举例子，Java可以做很多事情，从片面的B/S结构到目前理解的B/S结构，一年的时间真的可以改变一个人很多。
感觉有点跑题了，说回来，还是怎么学习：</p>
<h3 id="1">1、你得对你所在行业的知识框架要有一个基本的了解</h3>
<blockquote>
<p>比如我所在的JavaEE的学习路线：</p>
</blockquote>
<p><strong>Java基础</strong></p>
<ul>
<li>基础语法</li>
<li>逻辑控制流</li>
<li>面向对象的知识</li>
<li>常用的类，如String</li>
<li>IO</li>
<li>集合</li>
<li>多线程</li>
<li>异常</li>
<li>网络编程</li>
</ul>
<p><strong>JavaWeb</strong></p>
<ul>
<li>html/css/js相关基础知识</li>
<li>xml相关配置</li>
<li>Tomcat服务器</li>
<li>Servlet/JSP</li>
<li>数据库相关知识</li>
<li>过滤器，监听器</li>
<li>ajax</li>
<li>session/cookie</li>
<li>jdbc</li>
</ul>
<p><strong>框架相关(会用即可)</strong></p>
<ul>
<li>spring</li>
<li>springmvc</li>
<li>myBatis</li>
</ul>
<p>这是最基础的知识，这个层面就是先会用，可以在网上找一个网上商城的例子用来练习，把整体的代码思路看看，就算是OK了。
在实习工作期间，主要是适应公司的代码环境，这时候要会用一定的工具，类似版本控制，项目管理工具等：</p>
<ul>
<li>GIT</li>
<li>SVN</li>
<li>Maven</li>
</ul>
<p>这些工具的基本操作学习用不了多久，但是会给你带动很高的效率，在这之后，就是真正开始自己学习的过程，这才是提高的过程，你得根据自己的实际情况开始自己学习，不再依赖于视频教程，更多的是来源于书籍和自己实际项目的思考，首先要将业务需求转化为自己的代码实现，这是最关键的，其次是思考，怎么写更好，这是一个模仿+思考的过程，你要了解系统的整体结构是什么，用到了哪些技术，日志是怎么处理的，异常是怎么处理的，最关键的是要有自己的代码风格。</p>
<h3 id="2">2、一次项目交接的思考</h3>
<p>前几天有个同事要离职了，他的项目需要进行交接，我最近工作量比较少，就由我进行交接，这几天我觉得是我好几个月来成长最快的几天，我和他单独交流，因为项目是新建的一个项目，项目中业务信息不多，所以好理解，两天时间，基本上就可以上手了，之后的一天里我就一直和他在聊系统的设计思路和编码风格以及如何提高自己的编码水平。
很多人在做项目的时候思考的是如何做出来，也包括我，但是没有思考怎么做更好，他说他在做这个项目中删除了很多代码，想了好几套方法去解决，最终是保留了一套觉得自己好的，在这里，它借鉴了两个框架的设计思路，他没有深入了解过一个框架，但是大体了解一些，通过在写项目的过程中它看了些框架的源码，借鉴了一些它的思路，慢慢的也就有了一个从需求很不明确，没有的项目到现在也算是一个产品的项目，这其中花费了自己很大的心思。
我一直觉得自己的代码写的很烂，也一直想提高，但是苦于不知道如何提高，听了他的这些话，我就在想，目前我有基本的编码基础，我应该怎样提高，做项目？目前没有太多的时间去完整的做一个项目，最好的开端就是借鉴，从一个开源框架中借鉴它的思路，学习它的设计模式，编码风格，对工具类的封装，对功能的实现，这就像是你刚来公司的时候，要学习公司项目一样，但是这种开源框架会比较大，也比较难，不会像公司项目那样相对容易的让你去学习，但是坚持下去，总会有改变。</p>
]]></content>
        </item>
        
        <item>
            <title>使用 Github 空间搭建 Hexo 技术博客--安装篇（基于 IntelliJ IDEA）</title>
            <link>https://blog.sailfishc.cn/posts/2016/02/%E4%BD%BF%E7%94%A8-github-%E7%A9%BA%E9%97%B4%E6%90%AD%E5%BB%BA-hexo-%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2-%E5%AE%89%E8%A3%85%E7%AF%87%E5%9F%BA%E4%BA%8E-intellij-idea/</link>
            <pubDate>Sun, 28 Feb 2016 17:58:27 +0000</pubDate>
            
            <guid>https://blog.sailfishc.cn/posts/2016/02/%E4%BD%BF%E7%94%A8-github-%E7%A9%BA%E9%97%B4%E6%90%AD%E5%BB%BA-hexo-%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2-%E5%AE%89%E8%A3%85%E7%AF%87%E5%9F%BA%E4%BA%8E-intellij-idea/</guid>
            <description>部署前介绍  这篇博客引自code.youmeek.com  Hexo 是什么  Hexo 的中文官网：http://hexo.io/zh-cn/ 作者 Tommy Chen：https://zespia.tw/ 在我的理解里面：Hexo 是一个基于 Node.js 快速、简洁且高效的博客框架，可以将 Markdown 文件快速的生成静态网页，托管在 GitHub Pages 上。 而官网自己是这样说的：   Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。
 为什么要用 Hexo  我：因为其他博客框架太烂了 Tommy Chen：https://zespia.tw/blog/2012/10/11/hexo-debut/  适合人群  有 IntelliJ IDEA 基础的程序员（或者你使用的是 JetBrains 家的其他产品） 只想搭建一个技术博客的人（真心别搞太多，你没那么多精力）  文章要求  如果是 Git，Node.js 的新人，则这篇文章不要间断操作，要一气呵成，不然可能会遇到各种问题。  本文环境  系统：  Windows 10（64 位）   软件：  git：2.7.0.2-64-bit IntelliJ IDEA：15.0.4 node.js：v5.7.0-64-bit Stable   账号：  Github：https://github.</description>
            <content type="html"><![CDATA[<!-- raw HTML omitted -->
<h2 id="heading">部署前介绍</h2>
<ul>
<li>这篇博客引自code.youmeek.com</li>
</ul>
<h3 id="hexo-">Hexo 是什么</h3>
<ul>
<li>Hexo 的中文官网：<a href="http://hexo.io/zh-cn/">http://hexo.io/zh-cn/</a></li>
<li>作者 Tommy Chen：<a href="https://zespia.tw/">https://zespia.tw/</a></li>
<li>在我的理解里面：Hexo 是一个基于 Node.js 快速、简洁且高效的博客框架，可以将 Markdown 文件快速的生成静态网页，托管在 GitHub Pages 上。</li>
<li>而官网自己是这样说的：</li>
</ul>
<blockquote>
<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
</blockquote>
<h3 id="-hexo">为什么要用 Hexo</h3>
<ul>
<li>我：因为其他博客框架太烂了</li>
<li>Tommy Chen：<a href="https://zespia.tw/blog/2012/10/11/hexo-debut/">https://zespia.tw/blog/2012/10/11/hexo-debut/</a></li>
</ul>
<h3 id="heading1">适合人群</h3>
<ul>
<li>有 IntelliJ IDEA 基础的程序员（或者你使用的是 JetBrains 家的其他产品）</li>
<li>只想搭建一个技术博客的人（真心别搞太多，你没那么多精力）</li>
</ul>
<h3 id="heading2">文章要求</h3>
<ul>
<li>如果是 Git，Node.js 的新人，则这篇文章不要间断操作，要一气呵成，不然可能会遇到各种问题。</li>
</ul>
<h3 id="heading3">本文环境</h3>
<ul>
<li>系统：
<ul>
<li>Windows 10（64 位）</li>
</ul>
</li>
<li>软件：
<ul>
<li>git：<strong>2.7.0.2-64-bit</strong></li>
<li>IntelliJ IDEA：<strong>15.0.4</strong></li>
<li>node.js：<strong>v5.7.0-64-bit Stable</strong></li>
</ul>
</li>
<li>账号：
<ul>
<li>Github：<a href="https://github.com/">https://github.com/</a></li>
<li>DNSPOD：<a href="https://www.dnspod.cn/">https://www.dnspod.cn/</a></li>
</ul>
</li>
</ul>
<h3 id="heading4">搭建所需软件</h3>
<ul>
<li>各个软件官网：
<ul>
<li>git：<a href="http://git-scm.com/">http://git-scm.com/</a></li>
<li>IntelliJ IDEA：<a href="https://www.jetbrains.com/idea/">https://www.jetbrains.com/idea/</a></li>
<li>node.js：<a href="http://nodejs.org/">http://nodejs.org/</a></li>
</ul>
</li>
<li>所需软件集合：
<ul>
<li>上面三者集合包：<a href="http://pan.baidu.com/s/1bvbo8e">http://pan.baidu.com/s/1bvbo8e</a></li>
</ul>
</li>
</ul>
<h3 id="heading5">文章前提</h3>
<ul>
<li>如果你对上面要求的软件一个都不了解的话，建议你先看如下内容（只是让你们先了解下，当时别照着文章内容做）：
<ul>
<li><a href="http://www.jianshu.com/p/05289a4bc8b2">如何搭建一个独立博客——简明Github Pages与Hexo教程</a></li>
<li><a href="http://www.jianshu.com/p/858ecf233db9">通过Hexo在Github上搭建博客教程</a></li>
<li><a href="http://ibruce.info/2013/11/22/hexo-your-blog/">hexo你的博客</a></li>
<li><a href="http://www.jianshu.com/p/701b1095da11">手把手教你建github技术博客</a></li>
<li><a href="http://www.jianshu.com/p/05289a4bc8b2">如何搭建一个独立博客——简明Github Pages与Hexo教程</a></li>
<li><a href="http://www.jianshu.com/p/e858a90d0a17">windows下搭建hexo博客并将其部署到GitCafe终极教程</a></li>
<li><a href="http://www.jianshu.com/p/db7e64d86067">使用Hexo搭建博客（三），博客配置、主题和写作</a></li>
<li><a href="http://www.jianshu.com/p/e7413116e9d4">Hexo搭建WiKi</a></li>
<li><a href="https://www.zhihu.com/question/28058973">怎么用hexo上传一个README.md到github?</a></li>
</ul>
</li>
</ul>
<h3 id="heading6">域名绑定</h3>
<ul>
<li>如果你一开始就打算要绑定域名，则下面教程中所有可以填写域名的地方你都填写上你要绑定的域名，如果你没独立域名，那就使用 Github 默认给你的：XXXXXX.github.io 域名即可。</li>
</ul>
<hr>
<h2 id="heading7">部署开始</h2>
<h3 id="git-">git 安装</h3>
<ul>
<li>双击运行 <strong>Git-2.7.0.2-64-bit.exe</strong>，接下来一律下一步，不需要多余的选择，假设你安装的目录位置跟我一样：C:\Program Files\Git</li>
<li>打开 Git Bash（路径：C:\Program Files\Git\git-bash.exe），输入：<code>git --version</code>
<ul>
<li>如下图，如果出现：<strong>git version 2.7.0.windows.2</strong>，这表示安装成功</li>
<li><img src="http://img.youmeek.com/2016/hexo-start-a-1.jpg" alt="验证 git 安装"></li>
</ul>
</li>
</ul>
<h3 id="nodejs-">Node.js 安装</h3>
<ul>
<li>双击运行 <strong>node-v5.7.0-x64.msi</strong>，接下来一律下一步，不需要多余的选择。</li>
<li>安装完之后，打开 Git Bash，输入：<code>npm -v</code>
<ul>
<li>如下图，如果出现：<strong>3.6.0</strong>，则表示 Node.js 安装成功。如果你没有显示这个信息，我怀疑你需要重启电脑试试看，因为我在给我弟讲解这一步的时候发现有这个问题。</li>
<li><img src="http://img.youmeek.com/2016/hexo-start-a-2.jpg" alt="验证 node.js 安装"></li>
</ul>
</li>
</ul>
<h3 id="nodejs-1">Node.js 源设置</h3>
<ul>
<li>在安装 Hexo 之前，先说一下 Node.js 的源，Node.js 官方源默认是：<a href="http://registry.npmjs.org">http://registry.npmjs.org</a>，但是由于在国外，说不定你使用的时候就抽风无法下载任何软件。所以我们决定暂时使用淘宝提供的源，淘宝源官网：<a href="http://npm.taobao.org/">http://npm.taobao.org/</a></li>
<li>在 Git Bash 中我们执行下面这一句（这是一整句的）：</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">alias cnpm<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">npm --registry=https://registry.npm.taobao.org \
</span><span style="color:#e6db74">--cache=</span>$HOME<span style="color:#e6db74">/.npm/.cache/cnpm \
</span><span style="color:#e6db74">--disturl=https://npm.taobao.org/dist \
</span><span style="color:#e6db74">--userconfig=</span>$HOME<span style="color:#e6db74">/.cnpmrc</span><span style="color:#e6db74">&#34;</span>
</code></pre></div><ul>
<li>现在验证下是否可以使用淘宝的 cnpm 命令：<code>cnpm info express</code>
<ul>
<li>如果能输出一大堆介绍，则说明成功了，以后每次要使用淘宝的源都需要这样来。现在除了默认的 <strong>npm</strong>，还多了一个 <strong>cnpm</strong> 可以使用，我们下面有关安装的讲解内容也都是基于此临时命令。</li>
<li>如果输出：bash: cnpm: command not found，则表示没成功，需要你在排查下</li>
<li>需要强调的是：<strong>cnpm</strong> 不是永久性命令，只是此时这个界面窗口下的临时命令，关掉窗口就没效果了。</li>
</ul>
</li>
</ul>
<h3 id="-hexo-">安装 Hexo 框架</h3>
<ul>
<li>安装 Hexo（注意，现在是 cnpm 开头了，不是 npm 了）：<code>cnpm install -g hexo-cli</code>
<ul>
<li>安装时间不一定很快，有可能需要等 3 ~ 5 分钟。</li>
<li>安装过程中有 WARN 警告也没关系的，不用在意这些 WARN，继续等它安装完成。因为国内的网络问题，有时候安装异常慢花了大半个小时都没效果，那就 Ctrl + C 停掉这次命令，重新再执行一次。</li>
</ul>
</li>
</ul>
<h3 id="-hexo-1">创建 Hexo 项目</h3>
<ul>
<li>现在假设我要创建一个名为 hexo 的项目，项目目录就放在：E:\git_work_space 目录下，所以我们在 E:\git_work_space 目录下创建一个 hexo 目录。现在这个项目的全路径是：E:\git_work_space\hexo</li>
<li>打开 Git Bash：
<ul>
<li>进入该目录：<code>cd e:/git_work_space/hexo</code></li>
<li>然后执行：<code>hexo init</code>，这个时间也会比较长，也有可能要等几分钟，有显示 WARN 也不用管</li>
<li>最后执行：<code>cnpm install</code>，有显示 WARN 也不用管</li>
<li>安装完成之后，E:\git_work_space\hexo 目录结构是这样的：
<ul>
<li><img src="http://img.youmeek.com/2016/hexo-start-b-1.jpg" alt="安装 hexo 后的目录结构"></li>
</ul>
</li>
<li>现在我们启动 hexo 本地服务，看下默认的博客是怎样的，命令：<code>hexo server</code></li>
<li>现在用浏览器访问：<a href="http://localhost:4000/">http://localhost:4000/</a>，效果如下图
<ul>
<li><img src="http://img.youmeek.com/2016/hexo-start-b-2.jpg" alt="默认模板效果"></li>
</ul>
</li>
<li>如果要停止 hexo 服务：在 Git Bash 下按 <code>Ctrl + C</code> 即可</li>
</ul>
</li>
</ul>
<h3 id="heading8">选用其他主题</h3>
<ul>
<li>由于默认主题太大众了，所以现在我们换个主题。</li>
<li>你可以去这里找主题：
<ul>
<li>hexo-theme：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></li>
<li>hexo-github-theme-list：<a href="https://github.com/hexojs/hexo/wiki/Themes">https://github.com/hexojs/hexo/wiki/Themes</a></li>
<li>有那些好看的hexo主题？：<a href="http://www.zhihu.com/question/24422335">http://www.zhihu.com/question/24422335</a></li>
</ul>
</li>
<li>我这里选择的 <strong>yelee</strong>：<a href="https://github.com/MOxFIVE/hexo-theme-yelee">https://github.com/MOxFIVE/hexo-theme-yelee</a>
<ul>
<li>原因是能最大化衬托出：目录、文章内容、代码块。因为我对这个博客的定位就是用来放技术类内容，所以不会让它太杂或是太花。只是目前这个颜色偏浅，后续还需要调整。</li>
</ul>
</li>
<li>现在假设你跟我要用的模板是一样：
<ul>
<li>还是让 Git Bash 保持在 E:\git_work_space\hexo 目录下，然后输入命令：<code>git clone https://github.com/MOxFIVE/hexo-theme-yelee.git themes/yelee</code></li>
<li>这样就在 E:\git_work_space\hexo\themes 目录下生成了一个 yelle 文件夹，里面有我们刚刚 clone 下来的主题内容。</li>
<li>如果以后你不自己修改这个主题的话，可以考虑经常更新下作者的更新内容：
<ul>
<li><code>cd e:/git_work_space/hexo/themes/yelee</code></li>
<li><code>git pull origin master</code></li>
</ul>
</li>
</ul>
</li>
<li>下载好主题文件之后，我们现在要修改 E:\git_work_space\hexo 目录下的项目配置文件：<strong>_config.yml</strong>，把对应的主题目录名改下，编辑如下图。
<ul>
<li><img src="http://img.youmeek.com/2016/hexo-start-b-3.jpg" alt="修改主题目录"></li>
</ul>
</li>
<li>更改主题目录名后，我们还要重新生成主题静态内容：
<ul>
<li>继续在 Git Bash 中输入命令：
<ul>
<li>重新生成静态博客的所有内容：<code>hexo generate</code></li>
<li>重启 hexo 本地服务：<code>hexo server</code></li>
<li>重新访问：<a href="http://localhost:4000/">http://localhost:4000/</a>，效果如下图</li>
<li><img src="http://img.youmeek.com/2016/hexo-start-b-4.jpg" alt="新主题效果"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="-github-pages--ssh-">创建 Github pages 并 SSH 授权</h3>
<ul>
<li>现在假设你已经有一个 Gtihub 账号，你还需要一个特别的仓库，特别在仓库名就是你的 Github 账号登录名，比如我的用户名是：judasn，那我要创建的仓库名字完整滴填写是：judasn.github.io，具体效果如下图。
<ul>
<li><img src="http://img.youmeek.com/2016/hexo-start-c-1.jpg" alt="创建 github pages"></li>
</ul>
</li>
<li>创建好仓库之后，要本地生成 SSH 秘钥，方便电脑上的 git 软件好提交内容到 Github 上
<ul>
<li>在 Git Bash 中，输入：<code>ssh-keygen -t rsa -C &quot;你的邮箱地址&quot;</code>，然后回车，回车，再回车，一共 3 次回车，具体含义自己 Google。</li>
<li>比如我的：<code>ssh-keygen -t rsa -C &quot;jn3.141592654@gmail.com&quot;</code>，生成后效果如下图：</li>
<li><img src="http://img.youmeek.com/2016/hexo-start-c-2.jpg" alt="生成 ssh 密钥"></li>
<li>此时，生成密钥后，在你电脑目录：C:\Users\你的计算机用户名\.ssh 下，会生成两个文件：
<ul>
<li>私钥：<strong>id_rsa</strong></li>
<li>公钥：<strong>id_rsa.pub</strong></li>
<li>如果生成的不是这样的文件，那删除掉这两个生成的，重新执行上面的命令，让它再一次生成。</li>
</ul>
</li>
<li>现在用记事本打开 id_rsa.pub，复制文件中的所有内容。
<ul>
<li>访问：<a href="https://github.com/settings/ssh">https://github.com/settings/ssh</a>，添加新秘钥，效果如下图
<ul>
<li>Title：自己随便取</li>
<li>Key：把刚刚复制的都粘贴进来</li>
<li><img src="http://img.youmeek.com/2016/hexo-start-c-3.jpg" alt="添加密钥"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="-github-">把本地的博客内容同步到 Github 上</h3>
<ul>
<li>要把本地的静态博客同步到 Github，我们还需要先安装两个跟部署相关的 hexo 插件：
<ul>
<li>继续在 Git Bash 中输入：</li>
<li><code>cnpm install hexo -server --save</code></li>
<li><code>cnpm install hexo-deployer-git --save</code></li>
</ul>
</li>
<li>编辑全局 hexo 的配置文件：<strong>_config.yml</strong>
<ul>
<li>官网对此配置的介绍：<a href="https://hexo.io/zh-cn/docs/configuration.html">https://hexo.io/zh-cn/docs/configuration.html</a></li>
<li>我自己的编辑内容初稿（你需要认真看的是含有中文注释的内容）：</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># Hexo Configuration</span>
<span style="color:#75715e">## Docs: https://hexo.io/docs/configuration.html</span>
<span style="color:#75715e">## Source: https://github.com/hexojs/hexo/</span>

<span style="color:#75715e"># Site，这一块区域主要是设置博客的主要说明，需要注意的是：每个冒号后面都是有一个空格，然后再书写自己的内容的</span>
title: YouMeek Code
subtitle: 这里只有代码相关，要了解更多 &gt;&gt;&gt; YouMeek.com
description: 这里是 YouMeek.com 一部分
author: Judas.n
email: 363379444@qq.com
language: zh-CN
timezone:

<span style="color:#75715e"># URL，这一块一般可以设置的是 url 这个参数，比如我要设置绑定域名的，这里就需要填写我的域名信息</span>
<span style="color:#75715e">## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;</span>
url: http://code.youmeek.com
root: /
permalink: :year/:month/:day/:title/
permalink_defaults:

<span style="color:#75715e"># Directory</span>
source_dir: source
public_dir: public
tag_dir: tags
archive_dir: archives
category_dir: categories
code_dir: downloads/code
i18n_dir: :lang
skip_render:

<span style="color:#75715e"># Writing</span>
new_post_name: :title.md <span style="color:#75715e"># File name of new posts</span>
default_layout: post
titlecase: false <span style="color:#75715e"># Transform title into titlecase</span>
external_link: true <span style="color:#75715e"># Open external links in new tab</span>
filename_case: <span style="color:#ae81ff">0</span>
render_drafts: false
post_asset_folder: false
relative_link: false
future: true
highlight:
  enable: true
  line_number: true
  auto_detect: false
  tab_replace:

<span style="color:#75715e"># Category &amp; Tag</span>
default_category: uncategorized
category_map:
tag_map:

<span style="color:#75715e"># Date / Time format</span>
<span style="color:#75715e">## Hexo uses Moment.js to parse and display date</span>
<span style="color:#75715e">## You can customize the date format as defined in</span>
<span style="color:#75715e">## http://momentjs.com/docs/#/displaying/format/</span>
date_format: YYYY-MM-DD
time_format: HH:mm:ss

<span style="color:#75715e"># Pagination</span>
<span style="color:#75715e">## Set per_page to 0 to disable pagination</span>
per_page: <span style="color:#ae81ff">10</span>
pagination_dir: page

<span style="color:#75715e"># Extensions</span>
<span style="color:#75715e">## Plugins: https://hexo.io/plugins/</span>
<span style="color:#75715e">## Themes: https://hexo.io/themes/</span>
theme: yelee

<span style="color:#75715e"># Deployment</span>
<span style="color:#75715e">## 这里是重点，这里是修改发布地址，因为我们前面已经加了 SSH 密钥信息在 Github 设置里面了，所以只要我们电脑里面持有那两个密钥文件就可以无需密码地跟 Github 做同步。</span>
<span style="color:#75715e">## 需要注意的是这里的 repo 采用的是 ssh 的地址，而不是 https 的。分支我们默认采用 master 分支，以后你翅膀硬了要换其他也无所谓。</span>
<span style="color:#75715e">## Docs: https://hexo.io/docs/deployment.html</span>
deploy:
  type: git
  repo: git@github.com:judasn/judasn.github.io.git
  branch: master
  
</code></pre></div><ul>
<li>编辑全局配置后我们需要重新部署：
<ul>
<li>继续在 Git Bash 中输入命令：</li>
<li>先清除掉已经生成的旧文件：<code>hexo clean</code></li>
<li>再生成一次静态文件：<code>hexo generate</code></li>
<li>在本地预览下：<code>hexo server</code></li>
<li>本地没问题之后，Ctrl + C 停掉本地预览。</li>
<li>在部署到 Github 之前，需要先确定你是否已经用过 Git，如果你没用过，则此时你需要做如下设置，在 Git Bash 中依次输入下面两个命令：
<ul>
<li><code>git config --global user.email &quot;你的 Github 注册邮箱地址&quot;</code></li>
<li><code>git config --global user.name &quot;你的 Github 用户名&quot;</code></li>
</ul>
</li>
<li>使用部署命令部署到 Github 上：<code>hexo deploy</code>，有弹出下面提示框，请输入：<code>yes</code>
<ul>
<li><img src="http://img.youmeek.com/2016/hexo-start-d-1.jpg" alt="确认提交"></li>
</ul>
</li>
<li>提交成功效果如下：
<ul>
<li><img src="http://img.youmeek.com/2016/hexo-start-d-2.jpg" alt="提交成功"></li>
</ul>
</li>
<li>访问服务器地址进行检查：<a href="http://judasn.github.io">http://judasn.github.io</a>，效果如下
<ul>
<li><img src="http://img.youmeek.com/2016/hexo-start-d-3.jpg" alt="服务器效果"></li>
</ul>
</li>
<li>但是，也不排除你 deploy 不了到 Github，报这个错误：<code>Host key verification failed</code>，那解决办法如下：
<ul>
<li>还是在 Git Bash 界面中，输入如下命令：<code>ssh -T git@github.com</code>，根据界面提示，输入：<code>yes</code> 回车。之后你可以再试一下是否可以 deploy。</li>
</ul>
</li>
</ul>
</li>
<li>通过上面几次流程我们也就可以总结：以后，每次发表新文章要部署都按这样的流程来：
<ul>
<li><code>hexo clean</code></li>
<li><code>hexo generate</code></li>
<li><code>hexo deploy</code></li>
</ul>
</li>
<li>也因为这几个命令太频繁了，所以又有了精简版的命令：
<ul>
<li><code>hexo clean == hexo clean</code></li>
<li><code>hexo g == hexo generate</code></li>
<li><code>hexo s == hexo server</code></li>
<li><code>hexo d == hexo deploy</code></li>
</ul>
</li>
</ul>
<h3 id="heading9">绑定域名</h3>
<ul>
<li>绑定域名不排除会遇到很多网络问题或是七七八八，所以这里先提供先官网的一些说明：
<ul>
<li><a href="https://help.github.com/articles/setting-up-your-pages-site-repository/">https://help.github.com/articles/setting-up-your-pages-site-repository/</a></li>
<li><a href="https://help.github.com/articles/quick-start-setting-up-a-custom-domain/">https://help.github.com/articles/quick-start-setting-up-a-custom-domain/</a></li>
<li><a href="https://help.github.com/articles/setting-up-an-apex-domain/">https://help.github.com/articles/setting-up-an-apex-domain/</a></li>
<li><a href="https://help.github.com/articles/troubleshooting-custom-domains/">https://help.github.com/articles/troubleshooting-custom-domains/</a></li>
<li><a href="https://help.github.com/articles/custom-domain-redirects-for-github-pages-sites/">https://help.github.com/articles/custom-domain-redirects-for-github-pages-sites/</a></li>
</ul>
</li>
<li>首先我们要一个 CNAME 文件（文件名叫 CNAME，没有文件后缀的），把该文件放在 E:\git_work_space\hexo\source 目录下，以后一些需要放在根目录的资源文件都可以放这里。如果你找不到这样的文件可以到我的项目上下载：<a href="https://github.com/judasn/judasn.github.io">https://github.com/judasn/judasn.github.io</a>
<ul>
<li>CNAME 上的内容需要写你具体要绑定的域名信息，比如我是：<strong>code.youmeek.com</strong>，具体你可以参考下图：
<ul>
<li><img src="http://img.youmeek.com/2016/hexo-start-e-1.jpg" alt="设置 CNAME 文件"></li>
</ul>
</li>
</ul>
</li>
<li>接着我们需要到 DNSPOD 上设置域名解析：<a href="https://www.dnspod.cn/">https://www.dnspod.cn/</a>
<ul>
<li><img src="http://img.youmeek.com/2016/hexo-start-e-2.jpg" alt="设置域名解析"></li>
<li><img src="http://img.youmeek.com/2016/hexo-start-e-3.jpg" alt="设置域名解析"></li>
</ul>
</li>
<li>设置好之后，等过几分钟域名解析好之后，我们访问：<a href="http://code.youmeek.com">http://code.youmeek.com</a>，效果如下：
<ul>
<li><img src="http://img.youmeek.com/2016/hexo-start-e-4.jpg" alt="域名访问效果"></li>
<li>2016-08-19 更新：Github 提示，建议我们使用 CNAME 方式来指向，别用 IP，所以建议你这样配置，还是以我的为例：
<ul>
<li>主机记录：code</li>
<li>记录类型：CNAME</li>
<li>记录值：judasn.github.io.（后面的这个点别忘记了）</li>
<li>还有，要记得把 CNAME 那个文件再 deploy 到 Github 哦，不然还是访问不了的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="-intellij-idea-">整合 IntelliJ IDEA 提高效率</h3>
<ul>
<li>为了提交写作效率，我个人建议使用 IntelliJ IDEA 作为 Markdown 编辑工具
<ul>
<li>IntelliJ IDEA 有各种各样的快捷键支持你的操作</li>
<li>IntelliJ IDEA 可以快速地全文检索项目所有的文件</li>
<li>对 JavaScript、CSS、HTML 等常见语言的良好支持，方便你修改你的主题</li>
</ul>
</li>
<li>如果你还不会使用 IntelliJ IDEA 或是 JetBrains 家其他产品，你可以看下我写一整套教程：<a href="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/">http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/</a></li>
<li>现在我们用 IntelliJ IDEA 打开我们本地目录：E:\git_work_space\hexo，打开后效果如下图：
<ul>
<li><img src="http://img.youmeek.com/2016/hexo-start-f-1.jpg" alt="IntelliJ IDEA 打开项目"></li>
</ul>
</li>
<li>由于 IntelliJ IDEA 在 Windows 下的默认终端是 <code>cmd</code> 不好用，我们现在需要重新修改下 IntelliJ IDEA 的终端工具，把它指向我们习惯的 Git Bash，这样方便操作，如下图 gif 演示。
<ul>
<li><img src="http://img.youmeek.com/2016/hexo-start-f-2.gif" alt="IntelliJ IDEA 下操作 hexo"></li>
<li>如 gif 演示，我们可以 IntelliJ IDEA 里面安心写文章、做发布等操作。</li>
</ul>
</li>
<li>为了更稳定地使用 IntelliJ IDEA，在不修改主题的情况下，我们还需要这样做：
<ul>
<li><img src="http://img.youmeek.com/2016/hexo-start-f-3.jpg" alt="IntelliJ IDEA 下操作 hexo"></li>
</ul>
</li>
<li>hexo 新文章内容的开头需要这样定义：
<ul>
<li>categories：表示文章所属分类</li>
<li>tags：表示文章所属标签</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">---
title: 这是文章标题
date: 2016-02-28 17:58:27
categories: <span style="color:#f92672">[</span>Hexo,IntelliJ IDEA<span style="color:#f92672">]</span>
tags: <span style="color:#f92672">[</span>Hexo,IntelliJ IDEA,Git,Github,Node.js<span style="color:#f92672">]</span>
---
</code></pre></div><h2 id="heading10">结束语</h2>
<ul>
<li>我希望从这一篇你也可以再一次了解到 IntelliJ IDEA 的美丽之处。</li>
<li>最后，欢迎再次来到 IntelliJ IDEA 的世界！</li>
</ul>
]]></content>
        </item>
        
    </channel>
</rss>
