<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>橙小张的博客</title>
    <link>https://blog.sailfishc.cn/</link>
    <description>Recent content on 橙小张的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sun, 05 Jan 2020 18:09:12 +0800</lastBuildDate>
    
	<atom:link href="https://blog.sailfishc.cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>OKR入门</title>
      <link>https://blog.sailfishc.cn/life/okr/</link>
      <pubDate>Sun, 05 Jan 2020 18:09:12 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/life/okr/</guid>
      <description>定义 OKR = Objective + Key Result + Tasks（Plans）
OKR是目标+关键结果+任务去实现的
什么是OKR？ OKR是“目标和关键结果”的缩写。该概念是在英特尔公司发明的，并已在包括Google和Zynga在内的世界上最大的技术公司中广泛使用。 OKR旨在在指定的时间内为组织和团队设置策略和目标。在工作期结束时，您的OKR提供参考，以评估您在执行目标方面的表现。 花费一致的精力来确定您的公司战略，并使用OKR以易于消化的方式进行规划，可以真正帮助您的员工了解他们如何为全局做出贡献并与其他团队保持一致。
案例  最快的学习方法就是理解更多的例子
 目标：增加系统驱动力  每个地区的司机人数增加20％ 在所有活动区域中，将驾驶员平均工作时间增加到每周26小时  目标：增加驾驶员的地域覆盖率  将所有活跃城市的覆盖率提高到75％ 在使用高峰时段，将任何覆盖区域的取货时间减少至&amp;lt;10分钟  目标：提高驾驶员幸福感  定义并衡量驾驶员的幸福感评分 将驾驶员幸福感评分提高到75％  目标：增加每位用户的平均观看时间。 假设您一直在跟踪观看时间，则主要结果可能是：
 将总收看时间增加到每天XX分钟 将本机YT应用程序扩展到2个新操作系统 将视频加载时间减少X％  分析  Objective：使我们公司快速发展
  Youtube频道产生100000次观看 在Ins上获取10000的Follow 将网站的自然流量增加20%  分析下这个OKR，Objective是使公司快速发展，但是KR是需要有一定领域知识的，比如YouTube频道的观看次数是不是会使公司发展，INS上的follow会不会使得公司发展，对于外行人来看可能是不了解的，所以设定KR是需要知识的，那对于个人来说，该如何设定属于自己的OKR呢？我总结了下自己遇到的几个问题：
 Objective太大或者是太小 不知道KR如何设定 不清楚用哪些Task去实现目标  一般来说，OKR中的Objective是比较容易确定的（对于个人），但是Objective是不是太大了或者太小了该怎么界定呢？我认为是需要用KR来衡量的，当你清楚你的Objective需要用大于3个KR来实现的话，那么Objective应该是太大了，那如何解决呢？我的建议有两点：
 将部分KR提升为Objective 只实现部分KR  举例来说，如果你的Objective是让身体变好，那么KR有可能是这样的：
 一年去医院看病的次数小于5次 吃药周期小于30天 体重控制在60KG以内 体脂率在20%以内 ………. ………..  这时候你发现KR有很多条，这是有问题的，我的建议是减少KR的个数，选出最重要的几条，例如关于体重和体脂的KR，因为体重和体脂控制好了，会在一定程度减少生病的次数，也就减少了去医院的次数和吃药的周期。</description>
    </item>
    
    <item>
      <title>J.U.C 同步框架（AQS 框架）</title>
      <link>https://blog.sailfishc.cn/posts/2019/12/j.u.c-%E5%90%8C%E6%AD%A5%E6%A1%86%E6%9E%B6aqs-%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Fri, 27 Dec 2019 12:03:29 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/posts/2019/12/j.u.c-%E5%90%8C%E6%AD%A5%E6%A1%86%E6%9E%B6aqs-%E6%A1%86%E6%9E%B6/</guid>
      <description>本文转载自：biezhi.com https://www.cnblogs.com/dennyzhangdd/p/7218510.html
一、论文简介 闲来无事，看看源码，发现了一篇JDK作者的论文《The java.util.concurrent Synchronizer Framework》主要描述了作者对 AbstractQueuedSynchronizer 同步器框架的设计和实现。权威性毋庸置疑！自然需要拜读一下，配上中文翻译，希望大家能有所收获。
二、原文链接 论文英文版原文链接：http://gee.cs.oswego.edu/dl/papers/aqs.pdf
http://gee.cs.oswego.edu/ 这个是老李头的主页，里面有他的部分贡献，感兴趣的可以关注一下，老李头确实比较厉害。
三、中文翻译 摘要 在 J2SE 1.5 的 java.util.concurrent 包（下称 j.u.c 包）中，大部分的同步器（例如锁，屏障等等）都是基于 AbstractQueuedSynchronizer 类（下称 AQS 类），这个简单的框架而构建的。这个框架为同步状态的原子性管理、线程的阻塞和解除阻塞以及排队提供了一种通用的机制。这篇论文主要描述了这个框架基本原理、设计、实现、用法以及性能。
1. 背景介绍 通过 JCP 的 JSR166 规范，Java 的 1.5 版本引入了 j.u.c 包，这个包提供了一系列支持中等程度并发的类。这些组件是一系列的同步器（抽象数据类型(ADT)）。这些同步器主要维护着以下几个功能：内部同步状态的管理(例如：表示一个锁的状态是获取还是释放)，同步状态的更新和检查操作，且至少有一个方法会导致调用线程在同步状态被获取时阻塞，以及在其他线程改变这个同步状态时解除线程的阻塞。上述的这些的实际例子包括：互斥排它锁的不同形式、读写锁、信号量、屏障、Future、事件指示器以及传送队列等。
几乎任一同步器都可以用来实现其他形式的同步器。例如，可以用可重入锁实现信号量或者用信号量实现可重入锁。但是，这样做带来的复杂性，开销，不灵活使其至多只能是个二流工程，且缺乏吸引力。如果任何这样的构造方式不能在本质上比其他形式更简洁，那么开发者就不应该随意地选择其中的某个来构建另一个同步器。取而代之，JSR166 建立了一个小框架，AQS 类。这个框架为构造同步器提供一种通用的机制，并且被 j.u.c 包中大部分类使用，同时很多用户也用它来定义自己的同步器。
在这篇论文的下面部分会讨论这个框架的需求、设计与实现背后的主要思路、示例用法，以及性能指标的一些测量。
2 需求 2.1 功能 同步器一般包含两种方法，一种是 acquire，另一种是 release。acquire 操作阻塞调用的线程，直到或除非同步状态允许其继续执行。而 release 操作则是通过某种方式改变同步状态，使得一或多个被 acquire 阻塞的线程继续执行。
j.u.c 包中并没有对同步器的API做一个统一的定义。因此，有一些类定义了通用的接口（如 Lock），而另外一些则定义了其专有的版本。因此在不同的类中，acquire 和 release 操作的名字和形式会各有不同。例如：Lock.lock，Semaphore.acquire，CountDownLatch.await 和 FutureTask.get，在这个框架里，这些方法都是 acquire 操作。但是，J.U.C 为支持一系列常见的使用选项，在类间都有个一致约定。在有意义的情况下，每一个同步器都支持下面的操作：
 阻塞和非阻塞（例如 tryLock）同步 可选的超时设置，让调用者可以放弃等待 通过中断实现的任务取消，通常是分为两个版本，一个 acquire 可取消，而另一个不可以  同步器的实现根据其状态是否独占而有所不同。独占状态的同步器，在同一时间只有一个线程可以通过阻塞点，而共享状态的同步器可以同时有多个线程在执行。一般锁的实现类往往只维护独占状态，但是，例如计数信号量在数量许可的情况下，允许多个线程同时执行。为了使框架能得到广泛应用，这两种模式都要支持。</description>
    </item>
    
    <item>
      <title>如何使用Unit testing健壮Java代码</title>
      <link>https://blog.sailfishc.cn/posts/2019/12/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8unit-testing%E5%81%A5%E5%A3%AEjava%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Tue, 03 Dec 2019 23:57:32 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/posts/2019/12/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8unit-testing%E5%81%A5%E5%A3%AEjava%E4%BB%A3%E7%A0%81/</guid>
      <description>前言：测试的道理，推荐下王垠的博客，这篇博客不会提高你的测试水平，但是有一些理论和方法上的指导。
 在之前对于测试一直处于写Test Case的状态，使用JUnit结合Spring Test跑下接口，使用断言或者格式化的JSON结果比对下结果，这样也平安无事的写了一段时间的代码，随着对代码的一些要求，去学习了一些书籍和资料，有了一些总结，开始使用Unit testing来健壮我们的Java代码吧。
目录  聊聊我为什么要写这篇Unit Test的文章 Unit testing的目的和要解决的问题 Unit testing的基础 Unit testing的设计原则 Unit testing实践中的问题 使用Groovy来编写测试  我为什么要写这篇Unit testing的文章  写好代码应该是一个有追求的程序员对自己的基本要求
 在初入Java时沉浸在学习各种框架的谜团里，在工作中开始关注自己的代码质量，期间看了《重构》、《重构与模式》，之后接触到了敏捷开发，去了解TDD，就开始实践TDD了，当然，这篇文章不是写TDD（Test Driven Development）的。我也一直在找一本适合我的Test书籍，一直没合适的，期间找到了几本：
 《程序开发人员测试指南》 《Junit实战》  之后白衣推荐了《有效的单元测试》，立即入了这本书，发现这本书很符合我现在的情况，目前书还没看完，先大致的浏览了一遍，想结合耗哥（左耳朵耗子）在专栏中关于高效学习的模板写这篇文章，这也是写本文的初衷。
Unit testing的目的和要解决的问题 维基百科定义：Unit testing - Wikipedia
 In computer programming, unit testing is a software testing method by which individual units of source code, sets of one or more computer program modules together with associated control data, usage procedures, and operating procedures, are tested to determine whether they are fit for use.</description>
    </item>
    
    <item>
      <title>RSS背后的逻辑</title>
      <link>https://blog.sailfishc.cn/life/rss-basic/</link>
      <pubDate>Sun, 01 Dec 2019 18:09:12 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/life/rss-basic/</guid>
      <description>目录  前言 介绍RSS RSS的背后的逻辑论述 RSS实践 总结 参考资源  前言 其实知道RSS也挺久了，但是一直没应用起来，今天正式的了解了一下，发现RSS其实是很能创造生产力的一种工具。
介绍RSS  RSS (originally ** Site Summary** RDF ; later, two competing approaches emerged, which used the backronyms Rich Site Summary and Really Simple Syndication respectively) [2] is a type of web feed [3] which allows users and applications to access updates to websites in a standardized, computer-readable format
 简单来说：RSS指的是允许以标准化计算机可读的方式让用户和应用程序访问网站更新。
RSS的背后的逻辑论述 RSS的机制和软件设计中的一些方式很像：publish/subscribe发布订阅模式，用户作为服务的消费者，是采用主动去拉取（pull）源信息，还是被动的接收（push）信息，也是一个TradeOff的过程，很明显，对于用户来说，人不能像机器，定时的去（pull）数据下来，因为这样太浪费精力，所以RSS订阅的方式出现，提高了生产力。
可能大家都被这种情况困扰过，接收信息的渠道太多，技术博客，新闻网站，某个关注的人的网站，YouTube频道，某个关注的Twitter动态，关注的UP主的直播，购物网站的商品优惠活动，在现在这样信息满天飞，贩卖焦虑的时期，我们要学会过滤信息，只关注自己关心的优质的内容，并且是可学习的，随着时间的变化，我们只保留了这些最优质的的，和自己最匹配的内容，我们每个人在一天的精力都是有限的，不能在每一天都挨个打开各类APP，去浏览信息，去让我们的碎片时间消耗掉，到最后接受了太多的垃圾信息，没有将信息转化为知识，还消耗了一天的精力。
RSS实践  RSS订阅的过程是对自己信息源梳理的过程，我分析了下我自己的信息输入源：
  个人技术博客 公共技术博客网站的某个人的动态 关注的YouTube频道 关注的Github人和仓库 关注的Twitter人的时间线  不是所有的网站都有RSS订阅的，如果我们想订阅的话需要借助一些工具：</description>
    </item>
    
    <item>
      <title>这可能是最全的Redis分布式锁介绍</title>
      <link>https://blog.sailfishc.cn/posts/2019/11/%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Thu, 21 Nov 2019 07:01:41 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/posts/2019/11/%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E5%85%A8%E7%9A%84redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BB%8B%E7%BB%8D/</guid>
      <description>目录  分布式锁介绍 分布式锁的应用场景 分布式锁几种实现方式介绍  Redis ZK 数据库   Redis实现分布式锁的实现原理 易宝分布式锁分析 *实现Redis分布式锁的正确操作 实现Redis分布式锁的错误案例 Redis分布式锁的问题 Redisson的原理及Redission的一些讨论 基于Redisson的分布式锁的使用  分布式锁介绍 定义  A distributed lock manager (DLM) runs in every machine in a cluster, with an identical copy of a cluster-wide lock database. In this way a DLM provides software applications which are distributed across a cluster on multiple machines with a means to synchronize their accesses to shared resources .</description>
    </item>
    
    <item>
      <title>开发人员必备的Docker基础</title>
      <link>https://blog.sailfishc.cn/posts/2019/11/%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BF%85%E5%A4%87%E7%9A%84docker%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 10 Nov 2019 16:01:41 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/posts/2019/11/%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BF%85%E5%A4%87%E7%9A%84docker%E5%9F%BA%E7%A1%80/</guid>
      <description>Docker简介 说到Docker，我们就来谈谈业务应用从旧时代到Docker的发展历程。
旧时代 旧时代是基于Application运转的，一台服务器（无虚拟机时代）部署多个Application，不管是Windows还是Linux其实是无法保证在一台服务器上稳定安全的运行多个应用的，CPU，内存等公共资源的竞争导致应用极为不稳定。
VM阶段 VM让世界变得美好了，VM算是划时代意义的技术，但是VM不是完美的，VM会占用宿主机额外的CPU,RAM和存储（VM不够轻量级），启动慢。
Linux容器 容器技术出现的比较早，只是Docker将Linux容器技术广泛应用了，Docker解决了VM的问题以外，还有如下优点：
 容易上手 解决了运维中的环境问题及服务调度的痛点  Docker安装 Docker提供了桌面安装和服务器安装，对于开发来说，我们可以归类为：
 Windows平台 Mac平台 Linux平台：Ubuntu/CentOS  Windows平台 硬件要求：
 win10 64位 启用Hyper-V和容器特性  安装步骤：Install Docker Desktop on Windows | Docker Documentation
 下载Docker for windows安装包： https://www.docker.com/products/docker-desktop 根据安装向导安装 成功后再CMD中输入docker version查看版本，如果有版本信息表示安装成功  Mac平台 Mac版本和Windows桌面版安装类似，找到下载包，静默安装即可：
 下载地址：下载Docker for windows安装包： https://www.docker.com/products/docker-desktop  Ubuntu安装  Ubuntu安装：Get Docker Engine - Community for Ubuntu | Docker Documentation  Ubuntu有几种方式安装Docker，我们使用便捷脚本来安装Docker
 在Linux打开Shell 执行：curl -fsSL https://get.docker.com -o get-docker.</description>
    </item>
    
    <item>
      <title>学习观</title>
      <link>https://blog.sailfishc.cn/posts/2019/11/%E5%AD%A6%E4%B9%A0%E8%A7%82/</link>
      <pubDate>Sun, 03 Nov 2019 21:01:53 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/posts/2019/11/%E5%AD%A6%E4%B9%A0%E8%A7%82/</guid>
      <description>为学习付费，还是为知识付费，亦或者是为信息付费，在高中时看到一个资料，是一套数学的学习模型，当时心情非常激动，被资料宣传的效果倾倒，觉得有一套这样的学习资料，一定会学有所成，但是最终效果一般，也没考上一个好学校，毕业后坚信Just do IT，选择了IT道路，在IT路上，如何学习也是很重要的一门手艺。
介绍 本篇文章主要是从网络资源《学习观》中做的一些总结，主要包含两部分内容：
 学习理论  学习和记忆 信息和知识 知识的分类   学习工具  思维导图 费曼技巧   学习实战  正确的学习方法 如何学习英文    学习 理论知识 学习和记忆 从上学到工作，一直在学习，也有一些号称终生学习的人，但是好像没人告诉我们什么是学习，或者很少人去思考学习是什么？在上学的时候，听课是学习，做题是学习，考试也是学习，但是这个过程中到底哪些步骤才算是学习呢？学习的结果是学会，那怎么才算是学会呢？抽象的思考下，老师在课堂讲解了A，B，C三个知识点，对应给出了A，B，C三个知识点的题目，你将A，B，C三道题的题目解出来了，说明你学会了A，B，C这三个知识点，但是在考试中出现了你没见过的题目，类似AB，AC，BC，甚至是ABC这种组合的题目，你根据学习的A，B，C的基础知识点没有将题目解出来，这说明你没有学会，那学习究竟是什么呢？
我们将这个过程简化去分析下，有3个数：1，2，3，只有一种规则：乘，那么所有的可能性是：
1 * 1 = 1 1 * 2 = 2 1 * 3 = 3 2 * 1 = 2 2 * 2 = 4 2 * 3 = 6 3 * 1 = 3 3 * 2 = 6 3 * 3 = 9 这个数字是规则是有限的（这也是我们小学数学有可能满分，高中大学很难满分的原因），我们可以使用大脑记忆，出现类似题目可以很快的反馈出结果，但是我们真的学会了吗？没有，因为出现2 * 4的时候就不知道结果了，但是我们通过上面的例子去学习，总结出规律，即使出现其他题目也能解出来的过程就是学习。</description>
    </item>
    
    <item>
      <title>科学上网</title>
      <link>https://blog.sailfishc.cn/posts/2019/11/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</link>
      <pubDate>Fri, 01 Nov 2019 09:56:18 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/posts/2019/11/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</guid>
      <description>本文转自左耳朵耗子
 作者：左耳朵 http://coolshell.cn 更新时间：2019-11-01
这篇文章可以写的更好，欢迎到 https://github.com/haoel/haoel.github.io 更新
 科学上网  0. 序 1. 英文能力 2. 购买VPS  2.1 常规VPS 2.2 CN2 线路 2.3 NCP 线路   3. 搭建 Shadowsocks 和 VPN 服务  3.1 设置Docker服务 3.2 开启 TCP BBR 拥塞控制算法 3.3 设置Shadowsocks服务 3.4 设置L2TP/IPSec服务 3.5 设置PPTP服务   4. 客户端设置  4.1 Shadowsocks 客户端 4.2 VPN 客户端   5. 流量伪装和其它方式  5.1 V2Ray 5.2 Brook   6.</description>
    </item>
    
    <item>
      <title>解决添加到GitIgnore的文件没被忽略的问题</title>
      <link>https://blog.sailfishc.cn/posts/2019/10/%E8%A7%A3%E5%86%B3%E6%B7%BB%E5%8A%A0%E5%88%B0gitignore%E7%9A%84%E6%96%87%E4%BB%B6%E6%B2%A1%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 30 Oct 2019 09:56:18 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/posts/2019/10/%E8%A7%A3%E5%86%B3%E6%B7%BB%E5%8A%A0%E5%88%B0gitignore%E7%9A%84%E6%96%87%E4%BB%B6%E6%B2%A1%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description> 问题简述
 在开发中有时候会遇到把某文件添加到Git Ignore文件中，但是在Commit的时候发现这个文件还是可以被Commit，并没有被忽略掉，在查看了Git的官方文档，发现官网文档已经做了如下解释：
The purpose of gitignore files is to ensure that certain files not tracked by Git remain untracked. To stop tracking a file that is currently tracked, use：git rm —cached. 意思是：gitignore文件的目的是确保未被Git跟踪的某些文件保持未跟踪状态。要停止跟踪当前跟踪的文件，请使用git rm --cached。
 原因
 一般来说出现这种问题的原因是使用了IDE，在创建文件的时候IDE自动给add进去了，被Git追踪管理了。
 具体执行
  如果是单个文件：git rm —cached path/filename 如果是文件夹：git rm -r —cached path   参考文档
  Git - gitignore Documentation Git - git-rm Documentation  </description>
    </item>
    
    <item>
      <title>通过Hugo&#43;Github快速搭建博客</title>
      <link>https://blog.sailfishc.cn/posts/2019/10/%E9%80%9A%E8%BF%87hugo-github%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Thu, 24 Oct 2019 15:05:56 +0800</pubDate>
      
      <guid>https://blog.sailfishc.cn/posts/2019/10/%E9%80%9A%E8%BF%87hugo-github%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</guid>
      <description>写在前面
 程序员总想有自己的一个博客，厌倦了CSDN，简书，掘金这些博客网站，那就自己搭建一个吧，这篇文章包含了从0开始搭建到部署，可以没有自己的域名，自己的服务器，但是面包总会有的。
先罗列下常见的博客网站：
 Hexo WordPress JekyII Ghost Hugo  Hexo是我之前用的博客网站，但是在使用过程中遇到了一些问题：
 node环境问题较多，本身对Node不熟悉，解决成本高 node_modules过大，网络问题下载依赖过慢 编译为html过程越来越慢  后来发现了Hugo，发现Github已经3w多star了，Hugo官网对于Hugo的介绍是：The world’s fastest framework for building websites，总结起来就一句话，那就是快！！！
快速开始  Quick Start | Hugo  Hugo安装很简单，就以Mac为例快速开始：
 安装Hugo：brew install Hugo 查看Hugo版本：Hugo version 新建一个网站，名字为quickstart：Hugo new site quickstart 安装主题  进入目录：cd quickstart 使用Git Init创建Git仓库：git init 下载主题，放入theme目录（名字为ananke）：git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke 使用主题：echo ‘theme = “ananke”’ &amp;gt;&amp;gt; config.toml   新建MarkDown文章（也可以用现有的放入content/posts目录）：Hugo new posts/my-first-post.md 本地预览：Hugo server -D 打开浏览器：http://localhost:1313 搞定🌹  部署 本地搭建好了网站要部署到外部服务上，常见的方式有三种：</description>
    </item>
    
  </channel>
</rss>